<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PDC Sim 2026 (Optimized)</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Roboto:wght@400;700;900&family=Roboto+Condensed:wght@400;700&display=swap"
        rel="stylesheet">

    <!-- PWA Support -->
    <link rel="manifest" href="manifest_karrier.json">
    <meta name="theme-color" content="#0a0e1a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="PDC Sim">
    <link rel="apple-touch-icon" href="icon.png">
    <link rel="icon" type="image/png" href="icon.png">

    <style>
        /* ==================== GLOBAL STYLES ==================== */
        :root {
            --pdc-red: #d50000;
            --pdc-dark-red: #9a0000;
            --pdc-blue: #0e2a3a;
            --pdc-bg: #0a0e1a;
            --pdc-gold: #ffd700;
            --text-grey: #8fa3ad;
            --input-bg: #f5f5f5;
            --pdc-green: #00b359;
            --card-bg: linear-gradient(145deg, #1a1f35, #0f1525);
            --hover-glow: rgba(255, 215, 0, 0.15);
            --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 20px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        body {
            margin: 0;
            background: linear-gradient(135deg, #0a0e1a 0%, #1a1f35 50%, #0a0e1a 100%);
            background-attachment: fixed;
            color: white;
            font-family: 'Roboto', sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100dvh;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* SCROLLBARS */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, var(--pdc-gold), #cc9900);
            border-radius: 10px;
            transition: all 0.3s;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--pdc-gold);
        }

        /* ==================== LAYOUT COMPONENTS ==================== */
        #tournament-hub,
        #post-match-screen,
        #match-screen {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            z-index: 10;
        }

        #setup-screen {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            display: none;
            background: linear-gradient(135deg, #0f1729 0%, #1a2642 50%, #0f1729 100%);
            backdrop-filter: blur(10px);
            z-index: 100;
            box-sizing: border-box;
            overflow: hidden;
            align-items: stretch;
            justify-content: stretch;
        }

        .setup-box {
            background: linear-gradient(145deg, rgba(26, 31, 53, 0.95), rgba(15, 21, 37, 0.95));
            backdrop-filter: blur(20px);
            border-radius: 16px;
            width: 100%;
            max-width: 600px;
            height: 90dvh;
            max-height: 900px;
            border: 1px solid rgba(255, 215, 0, 0.1);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8), 0 0 1px rgba(255, 215, 0, 0.3);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .tabs {
            display: flex;
            background: linear-gradient(180deg, rgba(12, 16, 28, 0.9), rgba(8, 11, 20, 0.95));
            border-bottom: 1px solid rgba(255, 215, 0, 0.2);
            flex-shrink: 0;
            min-height: 40px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .tab-btn {
            flex: 1;
            padding: 10px;
            background: transparent;
            border: none;
            color: #999;
            font-family: 'Roboto Condensed';
            font-weight: bold;
            font-size: 13px;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.3s ease;
            position: relative;
        }

        .tab-btn:hover {
            color: #ccc;
            background: rgba(255, 215, 0, 0.05);
        }

        .tab-btn.active {
            background: rgba(255, 215, 0, 0.08);
            color: var(--pdc-gold);
            border-bottom: 3px solid var(--pdc-gold);
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }

        .tab-content {
            padding: 0;
            display: none;
            flex-direction: column;
            overflow-y: auto;
            flex: 1;
            height: 100%;
        }

        .tab-content.active {
            display: flex;
        }

        .qschool-view,
        .oom-view {
            display: none;
            width: 100%;
        }

        .qschool-view.active {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
        }

        .oom-view.active {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
        }

        /* EVENT INFO MODAL */
        #event-info-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #event-info-modal.active {
            opacity: 1;
        }

        #career-player-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease;
            width: 100%;
            height: 100%;
        }

        #career-player-modal.active {
            opacity: 1;
            display: flex !important;
        }

        .career-player-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            cursor: pointer;
            transition: all 0.2s ease;
            background: #1a1f35;
            color: #ddd;
        }

        .career-player-item:hover {
            background: rgba(255, 215, 0, 0.15);
            color: #fff;
        }

        .event-info-box {
            background: linear-gradient(145deg, #1a1f35, #0f1525);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            width: 90%;
            max-width: 500px;
            padding: 25px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
            color: #fff;
            position: relative;
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        #event-info-modal.active .event-info-box {
            transform: scale(1);
        }

        .event-info-header {
            font-family: 'Roboto Condensed', sans-serif;
            font-size: 24px;
            font-weight: 900;
            color: var(--pdc-gold);
            margin-bottom: 15px;
            text-transform: uppercase;
            text-align: center;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 15px;
        }

        .event-info-details {
            font-size: 14px;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .event-info-details p {
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            padding-bottom: 4px;
        }

        .event-info-results {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }

        .event-info-results h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #aaa;
            text-transform: uppercase;
        }

        .close-event-info {
            background: #333;
            color: #fff;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            display: block;
            margin: 20px auto 0;
            width: 100px;
            transition: all 0.2s;
        }

        .close-event-info:hover {
            background: #444;
            color: var(--pdc-gold);
        }

        /* CONTROLS */
        input,
        select {
            padding: 10px 14px;
            font-family: 'Roboto Condensed', sans-serif;
            font-size: 13px;
            font-weight: 600;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            background: rgba(255, 255, 255, 0.95);
            color: #222;
            outline: none;
            width: 100%;
            box-sizing: border-box;
            height: 40px;
            transition: all 0.3s ease;
            box-shadow: var(--shadow-sm);
        }

        input:hover,
        select:hover {
            border-color: rgba(255, 215, 0, 0.3);
            transform: translateY(-1px);
        }

        input:focus,
        select:focus {
            border-color: var(--pdc-gold);
            background: #fff;
            box-shadow: 0 0 0 3px rgba(255, 215, 0, 0.1), var(--shadow-md);
            transform: translateY(-1px);
        }

        .format-row {
            display: flex;
            gap: 10px;
        }

        .format-btn {
            flex: 1;
            padding: 10px;
            background: linear-gradient(145deg, #1a1f35, #12172a);
            border: 2px solid rgba(255, 255, 255, 0.1);
            color: #aaa;
            font-weight: bold;
            cursor: pointer;
            border-radius: 8px;
            text-align: center;
            font-size: 12px;
            height: 40px;
            transition: all 0.3s ease;
            box-shadow: var(--shadow-sm);
        }

        .format-btn:hover {
            background: linear-gradient(145deg, #1f2540, #161b30);
            border-color: rgba(255, 215, 0, 0.3);
            color: #ddd;
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .format-btn.selected {
            background: linear-gradient(135deg, var(--pdc-gold), #cc9900);
            color: #000;
            border-color: var(--pdc-gold);
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
            transform: translateY(-2px);
        }

        .btn-gold,
        .btn-blue,
        .btn-hub-action {
            font-weight: 900;
            cursor: pointer;
            padding: 12px 20px;
            font-size: 14px;
            text-transform: uppercase;
            border: none;
            border-radius: 10px;
            width: 100%;
            flex-shrink: 0;
            font-family: 'Roboto Condensed';
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .btn-gold {
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #111;
            margin: 5px 0;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
        }

        .btn-gold:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(255, 215, 0, 0.5);
        }

        .btn-gold:active {
            transform: translateY(0);
        }

        .btn-blue {
            background: linear-gradient(135deg, #2563eb, #1d4ed8);
            color: white;
            margin: 10px 0;
            box-shadow: 0 4px 15px rgba(37, 99, 235, 0.3);
        }

        .btn-blue:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(37, 99, 235, 0.5);
        }

        .btn-hub-action {
            font-size: 12px;
            color: white;
            flex: 1;
        }

        .btn-sim {
            background: linear-gradient(135deg, var(--pdc-green), #009647);
            box-shadow: 0 4px 15px rgba(0, 179, 89, 0.3);
        }

        .btn-sim:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(0, 179, 89, 0.5);
        }

        .btn-watch {
            background: linear-gradient(135deg, #f97316, #ea580c);
            box-shadow: 0 4px 15px rgba(249, 115, 22, 0.3);
        }

        .btn-watch:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(249, 115, 22, 0.5);
        }

        /* LISTS */
        .search-dropdown-container {
            position: relative;
            width: 100%;
        }

        .search-results-list {
            position: absolute;
            top: calc(100% + 5px);
            left: 0;
            width: 100%;
            max-height: 220px;
            overflow-y: auto;
            background: linear-gradient(145deg, #1a1f35, #12172a);
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 8px;
            z-index: 1000;
            display: none;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
        }

        .search-item {
            padding: 10px 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
            color: #ddd;
            transition: all 0.2s ease;
        }

        .search-item:hover {
            background: rgba(255, 215, 0, 0.1);
            color: var(--pdc-gold);
            padding-left: 16px;
        }

        .search-item img {
            width: 18px;
            height: 12px;
            object-fit: cover;
        }

        .player-selector-box {
            display: none;
            flex-direction: column;
            background: #111;
            border: 1px solid #444;
            margin-top: 5px;
            border-radius: 4px;
            overflow: hidden;
            flex-shrink: 0;
        }

        .player-list-container {
            height: 200px;
            overflow-y: auto;
            background: #161616;
            border-top: 1px solid #333;
        }

        .tc-badge {
            font-size: 9px;
            background: var(--pdc-gold);
            color: black;
            padding: 2px 4px;
            border-radius: 2px;
            margin-left: auto;
            font-weight: bold;
        }

        .tourn-config-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 5px;
            max-height: 120px;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .checkbox-row {
            display: flex;
            align-items: center;
            cursor: pointer;
            margin-top: 5px;
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.03), rgba(255, 255, 255, 0.01));
            padding: 12px;
            border-radius: 8px;
            flex-shrink: 0;
            border: 1px solid rgba(255, 255, 255, 0.08);
            transition: all 0.3s ease;
        }

        .checkbox-row:hover {
            background: rgba(255, 215, 0, 0.05);
            border-color: rgba(255, 215, 0, 0.2);
        }

        .checkbox-row input {
            width: 18px;
            height: 18px;
            margin-right: 10px;
            accent-color: var(--pdc-gold);
            cursor: pointer;
        }

        .pc-row {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-weight: bold;
            font-size: 10px;
            color: #8fa3ad;
            text-transform: uppercase;
            margin-bottom: 2px;
            display: block;
        }

        /* SEASON UI */
        .season-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            flex: 1;
            min-height: 0;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 2px;
            padding-bottom: 16px;
        }

        .season-event {
            background: linear-gradient(145deg, rgba(26, 31, 53, 0.7), rgba(18, 23, 40, 0.8));
            padding: 16px 20px;
            border-radius: 12px;
            border-left: 4px solid rgba(255, 215, 0, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            opacity: 0.9;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-left-width: 4px;
        }

        .season-event:hover {
            opacity: 1;
            transform: translateX(4px);
            border-left-color: var(--pdc-gold);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.15);
        }

        .season-event.active {
            opacity: 1;
            border-left-color: var(--pdc-gold);
            background: linear-gradient(145deg, #1f2540, #161b30);
            box-shadow: 0 4px 20px rgba(255, 215, 0, 0.2), inset 0 0 30px rgba(255, 215, 0, 0.05);
        }

        .season-event.completed {
            opacity: 0.5;
            border-left-color: var(--pdc-green);
            text-decoration: line-through;
        }

        .s-date {
            font-size: 10px;
            color: #6b7b88;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .s-name {
            font-size: 15px;
            font-weight: bold;
            color: #ffffff;
            margin: 4px 0 2px 0;
            letter-spacing: 0.5px;
        }

        .s-winner {
            font-size: 12px;
            color: var(--pdc-gold);
            font-weight: 600;
        }

        .season-event-logo {
            height: 24px;
            opacity: 0.8;
            margin-right: 10px;
            flex-shrink: 0;
        }

        /* CAREER MODE UI */
        .career-hero {
            background: linear-gradient(135deg, rgba(10, 14, 26, 0.9), rgba(24, 36, 68, 0.9));
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 14px;
            padding: 14px;
            box-shadow: var(--shadow-md);
            position: relative;
            overflow: hidden;
        }

        .career-hero::after {
            content: "";
            position: absolute;
            right: -40px;
            top: -40px;
            width: 140px;
            height: 140px;
            background: radial-gradient(circle, rgba(255, 215, 0, 0.2), rgba(255, 215, 0, 0));
            opacity: 0.6;
        }

        .career-hero-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 28px;
            letter-spacing: 2px;
            color: var(--pdc-gold);
            text-transform: uppercase;
        }

        .career-hero-sub {
            font-size: 12px;
            color: #a8b5c1;
            margin-top: 4px;
        }

        .career-hero-chip {
            display: inline-flex;
            gap: 6px;
            align-items: center;
            font-size: 11px;
            color: #fff;
            background: rgba(0, 0, 0, 0.35);
            padding: 6px 10px;
            border-radius: 999px;
            margin-top: 10px;
        }

        .career-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        @media (min-width: 720px) {
            .career-grid {
                grid-template-columns: 1.1fr 1fr;
            }
        }

        .career-panel {
            background: linear-gradient(145deg, rgba(26, 31, 53, 0.9), rgba(15, 21, 37, 0.95));
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 14px;
            padding: 12px;
            box-shadow: var(--shadow-sm);
        }

        .career-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #c8d1d8;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .career-player-card {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .career-player-name {
            font-size: 16px;
            font-weight: 900;
            color: #fff;
        }

        .career-player-meta {
            font-size: 11px;
            color: #8fa3ad;
        }

        .career-label {
            font-size: 10px;
            text-transform: uppercase;
            color: #8fa3ad;
            font-weight: bold;
        }

        .career-stat-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .career-stat {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 10px;
            padding: 8px;
            text-align: center;
        }

        .career-stat-label {
            font-size: 9px;
            color: #8fa3ad;
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .career-stat-value {
            font-size: 13px;
            font-weight: bold;
            color: var(--pdc-gold);
        }

        .career-actions {
            display: flex;
            gap: 6px;
            margin-bottom: 10px;
        }

        .career-day-summary {
            font-size: 10px;
            color: #8fa3ad;
        }

        .career-day-events {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 220px;
            overflow-y: auto;
            padding-right: 2px;
        }

        .career-calendar-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-height: 420px;
            overflow-y: auto;
            padding: 10px;
            background: transparent;
        }

        .career-training-panel {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 10px;
            margin-bottom: 10px;
        }

        .career-training-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
            margin-top: 8px;
        }

        .career-training-btn {
            background: linear-gradient(145deg, #1a233f, #141b30);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            padding: 8px;
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
        }

        .career-training-btn:hover {
            border-color: rgba(255, 215, 0, 0.4);
            color: var(--pdc-gold);
        }

        .career-intel-tabs {
            display: flex;
            gap: 6px;
        }

        .career-intel-tab {
            background: rgba(255, 255, 255, 0.05);
            color: #8fa3ad;
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 999px;
            padding: 4px 10px;
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
        }

        .career-intel-tab.active {
            background: var(--pdc-gold);
            color: #111;
        }

        .career-news-feed {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 280px;
            overflow-y: auto;
        }

        .career-standings-tabs,
        .career-standings-subtabs {
            display: flex;
            gap: 6px;
            margin-bottom: 8px;
        }

        .career-standings-tab,
        .career-standings-subtab {
            background: rgba(255, 255, 255, 0.05);
            color: #8fa3ad;
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            padding: 4px 10px;
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
        }

        .career-standings-tab.active,
        .career-standings-subtab.active {
            background: rgba(255, 215, 0, 0.2);
            color: var(--pdc-gold);
            border-color: rgba(255, 215, 0, 0.4);
        }

        .career-calendar .season-event,
        .career-day-events .season-event {
            border-left-color: rgba(255, 215, 0, 0.4);
            background: linear-gradient(145deg, rgba(20, 27, 48, 0.95), rgba(13, 18, 33, 0.95));
        }

        .career-calendar .season-event.completed {
            border-left-color: rgba(0, 179, 89, 0.7);
        }

        .career-muted {
            font-size: 10px;
            color: #8fa3ad;
            text-transform: none;
        }

        .career-shell {
            display: flex;
            gap: 0;
            min-height: 520px;
            background: linear-gradient(135deg, #0d1219 0%, #1a2332 50%, #0d1219 100%);
        }

        .career-sidebar {
            width: 170px;
            background: linear-gradient(180deg, #1a2332 0%, #151d2a 100%);
            border: none;
            border-radius: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            gap: 0;
            box-shadow: none;
            align-items: center;
            /* Center content */
            text-align: center;
        }

        .career-brand {
            display: flex;
            flex-direction: column;
            align-items: center;
            /* Center brand */
            font-family: 'Bebas Neue', sans-serif;
            font-size: 11px;
            letter-spacing: 1.5px;
            color: #fff;
            padding: calc(25px + env(safe-area-inset-top)) 15px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            width: 100%;
        }

        .career-brand span {
            font-size: 18px;
            color: #000;
            background: var(--pdc-gold);
            padding: 2px 8px;
            border-radius: 3px;
            letter-spacing: 1px;
            font-weight: bold;
            margin-top: 2px;
        }

        .career-nav {
            display: flex;
            flex-direction: column;
            gap: 0;
            padding: 10px 0;
        }

        .career-nav-btn {
            background: transparent;
            border: none;
            border-left: 3px solid transparent;
            color: #6b7a8a;
            padding: 12px 15px;
            border-radius: 0;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            text-align: center;
            /* Center text */
            transition: all 0.2s;
            position: relative;
            font-weight: 600;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .career-nav-btn::before {
            content: '';
            margin-right: 0;
            /* Align icon center */
            font-size: 18px;
        }

        .career-nav-btn:nth-child(1)::before {
            content: '‚äû';
        }

        .career-nav-btn:nth-child(2)::before {
            content: 'üìÖ';
        }

        .career-nav-btn:nth-child(3)::before {
            content: 'üìä';
        }

        .career-nav-btn:nth-child(4)::before {
            content: 'üéØ';
        }

        .career-nav-btn:nth-child(5)::before {
            content: 'üì∞';
        }

        .career-nav-btn:nth-child(6)::before {
            content: 'üè†';
        }

        .career-nav-btn:hover {
            background: rgba(255, 215, 0, 0.05);
            color: #a8b5c0;
        }

        .career-nav-btn.active {
            background: rgba(255, 215, 0, 0.12);
            color: var(--pdc-gold);
            border-left-color: var(--pdc-gold);
        }

        /* Prevent Clipping Fix */
        .career-start,
        .career-start-card {
            margin: auto;
        }

        .career-brand {
            padding-top: calc(20px + env(safe-area-inset-top));
        }

        .career-sidebar-card {
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 12px;
            margin: 15px 10px;
        }

        .career-sidebar-label {
            font-size: 8px;
            text-transform: uppercase;
            color: #5a6b7a;
            font-weight: bold;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
            text-align: center;
        }

        .career-sidebar-name {
            font-size: 15px;
            font-weight: 900;
            color: #fff;
            margin: 2px 0 4px;
        }

        .career-sidebar-meta {
            font-size: 10px;
            color: #5a6b7a;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .career-sidebar-meta::before {
            content: 'üìç';
            font-size: 12px;
        }

        .career-menu-overlay {
            position: fixed;
            inset: 0;
            background: radial-gradient(circle at center, #1a2332 0%, #0a0e1a 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .career-menu-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 20px;
            padding: 40px;
            width: 400px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
        }

        .career-menu-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 3.5rem;
            color: var(--pdc-gold);
            margin-bottom: 30px;
            letter-spacing: 2px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        .career-menu-actions {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .btn-menu {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            padding: 18px;
            border-radius: 12px;
            font-weight: 700;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .btn-menu:hover {
            background: var(--pdc-gold);
            color: #000;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.2);
        }

        .btn-menu.btn-back-hub {
            background: rgba(220, 38, 38, 0.1);
            border-color: rgba(220, 38, 38, 0.3);
            color: #ff6666;
            margin-top: 10px;
        }

        .btn-menu.btn-back-hub:hover {
            background: #dc2626;
            color: #fff;
            border-color: #dc2626;
        }

        .career-select-btn {
            width: 100%;
            background: rgba(255, 255, 255, 0.03);
            color: #8fa3ad;
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 6px;
            padding: 8px;
            font-size: 9px;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
        }

        .career-select-btn:hover {
            background: rgba(255, 255, 255, 0.06);
            color: var(--pdc-gold);
        }

        .career-mini-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            padding: 0 12px;
        }

        .career-mini-item {
            background: transparent;
            border: none;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 0;
            padding: 8px 0;
            text-align: left;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .career-mini-label {
            font-size: 9px;
            color: #5a6b7a;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .career-mini-value {
            font-size: 12px;
            font-weight: bold;
            color: var(--pdc-gold);
        }

        #career-latest-news {
            margin: auto 12px 12px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            font-size: 9px;
            color: #5a6b7a;
            line-height: 1.4;
        }

        .career-sidebar-actions {
            margin-top: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 15px 12px;
        }

        .career-sidebar-actions .btn-gold {
            font-size: 10px;
            padding: 10px;
            font-weight: 700;
        }

        .career-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 20px;
        }

        .career-topbar {
            display: flex;
            flex-direction: column;
            gap: 15px;
            background: rgba(26, 35, 50, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 12px;
            padding: 16px 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            margin-bottom: 10px;
        }

        .career-topbar-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .career-horizontal-nav {
            display: flex;
            gap: 4px;
            background: rgba(0, 0, 0, 0.2);
            padding: 4px;
            border-radius: 8px;
        }

        .career-nav-btn {
            background: none;
            border: none;
            color: #8fa3ad;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
            padding: 8px 15px;
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 6px;
        }

        .career-nav-btn:hover {
            color: #fff;
            background: rgba(255, 255, 255, 0.05);
        }

        .career-nav-btn.active {
            color: #000;
            background: var(--pdc-gold);
        }

        .career-topbar-stats {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .career-brand-mini {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 18px;
            letter-spacing: 1px;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .career-brand-mini span {
            font-size: 14px;
            color: #000;
            background: var(--pdc-gold);
            padding: 1px 6px;
            border-radius: 3px;
            font-weight: bold;
        }

        .career-date {
            font-size: 16px;
            font-weight: bold;
            color: #fff;
        }

        .career-topbar-right {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .career-pill {
            background: rgba(0, 0, 0, 0.35);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 999px;
            padding: 6px 10px;
            font-size: 11px;
            text-transform: uppercase;
            color: #8fa3ad;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .career-pill span {
            color: var(--pdc-gold);
            font-weight: bold;
        }

        .career-main-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 12px;
        }

        .career-card {
            background: rgba(26, 35, 50, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .career-card-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #c8d1d8;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .career-link {
            background: none;
            border: none;
            padding: 0;
            text-align: left;
            cursor: pointer;
        }

        .career-link:hover {
            color: var(--pdc-gold);
        }

        .career-bar-row {
            display: grid;
            grid-template-columns: 110px 1fr 50px;
            gap: 8px;
            align-items: center;
            font-size: 11px;
            color: #8fa3ad;
            margin-bottom: 6px;
        }

        .career-bar {
            height: 8px;
            background: rgba(0, 0, 0, 0.35);
            border-radius: 999px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .career-bar-fill {
            height: 100%;
            width: 0;
            background: linear-gradient(90deg, var(--pdc-gold), #ffd27a);
            transition: width 0.4s ease;
        }

        .career-stat-text {
            color: #fff;
            font-weight: bold;
        }

        .career-calendar-card .career-calendar-list {
            max-height: 360px;
        }

        .career-training-overlay {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(6, 10, 18, 0.75);
            z-index: 200;
        }

        .career-training-overlay.active {
            display: flex;
            animation: careerFadeIn 0.2s ease;
        }

        .career-training-card {
            background: linear-gradient(145deg, rgba(26, 31, 53, 0.95), rgba(15, 21, 37, 0.98));
            border: 1px solid rgba(255, 215, 0, 0.25);
            border-radius: 16px;
            padding: 18px 22px;
            min-width: 280px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            animation: careerPop 0.35s ease;
        }

        .career-event-overlay {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(6, 10, 18, 0.75);
            z-index: 220;
        }

        .career-event-overlay.active {
            display: flex;
            animation: careerFadeIn 0.2s ease;
        }

        .career-event-card {
            background: linear-gradient(145deg, rgba(24, 30, 48, 0.98), rgba(12, 17, 31, 0.98));
            border: 1px solid rgba(255, 215, 0, 0.25);
            border-radius: 16px;
            padding: 18px 22px;
            min-width: 320px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            animation: careerPop 0.35s ease;
        }

        .career-event-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 22px;
            letter-spacing: 2px;
            color: var(--pdc-gold);
            margin-bottom: 4px;
        }

        .career-event-sub {
            font-size: 12px;
            color: #8fa3ad;
            margin-bottom: 10px;
        }

        .career-event-stats {
            display: grid;
            gap: 6px;
            font-size: 12px;
            color: #d7e1e8;
        }

        .career-event-stats strong {
            color: var(--pdc-gold);
        }

        .career-overlay {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: transparent;
            z-index: 230;
            padding: 0;
        }

        .career-overlay.active {
            display: flex;
            animation: careerFadeIn 0.2s ease;
        }

        .career-overlay-card {
            width: 100%;
            height: 100%;
            overflow-y: auto;
            background: linear-gradient(135deg, #0a0e1a 0%, #1a1f35 50%, #0a0e1a 100%);
            border: none;
            border-radius: 0;
            padding: 0;
            box-shadow: none;
        }

        .career-overlay-topbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0, 0, 0, 0.4);
            border-bottom: 2px solid rgba(255, 215, 0, 0.3);
            padding: 20px 30px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .career-overlay-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 28px;
            letter-spacing: 3px;
            color: var(--pdc-gold);
            text-transform: uppercase;
            font-weight: 600;
        }

        .career-overlay-content {
            padding: 30px 40px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .career-overlay-panel {
            background: linear-gradient(145deg, rgba(26, 31, 53, 0.7), rgba(15, 21, 37, 0.85));
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 14px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            margin-bottom: 20px;
        }

        .career-training-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 22px;
            letter-spacing: 2px;
            color: var(--pdc-gold);
        }

        .career-training-sub {
            font-size: 12px;
            color: #8fa3ad;
            margin-top: 4px;
        }

        .career-training-stats {
            margin-top: 10px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 11px;
            color: #d7e1e8;
        }

        .career-training-stats div {
            background: rgba(0, 0, 0, 0.3);
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .career-training-stats strong {
            color: var(--pdc-gold);
        }

        @keyframes careerFadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes careerPop {
            from {
                transform: scale(0.95);
                opacity: 0.6;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        @media (max-width: 980px) {
            .career-shell {
                flex-direction: column;
            }

            .career-sidebar {
                width: 100%;
            }

            .career-main-grid {
                grid-template-columns: 1fr;
            }
        }

        body.career-fullscreen #setup-screen .setup-box {
            width: 100%;
            max-width: none;
            height: 100vh;
            border-radius: 0;
        }

        body.career-fullscreen #setup-screen .tabs {
            display: none;
        }

        body.career-fullscreen #tab-season {
            height: 100vh;
        }

        .career-start {
            display: none;
            height: 100%;
            align-items: center;
            justify-content: center;
            padding: 28px;
        }

        .career-start-card {
            width: min(680px, 100%);
            height: auto;
            background: radial-gradient(120% 120% at 10% 0%, rgba(255, 215, 0, 0.12), transparent 55%),
                linear-gradient(165deg, rgba(24, 34, 54, 0.98) 0%, rgba(16, 22, 36, 0.96) 60%, rgba(12, 16, 28, 0.98) 100%);
            border: 1px solid rgba(255, 215, 0, 0.18);
            border-radius: 18px;
            padding: 28px 32px 32px;
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.65), 0 0 0 1px rgba(255, 215, 0, 0.08) inset;
            position: relative;
            overflow: hidden;
        }

        .career-start-card::after {
            content: "";
            position: absolute;
            inset: 0;
            background: radial-gradient(200px 200px at 100% -20%, rgba(56, 189, 248, 0.14), transparent 60%);
            pointer-events: none;
        }

        .career-start-title {
            margin-top: 60px;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 34px;
            letter-spacing: 4px;
            color: var(--pdc-gold);
            text-transform: uppercase;
            margin-bottom: 18px;
            text-align: center;
            text-shadow: 0 0 14px rgba(255, 215, 0, 0.35);
        }

        .career-start-tabs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 16px;
            background: rgba(10, 16, 28, 0.55);
            border-radius: 12px;
            padding: 6px;
            border: 1px solid rgba(255, 255, 255, 0.06);
        }

        .career-start-tab {
            flex: 1;
            background: transparent;
            border: 1px solid transparent;
            color: #9aa9b6;
            padding: 11px 14px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 800;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
        }

        .career-start-tab:hover {
            background: rgba(255, 255, 255, 0.04);
            color: #c4d0dc;
        }

        .career-start-tab.active {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 215, 0, 0.05));
            color: var(--pdc-gold);
            border-color: rgba(255, 215, 0, 0.35);
            box-shadow: 0 8px 22px rgba(255, 215, 0, 0.15);
        }

        .career-start-pane {
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        .career-start-pane label {
            font-size: 10px;
            font-weight: 700;
            color: #94a4b2;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
            display: block;
        }

        .career-start-pane input[type="text"],
        .career-start-pane input[type="number"],
        .career-start-pane select {
            width: 100%;
            background: rgba(8, 12, 22, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 12px 14px;
            color: #eaf0f6;
            font-size: 14px;
            outline: none;
            transition: all 0.2s;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02), 0 6px 18px rgba(0, 0, 0, 0.3);
        }

        .career-start-pane input[type="text"]:focus,
        .career-start-pane input[type="number"]:focus,
        .career-start-pane select:focus {
            background: rgba(10, 14, 26, 0.95);
            border-color: rgba(255, 215, 0, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 215, 0, 0.15), 0 10px 22px rgba(0, 0, 0, 0.4);
        }

        .career-start-slider {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .career-start-slider input[type="range"] {
            flex: 1;
            appearance: none;
            height: 10px;
            border-radius: 999px;
            background: linear-gradient(90deg, #22c55e, #fbbf24, #fb923c, #ef4444);
            outline: none;
            cursor: pointer;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.08);
        }

        .career-start-slider input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #0b0f1c;
            border: 3px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 0 4px rgba(255, 215, 0, 0.25), 0 4px 12px rgba(0, 0, 0, 0.5);
            cursor: pointer;
            transition: all 0.2s;
        }

        .career-start-slider input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.08);
        }

        .career-start-slider input[type="range"]::-moz-range-thumb {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #0b0f1c;
            border: 3px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 0 4px rgba(255, 215, 0, 0.25), 0 4px 12px rgba(0, 0, 0, 0.5);
            cursor: pointer;
        }

        .career-start-pill {
            background: linear-gradient(135deg, #f8d463, #d6a51b);
            color: #10131b;
            font-weight: 900;
            padding: 6px 16px;
            border-radius: 999px;
            min-width: 80px;
            text-align: center;
            font-size: 13px;
            box-shadow: 0 10px 20px rgba(255, 215, 0, 0.25);
        }

        .career-start-actions {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 16px;
        }

        .career-start-actions button {
            width: 100%;
            padding: 14px;
            font-weight: 800;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1.2px;
        }

        .career-start-actions .btn-gold {
            background: linear-gradient(135deg, #f8d463 0%, #d6a51b 100%);
            border: none;
            box-shadow: 0 10px 20px rgba(248, 212, 99, 0.3);
        }

        .career-start-actions .btn-gold:hover {
            background: linear-gradient(135deg, #ffe08c 0%, #e1b733 100%);
            transform: translateY(-1px);
            box-shadow: 0 12px 24px rgba(248, 212, 99, 0.4);
        }

        .career-start-actions .btn-blue {
            background: linear-gradient(135deg, #25314a 0%, #1a2438 100%);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.35);
            transition: all 0.2s;
        }

        .career-start-actions .btn-blue:hover {
            background: linear-gradient(135deg, #2e3c58 0%, #202a40 100%);
            transform: translateY(-1px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
        }

        .career-start-pane .checkbox-row {
            background: linear-gradient(135deg, rgba(8, 12, 22, 0.9), rgba(18, 24, 38, 0.85));
            border: 1px solid rgba(255, 215, 0, 0.22);
            border-radius: 12px;
            padding: 14px 16px;
            display: flex;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 8px 18px rgba(0, 0, 0, 0.35);
        }

        .career-start-pane .checkbox-row:hover {
            background: linear-gradient(135deg, rgba(18, 26, 40, 0.95), rgba(22, 30, 46, 0.9));
            border-color: rgba(255, 215, 0, 0.4);
        }

        .career-start-pane .checkbox-row input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin-right: 12px;
            accent-color: var(--pdc-gold);
            cursor: pointer;
        }

        .career-start-pane .checkbox-row label {
            margin: 0;
            color: #d1dae3;
            font-size: 12px;
            text-transform: none;
            font-weight: 600;
            cursor: pointer;
            letter-spacing: 0.3px;
        }

        .career-player-box {
            width: 100%;
            height: 100%;
            margin-top: 60px;
            padding: 50px;
            background: radial-gradient(120% 120% at 0% 0%, rgba(255, 215, 0, 0.12), transparent 50%),
                linear-gradient(170deg, rgba(21, 28, 44, 0.98), rgba(12, 16, 28, 0.98));
            border: none;
            border-radius: 0;
            box-shadow: none;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        #career-player-modal .format-btn {
            height: 36px;
            border-radius: 10px;
            font-size: 11px;
        }

        #career-player-modal input[type="text"],
        #career-player-modal input[type="number"],
        #career-player-modal select {
            background: rgba(8, 12, 22, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            color: #eaf0f6;
        }

        #career-start-list,
        #career-player-list {
            background: rgba(9, 12, 20, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.03);
        }

        .career-controls {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .career-controls-row {
            display: flex;
            gap: 6px;
        }

        /* UPDATED OOM STYLES */
        .oom-container {
            flex: 1;
            min-height: 0;
            overflow-y: auto;
            margin-top: 10px;
            border: 1px solid rgba(255, 215, 0, 0.2);
            background: linear-gradient(145deg, rgba(0, 0, 0, 0.6), rgba(10, 14, 26, 0.8));
            backdrop-filter: blur(5px);
            border-radius: 8px;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .oom-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            table-layout: fixed;
            height: fit-content;
            background: rgba(0, 0, 0, 0.2);
        }

        /* Sticky header with solid background so content doesn't show under it */
        .oom-table th {
            text-align: left;
            color: #ffffff;
            border-bottom: 2px solid var(--pdc-gold);
            padding: 12px 14px;
            position: sticky;
            top: 0;
            background: linear-gradient(180deg, rgba(26, 31, 53, 0.95), rgba(18, 23, 40, 0.95));
            backdrop-filter: blur(10px);
            z-index: 5;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.4);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-size: 11px;
        }

        .oom-table td {
            padding: 10px 14px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            color: #d7e1e8;
        }

        .oom-table tr:hover {
            background: rgba(255, 215, 0, 0.05);
        }

        .oom-pos {
            width: 30px;
            font-weight: bold;
            color: var(--pdc-gold);
            text-align: center;
        }

        .oom-money {
            text-align: right;
            color: #ccc;
            font-family: 'Roboto Condensed';
            font-weight: bold;
        }

        /* OOM Tabs */
        .oom-nav {
            display: flex;
            gap: 8px;
            background: rgba(0, 0, 0, 0.3);
            margin-top: 10px;
            padding: 8px;
            border-radius: 8px;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .oom-nav-btn {
            flex: 1;
            padding: 10px 16px;
            background: rgba(26, 31, 53, 0.6);
            color: #8fa3ad;
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 6px;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.25s ease;
            min-width: 100px;
        }

        .oom-nav-btn:hover {
            background: rgba(26, 31, 53, 0.8);
            border-color: rgba(255, 215, 0, 0.3);
            color: #c5d3dc;
        }

        .oom-nav-btn.active {
            background: linear-gradient(145deg, rgba(255, 215, 0, 0.15), rgba(255, 215, 0, 0.08));
            color: var(--pdc-gold);
            border-color: var(--pdc-gold);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.2), inset 0 1px 2px rgba(255, 255, 255, 0.1);
        }

        /* HUB & BRACKET */
        #tournament-hub {
            background: linear-gradient(135deg, #0a0e1a 0%, #1a1f35 50%, #0a0e1a 100%);
            z-index: 90;
            padding: 0;
        }

        .hub-header {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            background: linear-gradient(180deg, rgba(26, 31, 53, 0.95), rgba(15, 21, 37, 0.9));
            backdrop-filter: blur(10px);
            padding: 15px 20px;
            flex-shrink: 0;
            border-bottom: 2px solid rgba(255, 215, 0, 0.2);
            position: relative;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            gap: 15px;
        }

        .hub-header img {
            height: 32px;
            flex-shrink: 0;
        }

        .hub-title {
            font-size: 20px;
            color: var(--pdc-gold);
            font-family: 'Roboto Condensed';
            font-weight: bold;
        }

        .hub-actions {
            display: flex;
            gap: 10px;
        }

        .btn-reset-hub {
            background: linear-gradient(145deg, #9a0000, #7a0000);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.1);
            padding: 8px 16px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .btn-reset-hub:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(154, 0, 0, 0.4);
        }

        .bracket-wrapper {
            display: flex;
            flex: 1;
            overflow-x: auto;
            overflow-y: auto;
            padding: 30px 20px;
            position: relative;
            -webkit-overflow-scrolling: touch;
        }

        .bracket-round-column {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 320px;
            flex-shrink: 0;
            position: relative;
        }

        .round-column-header {
            text-align: center;
            padding: 10px;
            background: linear-gradient(145deg, rgba(26, 31, 53, 0.6), rgba(15, 21, 37, 0.6));
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid rgba(255, 215, 0, 0.2);
            flex-shrink: 0;
        }

        .round-column-name {
            font-size: 16px;
            font-weight: bold;
            color: var(--pdc-gold);
            text-transform: uppercase;
            margin-bottom: 3px;
        }

        .round-column-format {
            font-size: 11px;
            color: #8fa3ad;
        }

        /* Mobile Responsive Styles */
        @media (max-width: 768px) {
            .bracket-wrapper {
                padding: 15px 10px;
            }

            .bracket-round-column {
                min-width: 280px;
            }

            .bracket-match {
                min-height: 50px;
                padding: 8px 10px;
                font-size: 13px;
            }

            .bm-flag {
                width: 16px;
                height: 12px;
            }

            .bm-name {
                font-size: 12px;
            }

            .bm-score {
                font-size: 14px;
                min-width: 18px;
            }

            .bm-avg {
                font-size: 10px;
            }

            .round-column-header {
                padding: 8px;
                margin-bottom: 12px;
            }

            .round-column-name {
                font-size: 14px;
            }

            .round-column-format {
                font-size: 10px;
            }

            .btn-play-mini {
                padding: 4px 8px;
                font-size: 10px;
                min-height: 28px;
            }

            .match-nav-btn {
                padding: 4px 8px;
                font-size: 12px;
            }

            .hub-header {
                flex-direction: column;
                gap: 10px;
                padding: 10px;
            }

            .hub-actions {
                width: 100%;
                justify-content: center;
                flex-wrap: wrap;
            }

            .hub-actions button {
                font-size: 11px;
                padding: 8px 12px;
            }

            .advancement-container {
                max-width: 95%;
                padding: 20px;
            }

            .advancement-title {
                font-size: 24px;
            }

            .advancement-player {
                min-width: 120px;
            }

            .advancement-player-name {
                font-size: 13px;
            }
        }

        @media (max-width: 480px) {
            .bracket-round-column {
                min-width: 240px;
            }

            .bracket-match {
                font-size: 12px;
            }

            .bm-name {
                font-size: 11px;
                max-width: 130px;
            }

            .round-column-name {
                font-size: 12px;
            }

            .match-select-cb {
                width: 14px;
                height: 14px;
            }
        }

        .bracket-matches-list {
            display: flex;
            flex-direction: column;
            gap: 30px;
            flex: 1;
            position: relative;
        }

        /* Tournament Bracket Lines - Single Side */
        .bracket-match-wrapper {
            position: relative;
            margin-bottom: 20px;
        }

        /* Horizontal line extending right from each match */
        .bracket-match-wrapper::before {
            content: '';
            position: absolute;
            left: 100%;
            top: 50%;
            width: 30px;
            height: 2px;
            background: rgba(255, 215, 0, 0.7);
            transform: translateY(-50%);
            z-index: 1;
        }

        /* Vertical line connecting odd match (top of pair) downward */
        .bracket-match-wrapper:nth-child(odd):not(:last-child)::after {
            content: '';
            position: absolute;
            left: calc(100% + 30px);
            top: 50%;
            width: 2px;
            height: calc(50% + 30px);
            background: rgba(255, 215, 0, 0.7);
            z-index: 1;
        }

        /* Vertical line connecting even match (bottom of pair) upward */
        .bracket-match-wrapper:nth-child(even)::after {
            content: '';
            position: absolute;
            left: calc(100% + 30px);
            bottom: 50%;
            width: 2px;
            height: calc(50% + 30px);
            background: rgba(255, 215, 0, 0.7);
            z-index: 1;
        }

        /* Last round - no lines */
        .bracket-round-column:last-child .bracket-match-wrapper::before,
        .bracket-round-column:last-child .bracket-match-wrapper::after {
            display: none;
        }

        /* Completed match highlighting */
        .bracket-match-wrapper.completed::before {
            background: var(--pdc-gold);
            box-shadow: 0 0 12px rgba(255, 215, 0, 0.5);
            height: 3px;
        }

        .bracket-match-wrapper.completed:nth-child(odd):not(:last-child)::after,
        .bracket-match-wrapper.completed:nth-child(even)::after {
            background: var(--pdc-gold);
            box-shadow: 0 0 12px rgba(255, 215, 0, 0.5);
            width: 3px;
        }

        /* Compact Bracket Match */
        .bracket-match {
            background: linear-gradient(145deg, #1a1f35, #12172a);
            border: 2px solid rgba(255, 215, 0, 0.2);
            border-left: 4px solid rgba(255, 215, 0, 0.4);
            padding: 10px 14px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            min-height: 58px;
            box-shadow: var(--shadow-sm);
            position: relative;
        }

        .bracket-match:hover {
            background: linear-gradient(145deg, #1f2540, #161b30);
            transform: scale(1.02);
            border-color: rgba(255, 215, 0, 0.3);
            border-left-color: rgba(255, 215, 0, 0.6);
            box-shadow: var(--shadow-md);
        }

        .bracket-match.completed {
            border-left-color: var(--pdc-gold);
            border-color: rgba(255, 215, 0, 0.3);
            opacity: 1;
        }

        .bracket-match.completed:hover {
            border-left-color: var(--pdc-gold);
            box-shadow: 0 4px 20px rgba(255, 215, 0, 0.4), inset 0 0 30px rgba(255, 215, 0, 0.05);
        }

        /* Player advancement animation */
        .bracket-match.just-won {
            animation: matchWinPulse 0.8s ease-out;
        }

        @keyframes matchWinPulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
                box-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
            }

            100% {
                transform: scale(1);
            }
        }

        /* ADVANCEMENT ANIMATION */
        #advancement-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 200;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(15px);
            animation: overlayFadeIn 0.3s ease-out;
        }

        @keyframes overlayFadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .advancement-container {
            background: linear-gradient(145deg, #1a1f35, #12172a);
            border-radius: 16px;
            padding: 30px;
            max-width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            border: 2px solid var(--pdc-gold);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9), 0 0 100px rgba(255, 215, 0, 0.3);
            animation: advancementSlideIn 0.5s ease-out;
        }

        @keyframes advancementSlideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .advancement-title {
            text-align: center;
            font-size: 32px;
            font-weight: 900;
            color: var(--pdc-gold);
            text-transform: uppercase;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            letter-spacing: 2px;
        }

        .advancement-subtitle {
            text-align: center;
            font-size: 16px;
            color: #8fa3ad;
            margin-bottom: 30px;
            text-transform: uppercase;
        }

        .advancement-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .advancement-player {
            background: linear-gradient(145deg, rgba(255, 215, 0, 0.08), rgba(255, 215, 0, 0.03));
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 12px;
            animation: playerSlideIn 0.4s ease-out forwards;
            opacity: 0;
            transform: translateX(-30px);
        }

        @keyframes playerSlideIn {
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .advancement-player:nth-child(1) {
            animation-delay: 0.1s;
        }

        .advancement-player:nth-child(2) {
            animation-delay: 0.15s;
        }

        .advancement-player:nth-child(3) {
            animation-delay: 0.2s;
        }

        .advancement-player:nth-child(4) {
            animation-delay: 0.25s;
        }

        .advancement-player:nth-child(5) {
            animation-delay: 0.3s;
        }

        .advancement-player:nth-child(6) {
            animation-delay: 0.35s;
        }

        .advancement-player:nth-child(7) {
            animation-delay: 0.4s;
        }

        .advancement-player:nth-child(8) {
            animation-delay: 0.45s;
        }

        .advancement-player:nth-child(n+9) {
            animation-delay: 0.5s;
        }

        .advancement-flag {
            width: 36px;
            height: 24px;
            object-fit: cover;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            flex-shrink: 0;
        }

        .advancement-player-name {
            font-size: 16px;
            font-weight: bold;
            color: white;
            flex: 1;
        }

        .advancement-player-avg {
            font-size: 12px;
            color: var(--pdc-gold);
            font-weight: bold;
        }

        .advancement-continue {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, var(--pdc-gold), #ffed4e);
            color: #111;
            font-size: 16px;
            font-weight: 900;
            text-transform: uppercase;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
        }

        .advancement-continue:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(255, 215, 0, 0.6);
        }

        .match-nav-btn {
            background: transparent;
            border: none;
            color: #555;
            font-weight: bold;
            font-size: 16px;
            padding: 0 8px;
            cursor: pointer;
            height: 100%;
            display: flex;
            align-items: center;
        }

        .match-nav-btn:hover {
            color: var(--pdc-gold);
        }

        .bm-content {
            flex: 1;
            padding: 0;
        }

        .bm-row {
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 3px;
        }

        .bm-row:last-child {
            margin-bottom: 0;
        }

        .bm-flag {
            width: 18px;
            height: 12px;
            object-fit: cover;
        }

        .bm-name {
            font-weight: bold;
            font-family: 'Roboto Condensed';
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            max-width: 130px;
            font-size: 13px;
        }

        .bm-avg {
            font-size: 10px;
            color: #777;
            font-family: 'Roboto Condensed';
        }

        .bm-score {
            font-size: 14px;
            margin-left: auto;
            font-weight: bold;
            font-family: 'Roboto Condensed';
            color: var(--pdc-gold);
        }

        .bm-action {
            margin-left: 5px;
        }

        .btn-play-mini {
            background: var(--pdc-red);
            color: white;
            border: none;
            padding: 4px 8px;
            font-size: 10px;
            font-weight: bold;
            border-radius: 2px;
        }

        .match-select-cb {
            width: 20px;
            height: 20px;
            accent-color: var(--pdc-gold);
            cursor: pointer;
            margin: 0 5px;
            flex-shrink: 0;
        }

        /* MATCH SCREEN */
        .event-bar {
            height: 36px;
            background: #111;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            border-bottom: 1px solid #444;
            flex-shrink: 0;
            position: relative;
        }

        .event-bar img {
            height: 24px;
        }

        .event-logo {
            height: 28px !important;
            opacity: 1 !important;
        }

        .event-bar span {
            font-size: 12px;
            font-weight: bold;
            color: #ccc;
        }

        .scoreboard-header {
            display: flex;
            height: 130px;
            flex-shrink: 0;
        }

        .player-card {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .name-strip {
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background: linear-gradient(to bottom, #4c6478, #2f4254);
            border-bottom: 1px solid #000;
            padding: 0 5px;
            position: relative;
        }

        .score-strip {
            flex: 1;
            background: linear-gradient(to bottom, #e4eaf0, #cfd7df);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #666;
        }

        .player-card.active .name-strip {
            background: linear-gradient(to bottom, #e00000, #9a0000);
        }

        /* Event-specific active player colors */
        .scoreboard-header.theme-world-championship .player-card.active .name-strip {
            background: linear-gradient(to bottom, #1E7F43, #0C3B2E) !important;
        }

        .scoreboard-header.theme-premier-league .player-card.active .name-strip {
            background: linear-gradient(to bottom, #FFD100, #796d02) !important;
        }

        .scoreboard-header.theme-matchplay .player-card.active .name-strip {
            background: linear-gradient(to bottom, #B22222, #8B0000) !important;
        }

        .scoreboard-header.theme-uk-open .player-card.active .name-strip {
            background: linear-gradient(to bottom, #8402db, #C8102E) !important;
        }

        .scoreboard-header.theme-grand-slam .player-card.active .name-strip {
            background: linear-gradient(to bottom, #FF8C00, #D97706) !important;
        }

        .scoreboard-header.theme-european .player-card.active .name-strip {
            background: linear-gradient(to bottom, #C0C0C0, #5B2D8B) !important;
        }

        .scoreboard-header.theme-world-grandprix .player-card.active .name-strip {
            background: linear-gradient(to bottom, #fd0202, #000000) !important;
        }

        .scoreboard-header.theme-players-championship .player-card.active .name-strip {
            background: linear-gradient(to bottom, #C8102E, #111111) !important;
        }

        .scoreboard-header.theme-world-series .player-card.active .name-strip {
            background: linear-gradient(to bottom, #000000, #7A0000) !important;
        }

        .scoreboard-header.theme-winmau .player-card.active .name-strip {
            background: linear-gradient(to bottom, #FFFFFF, #000000) !important;
        }

        .scoreboard-header.theme-masters .player-card.active .name-strip {
            background: linear-gradient(to bottom, #D4AF37, #000000) !important;
        }

        .scoreboard-header.theme-minor .player-card.active .name-strip {
            background: linear-gradient(to bottom, #2E2E2E, #1A1A1A) !important;
        }

        /* Bottom bar theme colors */
        .bottom-bar.theme-world-championship .leg-name {
            color: white !important;
        }

        .bottom-bar.theme-premier-league .leg-name {
            color: white !important;
        }

        .bottom-bar.theme-matchplay .leg-name {
            color: white !important;
        }

        .bottom-bar.theme-uk-open .leg-name {
            color: white !important;
        }

        .bottom-bar.theme-grand-slam .leg-name {
            color: white !important;
        }

        .bottom-bar.theme-european .leg-name {
            color: #000 !important;
        }

        .bottom-bar.theme-world-grandprix .leg-name {
            color: white !important;
        }

        .bottom-bar.theme-players-championship .leg-name {
            color: white !important;
        }

        .bottom-bar.theme-world-series .leg-name {
            color: white !important;
        }

        .bottom-bar.theme-winmau .leg-name {
            color: #000 !important;
        }

        .bottom-bar.theme-masters .leg-name {
            color: #000 !important;
        }

        .bottom-bar.theme-minor .leg-name {
            color: white !important;
        }

        .flag {
            height: 16px;
            width: 24px;
            object-fit: cover;
            border: 1px solid rgba(0, 0, 0, 0.3);
            flex-shrink: 0;
        }

        .p-name {
            font-size: 16px;
            font-weight: 900;
            text-transform: uppercase;
            color: white;
            text-shadow: 1px 1px 2px black;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 120px;
        }

        .p-score {
            font-size: 50px;
            font-family: 'Roboto', sans-serif;
            font-weight: 900;
            line-height: 1;
            margin-bottom: -2px;
            color: #222;
        }

        .p-avg {
            font-size: 12px;
            font-weight: bold;
            margin-top: 2px;
            color: #333;
            text-transform: uppercase;
        }

        .starter-dot {
            width: 8px;
            height: 8px;
            flex-shrink: 0;
            background-color: var(--pdc-gold);
            border-radius: 50%;
            position: absolute;
            left: 8px;
            display: none;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .visit-board {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-y: auto;
            padding: 10px 0;
            background: rgba(0, 0, 0, 0.5);
        }

        .visit-row {
            display: grid;
            grid-template-columns: 1fr 30px 80px 30px 1fr;
            width: 100%;
            max-width: 500px;
            align-items: center;
            margin-bottom: 4px;
            min-height: 36px;
            padding: 0 10px;
            box-sizing: border-box;
        }

        .v-score {
            font-family: 'Roboto Condensed';
            font-size: 26px;
            font-weight: bold;
            color: white;
        }

        .v-round {
            color: var(--text-grey);
            font-size: 12px;
            text-align: center;
        }

        .v-arrow {
            color: var(--pdc-gold);
            font-size: 16px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.1s;
        }

        /* Theme-specific v-arrow colors for player round indicator */
        .visit-board.theme-world-championship .v-arrow {
            color: #1E7F43;
        }

        .visit-board.theme-premier-league .v-arrow {
            color: #FFD100;
        }

        .visit-board.theme-matchplay .v-arrow {
            color: #B22222;
        }

        .visit-board.theme-uk-open .v-arrow {
            color: #8402db;
        }

        .visit-board.theme-grand-slam .v-arrow {
            color: #FF8C00;
        }

        .visit-board.theme-european .v-arrow {
            color: #5B2D8B;
        }

        .visit-board.theme-world-grandprix .v-arrow {
            color: #fd0202;
        }

        .visit-board.theme-players-championship .v-arrow {
            color: #C8102E;
        }

        .visit-board.theme-world-series .v-arrow {
            color: #7A0000;
        }

        .visit-board.theme-winmau .v-arrow {
            color: #888888;
        }

        .visit-board.theme-masters .v-arrow {
            color: #D4AF37;
        }

        .visit-board.theme-minor .v-arrow {
            color: #666666;
        }

        /* Theme-specific visit-board background colors */
        .visit-board.theme-world-championship {
            background: linear-gradient(180deg, rgba(30, 127, 67, 0.3) 0%, rgba(12, 59, 46, 0.5) 100%);
        }

        .visit-board.theme-premier-league {
            background: linear-gradient(180deg, rgba(255, 209, 0, 0.15) 0%, rgba(121, 109, 2, 0.3) 100%);
        }

        .visit-board.theme-matchplay {
            background: linear-gradient(180deg, rgba(178, 34, 34, 0.3) 0%, rgba(139, 0, 0, 0.5) 100%);
        }

        .visit-board.theme-uk-open {
            background: linear-gradient(180deg, rgba(132, 2, 219, 0.3) 0%, rgba(200, 16, 46, 0.3) 100%);
        }

        .visit-board.theme-grand-slam {
            background: linear-gradient(180deg, rgba(255, 140, 0, 0.3) 0%, rgba(217, 119, 6, 0.4) 100%);
        }

        .visit-board.theme-european {
            background: linear-gradient(180deg, rgba(192, 192, 192, 0.2) 0%, rgba(91, 45, 139, 0.4) 100%);
        }

        .visit-board.theme-world-grandprix {
            background: linear-gradient(180deg, rgba(253, 2, 2, 0.3) 0%, rgba(0, 0, 0, 0.5) 100%);
        }

        .visit-board.theme-players-championship {
            background: linear-gradient(180deg, rgba(200, 16, 46, 0.3) 0%, rgba(17, 17, 17, 0.5) 100%);
        }

        .visit-board.theme-world-series {
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.5) 0%, rgba(122, 0, 0, 0.4) 100%);
        }

        .visit-board.theme-winmau {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.2) 0%, rgba(0, 0, 0, 0.4) 100%);
        }

        .visit-board.theme-masters {
            background: linear-gradient(180deg, rgba(212, 175, 55, 0.2) 0%, rgba(0, 0, 0, 0.5) 100%);
        }

        .visit-board.theme-minor {
            background: linear-gradient(180deg, rgba(46, 46, 46, 0.5) 0%, rgba(26, 26, 26, 0.6) 100%);
        }

        .bottom-bar {
            height: 60px;
            background: linear-gradient(135deg, #2E2E2E, #1A1A1A);
            display: flex;
            align-items: center;
            justify-content: center;
            border-top: 2px solid rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
            padding-bottom: env(safe-area-inset-bottom);
        }

        /* Theme-specific bottom bar styles */
        .bottom-bar.theme-world-championship {
            background: linear-gradient(135deg, #1E7F43, #0C3B2E);
        }

        .bottom-bar.theme-premier-league {
            background: linear-gradient(135deg, #FFD100, #796d02);
        }

        .bottom-bar.theme-matchplay {
            background: linear-gradient(135deg, #B22222, #8B0000);
        }

        .bottom-bar.theme-uk-open {
            background: linear-gradient(135deg, #8402db, #C8102E);
        }

        .bottom-bar.theme-grand-slam {
            background: linear-gradient(135deg, #FF8C00, #D97706);
        }

        .bottom-bar.theme-european {
            background: linear-gradient(135deg, #C0C0C0, #5B2D8B);
        }

        .bottom-bar.theme-world-grandprix {
            background: linear-gradient(135deg, #fd0202, #000000);
        }

        .bottom-bar.theme-players-championship {
            background: linear-gradient(135deg, #C8102E, #111111);
        }

        .bottom-bar.theme-world-series {
            background: linear-gradient(135deg, #000000, #7A0000);
        }

        .bottom-bar.theme-winmau {
            background: linear-gradient(135deg, #FFFFFF, #000000);
        }

        .bottom-bar.theme-masters {
            background: linear-gradient(135deg, #D4AF37, #000000);
        }

        .bottom-bar.theme-minor {
            background: linear-gradient(135deg, #2E2E2E, #1A1A1A);
        }

        /* Gold background - white text */
        .bottom-bar.theme-premier-league .leg-name,
        .bottom-bar.theme-masters .leg-name {
            color: white !important;
        }

        .legs-display {
            display: flex;
            width: 100%;
            justify-content: center;
            align-items: center;
            height: 100%;
        }

        .score-box-left {
            flex: 1;
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 15px;
            padding-right: 15px;
        }

        .score-box-right {
            flex: 1;
            display: flex;
            justify-content: flex-start;
            align-items: center;
            gap: 15px;
            padding-left: 15px;
        }

        .leg-name {
            font-weight: bold;
            font-size: 14px;
            color: white;
            text-transform: uppercase;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 80px;
        }

        .main-score {
            font-size: 32px;
            color: white;
            font-weight: bold;
            font-family: 'Roboto Condensed';
            min-width: 25px;
            text-align: center;
        }

        .sub-score {
            font-size: 20px;
            color: white;
            font-weight: bold;
            font-family: 'Roboto Condensed';
            opacity: 0.7;
            min-width: 20px;
            text-align: center;
        }

        .leg-label {
            color: white;
            text-align: center;
            font-weight: bold;
            font-size: 10px;
            width: 40px;
        }

        /* POST MATCH STATS */
        #post-match-screen {
            display: none;
            background: linear-gradient(135deg, #0f1729 0%, #1a2642 50%, #0f1729 100%);
            z-index: 110;
            align-items: center;
            overflow-y: auto;
        }

        .stats-header {
            width: 100%;
            background: linear-gradient(180deg, rgba(26, 31, 53, 0.95), rgba(15, 21, 37, 0.9));
            backdrop-filter: blur(10px);
            padding: 20px;
            text-align: center;
            border-bottom: 2px solid var(--pdc-gold);
            box-sizing: border-box;
            flex-shrink: 0;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        }

        .stats-title {
            font-size: 22px;
            color: var(--pdc-gold);
            font-weight: bold;
            text-transform: uppercase;
            margin-bottom: 2px;
        }

        .stats-subtitle {
            font-size: 12px;
            color: #ccc;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 130px 1fr;
            width: 100%;
            max-width: 500px;
            padding: 15px 10px;
            gap: 8px;
            flex-shrink: 0;
        }

        .stat-label {
            color: #888;
            font-size: 11px;
            text-align: center;
            text-transform: uppercase;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .stat-val {
            font-size: 20px;
            font-weight: bold;
            text-align: center;
            font-family: 'Roboto Condensed';
        }

        .stat-val.winner {
            color: var(--pdc-gold);
        }

        .stat-row {
            display: contents;
        }

        .p-head {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            margin-bottom: 15px;
        }

        .p-head img {
            width: 36px;
            height: 24px;
            border: 1px solid #555;
        }

        .p-head span {
            font-weight: bold;
            font-size: 16px;
            text-transform: uppercase;
            text-align: center;
        }

        /* OVERLAYS */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 50;
            flex-direction: column;
        }

        .intro-box {
            background: #b00000;
            color: white;
            text-align: center;
            padding: 20px;
            border: 2px solid white;
            width: 80%;
            max-width: 300px;
        }

        .end-box {
            background: #222;
            padding: 30px 20px;
            text-align: center;
            border: 1px solid #444;
            width: 90%;
            max-width: 400px;
            box-sizing: border-box;
        }

        .end-winner {
            font-size: 32px;
            color: var(--pdc-gold);
            font-weight: bold;
            margin: 15px 0;
        }

        .end-score {
            font-size: 40px;
            background: #444;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .game-shot-box,
        .high-checkout-box {
            background: #009900;
            color: white;
            font-size: clamp(20px, 10vw, 60px);
            font-weight: 900;
            padding: 20px;
            width: 80%;
            border: 2px solid white;
            animation: popIn 0.3s forwards;
            text-transform: uppercase;
            text-align: center;
        }

        .high-checkout-box {
            background: #1b4dff;
        }

        .one-eighty-box {
            background: var(--pdc-red);
            color: white;
            font-size: 25vw;
            font-weight: 900;
            padding: 10px 40px;
            border: 4px solid white;
            animation: popIn 0.3s forwards;
            text-transform: uppercase;
            transform: rotate(-5deg);
            box-shadow: 5px 5px 0px rgba(0, 0, 0, 0.5);
            font-family: 'Roboto Condensed';
        }

        @keyframes popIn {
            from {
                transform: scale(0.5);
            }

            to {
                transform: scale(1);
            }
        }

        /* INTRO ANIM */
        #clean-intro {
            position: fixed;
            inset: 0;
            z-index: 999999;
            display: none;
            background: linear-gradient(135deg, #081a2f 0%, #000814 70%);
            overflow: hidden;
            align-items: center;
            justify-content: center;
            font-family: 'Roboto Condensed', sans-serif;
        }

        .intro-bg-lines {
            position: absolute;
            inset: 0;
            background: repeating-linear-gradient(90deg, rgba(255, 255, 255, .03) 0px, rgba(255, 255, 255, .03) 1px, transparent 1px, transparent 6px);
            animation: bgMove 3s linear infinite;
            pointer-events: none;
        }

        @keyframes bgMove {
            from {
                background-position: 0 0;
            }

            to {
                background-position: 200px 0;
            }
        }

        .intro-card {
            position: relative;
            z-index: 2;
            background: linear-gradient(180deg, #0c1f3a, #000814);
            border-radius: 6px;
            padding: 40px 20px;
            width: 90%;
            max-width: 500px;
            text-align: center;
            box-shadow: 0 0 50px rgba(0, 0, 0, .9);
            animation: cardIn 1.2s ease forwards, glowPulse 2.5s ease-in-out infinite alternate;
        }

        .intro-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 6px;
            background: linear-gradient(90deg, #e10600, #ffffff, #001c54);
            border-radius: 6px 6px 0 0;
        }

        @keyframes cardIn {
            from {
                transform: translateY(40px) scale(.8);
                opacity: 0;
            }

            to {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        @keyframes glowPulse {
            from {
                box-shadow: 0 0 30px rgba(255, 204, 0, .2);
            }

            to {
                box-shadow: 0 0 70px rgba(255, 204, 0, .6);
            }
        }

        .intro-event {
            font-size: 18px;
            letter-spacing: 4px;
            color: #e10600;
            margin-bottom: 20px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .intro-vs-box {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }

        .intro-name {
            font-size: 32px;
            font-weight: 900;
            letter-spacing: 1px;
            color: white;
            text-transform: uppercase;
            animation: textSlide 1s ease forwards;
            line-height: 1.1;
        }

        .intro-nation {
            margin-top: 5px;
            font-size: 14px;
            letter-spacing: 2px;
            color: #4da3ff;
            text-transform: uppercase;
            font-weight: bold;
        }

        .intro-vs-text {
            font-size: 24px;
            color: white;
            font-weight: bold;
            opacity: 0.5;
        }

        .intro-sub {
            letter-spacing: 6px;
            opacity: .7;
            color: white;
            font-size: 12px;
            margin-top: 20px;
            font-weight: bold;
        }

        @keyframes textSlide {
            from {
                transform: translateY(20px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .intro-side {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 15%;
            max-width: 160px;
            background: linear-gradient(180deg, #001c54, #000814);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 1;
            animation: sideSlide 1s ease forwards;
        }

        .intro-left {
            left: 0;
            border-right: 1px solid #333;
        }

        .intro-right {
            right: 0;
            border-left: 1px solid #333;
        }

        @keyframes sideSlide {
            from {
                width: 0;
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .intro-flag-img {
            width: 60%;
            height: auto;
            margin-bottom: 10px;
            border-radius: 2px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
            animation: flagPop .8s ease forwards;
        }

        .intro-side-text {
            font-size: 18px;
            letter-spacing: 2px;
            font-weight: bold;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            transform: rotate(180deg);
        }

        @keyframes flagPop {
            0% {
                transform: scale(.2);
                opacity: 0;
            }

            70% {
                transform: scale(1.2);
                opacity: 1;
            }

            100% {
                transform: scale(1);
            }
        }

        .dart-anim {
            position: absolute;
            top: 40%;
            left: -200px;
            width: 180px;
            height: auto;
            opacity: 0.25;
            transform: rotate(-15deg);
            animation: dartThrow 3s ease-out forwards;
            pointer-events: none;
            z-index: 0;
        }

        @keyframes dartThrow {
            0% {
                transform: translateX(0) rotate(-20deg);
                opacity: 0;
            }

            20% {
                opacity: .35;
            }

            100% {
                transform: translateX(150vw) rotate(5deg);
                opacity: 0;
            }
        }

        /* RESPONSIVE */
        @media (min-width: 768px) {
            .setup-box {
                max-width: 750px;
            }

            .pc-row {
                flex-direction: row;
                gap: 20px;
            }

            .pc-row>div {
                flex: 1;
            }

            .p-name {
                font-size: 22px;
                max-width: none;
            }

            .p-score {
                font-size: 65px;
            }

            .flag {
                width: 30px;
                height: 20px;
            }

            .bracket-container {
                max-width: 800px;
            }

            .leg-name {
                display: block;
            }

            .intro-name {
                font-size: 44px;
            }
        }

        @media (max-width: 600px) {
            .tourn-config-grid {
                grid-template-columns: 1fr;
                max-height: 150px;
            }

            .leg-name {
                display: none;
            }

            .bm-name {
                max-width: 100px;
            }

            .intro-name {
                font-size: 26px;
            }

            .intro-side {
                width: 40px;
            }

            .intro-side-text {
                font-size: 12px;
            }
        }

        .btn-icon {
            background: transparent;
            border: none;
            color: white;
            font-size: 18px;
            cursor: pointer;
            padding: 5px 10px;
            font-weight: bold;
        }

        .btn-icon:hover {
            color: var(--pdc-gold);
        }

        .btn-exit-small {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #9a0000;
            color: white;
            border: none;
            font-size: 10px;
            padding: 4px 8px;
            cursor: pointer;
            border-radius: 4px;
        }

        /* PWA Install Button */
        #pwa-install-btn {
            position: fixed;
            bottom: 70px;
            right: 12px;
            z-index: 10000;
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #111;
            border: none;
            padding: 10px 16px;
            border-radius: 12px;
            font-family: 'Bebas Neue', sans-serif;
            font-weight: bold;
            font-size: 16px;
            letter-spacing: 0.5px;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(255, 215, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.4);
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        #pwa-install-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 30px rgba(255, 215, 0, 0.7);
        }

        #pwa-install-btn svg {
            width: 16px;
            height: 16px;
        }

        #pwa-install-btn.hidden {
            display: none;
        }

        /* EMERGENCY RESET */
        #btn-emergency-reset {
            position: fixed;
            bottom: 10px;
            left: 10px;
            z-index: 9999999;
            background: #9a0000;
            color: white;
            padding: 8px 12px;
            border: 2px solid white;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            animation: fadeOutReset 5s forwards;
        }

        @keyframes fadeOutReset {
            0% {
                opacity: 1;
            }

            80% {
                opacity: 1;
            }

            100% {
                opacity: 0;
                pointer-events: none;
            }
        }

        /* --- OPTIMIZED PLAYER SELECTOR (Smaller) --- */
        .player-option {
            display: flex;
            align-items: center;
            padding: 4px 8px;
            /* Reduced padding */
            border-bottom: 1px solid #2a2a2a;
            cursor: pointer;
            min-height: 28px;
            /* Force smaller height */
        }

        .player-option img {
            width: 16px;
            /* Smaller flag */
            height: 11px;
            margin-right: 8px;
        }

        .player-option span {
            font-size: 11px;
            /* Smaller font */
            font-weight: bold;
        }

        .player-option input {
            width: 14px;
            height: 14px;
            margin-right: 8px;
        }

        /* --- STANDINGS HUB NAVIGATION --- */
        .standings-nav {
            display: flex;
            gap: 5px;
            padding: 5px;
            background: #111;
            border-bottom: 1px solid #333;
            overflow-x: auto;
        }

        .standings-nav button {
            flex: 1;
            padding: 8px 4px;
            background: #1a1f35;
            border: 1px solid #333;
            color: #888;
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            border-radius: 4px;
            white-space: nowrap;
        }

        .standings-nav button.active {
            background: var(--pdc-gold);
            color: black;
            border-color: var(--pdc-gold);
        }

        .standing-section {
            display: none;
            flex-direction: column;
            flex: 1;
            min-height: 0;
            overflow-y: auto;
            padding: 0 5px 10px 5px;
        }

        .standing-section.active {
            display: flex;
        }

        .standing-section>div:first-of-type {
            flex-shrink: 0;
        }

        .oom-view {
            flex: 1;
            min-height: 0;
            overflow-y: auto;
            padding-top: 15px;
        }

        #premier-league-standings,
        #qschool-standings-uk,
        #qschool-standings-eu {
            flex: 1;
            min-height: 0;
            overflow-y: auto;
        }
    </style>
</head>

<body>

    <!-- EMERGENCY RESET -->
    <button id="btn-emergency-reset" onclick="localStorage.clear(); location.reload();">‚ö†Ô∏è RESET APP</button>

    <!-- SETUP SCREEN -->
    <div id="setup-screen" style="display:none;">
        <div class="setup-box">

            <!-- NEWS TAB (HIDDEN) -->
            <div id="tab-news" class="tab-content" style="padding:0; display:none;">
                <style>
                    .news-card {
                        background: linear-gradient(145deg, #1f2430, #141822);
                        padding: 12px;
                        border-radius: 6px;
                        border-left: 3px solid #666;
                        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
                        position: relative;
                        transition: transform 0.2s;
                    }

                    .news-card:hover {
                        transform: translateX(2px);
                        background: linear-gradient(145deg, #252b3a, #1a1e2a);
                    }

                    .news-card.high {
                        border-left-color: var(--pdc-gold);
                        box-shadow: 0 0 10px rgba(255, 215, 0, 0.1);
                    }

                    .news-card.medium {
                        border-left-color: #3498db;
                    }

                    .news-card.win {
                        border-left-color: #FFD700;
                    }

                    .news-card.rivalry {
                        border-left-color: #e74c3c;
                        background: linear-gradient(145deg, #2a1f1f, #1a1414);
                    }

                    .news-card.upset {
                        border-left-color: #9b59b6;
                    }

                    .news-card.rank {
                        border-left-color: #f39c12;
                    }

                    .news-card.withdrawal {
                        border-left-color: #7f8c8d;
                    }

                    .news-card.replacement {
                        border-left-color: #16a085;
                    }

                    .news-header {
                        display: flex;
                        justify-content: space-between;
                        margin-bottom: 4px;
                        font-size: 10px;
                        color: #888;
                        text-transform: uppercase;
                        font-weight: bold;
                    }

                    .news-title {
                        font-size: 13px;
                        color: #ececec;
                        line-height: 1.4;
                        font-weight: 500;
                    }

                    .news-type-icon {
                        margin-right: 5px;
                        opacity: 0.7;
                    }

                    .news-filters {
                        display: flex;
                        gap: 5px;
                        flex-wrap: wrap;
                        padding: 10px;
                        background: rgba(0, 0, 0, 0.2);
                        border-bottom: 1px solid #333;
                    }

                    .filter-btn {
                        background: transparent;
                        border: 1px solid #444;
                        color: #aaa;
                        padding: 4px 10px;
                        border-radius: 12px;
                        font-size: 11px;
                        cursor: pointer;
                        transition: all 0.2s;
                    }

                    .filter-btn:hover {
                        border-color: #777;
                        color: #fff;
                    }

                    .filter-btn.active {
                        background: var(--pdc-gold);
                        color: #000;
                        border-color: var(--pdc-gold);
                        font-weight: bold;
                    }
                </style>
                <div class="news-filters">
                    <button class="filter-btn active" onclick="NewsSystem.setFilter('all')">ALL</button>
                    <button class="filter-btn" onclick="NewsSystem.setFilter('major')">MAJORS</button>
                    <button class="filter-btn" onclick="NewsSystem.setFilter('tour')">PRO TOUR</button>
                    <button class="filter-btn" onclick="NewsSystem.setFilter('withdrawal')">WITHDRAWALS</button>
                    <button class="filter-btn" onclick="NewsSystem.setFilter('upset')">UPSETS</button>
                </div>
                <div id="news-feed"
                    style="padding: 10px; display:flex; flex-direction:column; gap:8px; overflow-y:auto; flex:1;">
                    <!-- News Item Template -->
                    <div style="text-align:center; padding: 20px; color:#666; font-size:12px;">No news yet...</div>
                </div>
            </div>

            <!-- SINGLE MATCH TAB -->


            <!-- CAREER TAB -->
            <div id="tab-season" class="tab-content active">
                <div id="career-main-menu" class="career-menu-overlay">
                    <div class="career-menu-card">
                        <div class="career-menu-title">CAREER MODE</div>
                        <div class="career-menu-actions">
                            <button class="btn-menu" onclick="Season.showCareerStart()">START NEW CAREER</button>
                            <button class="btn-menu" onclick="AuthSystem.showModal()">LOAD CAREER</button>
                            <button class="btn-menu btn-back-hub" onclick="window.location.href='darts.html'">BACK TO
                                MAIN HUB</button>
                        </div>
                    </div>
                </div>

                <div id="career-start" class="career-start" style="display:none;">
                    <div class="career-start-card">
                        <div class="career-start-title">Customize Your Player</div>
                        <div class="career-start-tabs">
                            <button class="career-start-tab active" id="career-start-tab-custom"
                                onclick="Season.switchCareerStartTab('custom')">Create Player</button>
                            <button class="career-start-tab" id="career-start-tab-existing"
                                onclick="Season.switchCareerStartTab('existing')">Existing Player</button>
                        </div>

                        <div id="career-start-custom" class="career-start-pane">
                            <div>
                                <label>Player Name</label>
                                <input type="text" id="career-start-name" placeholder="Enter your name">
                            </div>
                            <div>
                                <label>Nationality</label>
                                <select id="career-start-country"></select>
                            </div>
                            <div>
                                <label>Home City</label>
                                <input type="text" id="career-start-city" placeholder="e.g., London, New York, Sydney"
                                    value="London">
                            </div>
                            <div>
                                <label>Home Country</label>
                                <input type="text" id="career-start-home-country" placeholder="Your home country"
                                    value="England">
                            </div>
                            <div>
                                <label>Home Region (affects travel costs)</label>
                                <select id="career-start-region">
                                    <option value="uk">UK & Ireland</option>
                                    <option value="eu">Europe</option>
                                    <option value="asia">Asia</option>
                                    <option value="america">Americas</option>
                                    <option value="oceania">Oceania</option>
                                    <option value="africa">Africa</option>
                                </select>
                            </div>
                            <div>
                                <label>Starting Age</label>
                                <input type="number" id="career-start-age" min="16" max="60" value="25">
                            </div>
                            <div>
                                <label>Match Average</label>
                                <div class="career-start-slider">
                                    <input type="range" id="career-start-avg" min="20" max="100" step="0.1" value="60"
                                        oninput="Season.updateCareerStartRanges()">
                                    <div class="career-start-pill" id="career-start-avg-val">60.0</div>
                                </div>
                            </div>
                            <div>
                                <label>Checkout %</label>
                                <div class="career-start-slider">
                                    <input type="range" id="career-start-co" min="10" max="60" step="0.1" value="35"
                                        oninput="Season.updateCareerStartRanges()">
                                    <div class="career-start-pill" id="career-start-co-val">35.0%</div>
                                </div>
                            </div>
                            <div class="checkbox-row"
                                onclick="const cb=this.querySelector('input'); cb.checked=!cb.checked;">
                                <input type="checkbox" id="career-start-tourcard">
                                <label for="career-start-tourcard">Tour Card Holder<br><span
                                        style="font-size:10px; opacity:0.7;">Start with automatic qualification for
                                        major events</span></label>
                            </div>
                            <div class="career-start-actions">
                                <button class="btn-blue"
                                    style="background: linear-gradient(135deg, #2d3f5f 0%, #1e2a3f 100%); font-size: 11px;"
                                    onclick="Season.switchCareerStartTab('existing')">PLAY AS EXISTING PLAYER</button>
                                <button class="btn-blue"
                                    style="background: linear-gradient(135deg, #4b5563 0%, #1f2937 100%); font-size: 11px;"
                                    onclick="document.getElementById('career-start').style.display='none'; Season.renderCareerHub();">BACK</button>
                                <button class="btn-gold" onclick="Season.createCareerPlayerFromHub()">Start
                                    Career</button>
                            </div>
                        </div>

                        <div id="career-start-existing" class="career-start-pane" style="display:none;">
                            <label>Search Player</label>
                            <input type="text" id="career-start-search" placeholder="Type a name..."
                                onkeyup="Season.filterCareerPlayerListTo('career-start-list','career-start-search')">
                            <div id="career-start-list"
                                style="max-height:260px; overflow-y:auto; border:1px solid rgba(255,255,255,0.1); border-radius:6px; background:#111;">
                            </div>
                        </div>
                    </div>
                </div>

                <div class="career-shell">
                    <main class="career-main">
                        <div class="career-topbar">
                            <div class="career-topbar-row">
                                <div class="career-brand-mini">CAREER MODE <span id="season-year-disp">2026</span></div>
                                <div class="career-date" id="career-date-display">January 1, 2026</div>
                                <div class="career-topbar-right">
                                    <button class="career-pill" onclick="Season.openCareerPlayerModal()"
                                        style="cursor:pointer; background:rgba(255,215,0,0.1); border-color:rgba(255,215,0,0.3); color:var(--pdc-gold);">
                                        üë§ PROFILE
                                    </button>
                                    <button class="career-pill" onclick="AuthSystem.showModal()"
                                        style="cursor:pointer; background:rgba(0,102,204,0.1); border-color:rgba(0,102,204,0.3); color:#88ccff;">
                                        ‚òÅÔ∏è <span id="auth-pill-status">ACCOUNT</span>
                                    </button>
                                    <button class="career-pill" onclick="Season.reset()"
                                        style="background:rgba(154,0,0,0.1); border-color:rgba(154,0,0,0.3); color:#ff6666; cursor:pointer;">
                                        RESET
                                    </button>
                                </div>
                            </div>

                            <div class="career-topbar-row"
                                style="border-top: 1px solid rgba(255,255,255,0.05); padding-top: 12px;">
                                <nav class="career-horizontal-nav">
                                    <button class="career-nav-btn active" id="career-nav-dashboard"
                                        onclick="Season.switchCareerView('dashboard')">Dashboard</button>
                                    <button class="career-nav-btn" id="career-nav-calendar"
                                        onclick="Season.switchCareerView('calendar')">Calendar</button>
                                    <button class="career-nav-btn" id="career-nav-rankings"
                                        onclick="Season.switchCareerView('rankings')">Rankings</button>
                                    <button class="career-nav-btn" id="career-nav-training"
                                        onclick="Season.switchCareerView('training')">Training</button>
                                    <button class="career-nav-btn" id="career-nav-news"
                                        onclick="Season.switchCareerView('news')">News</button>
                                    <button class="career-nav-btn" id="career-nav-form"
                                        onclick="Season.switchCareerView('form')">Form</button>
                                </nav>

                                <div class="career-topbar-stats">
                                    <div class="career-pill">RANK <span id="career-stat-rank">--</span></div>
                                    <div class="career-pill">WORLD <span id="career-pill-world">--</span></div>
                                    <div class="career-pill">BANK <span id="career-pill-balance">--</span></div>
                                    <div class="career-pill">AVG <span id="career-stat-avg">--</span></div>
                                    <div class="career-pill">CO% <span id="career-stat-co">--</span></div>
                                    <div class="career-pill">FAT <span id="career-stat-fatigue">--</span></div>
                                </div>
                            </div>
                        </div>

                        <div class="career-main-grid">
                            <section class="career-card" id="career-section-recent">
                                <div class="career-card-title">Recent Activity</div>
                                <div id="career-activity-text" class="career-muted">No recent activity</div>
                            </section>

                            <section class="career-card">
                                <div class="career-card-title">Latest News</div>
                                <div id="career-latest-news" class="career-muted">No news available</div>
                            </section>

                            <section class="career-card">
                                <div class="career-card-title">Player Development</div>
                                <div class="career-bar-row">
                                    <span>Match Average</span>
                                    <div class="career-bar">
                                        <div id="career-bar-avg" class="career-bar-fill"></div>
                                    </div>
                                    <span id="career-stat-avg-2">--</span>
                                </div>
                                <div class="career-bar-row">
                                    <span>Checkout %</span>
                                    <div class="career-bar">
                                        <div id="career-bar-co" class="career-bar-fill"></div>
                                    </div>
                                    <span id="career-stat-co-2">--</span>
                                </div>
                                <div class="career-bar-row">
                                    <span>Form</span>
                                    <div class="career-bar">
                                        <div id="career-bar-form" class="career-bar-fill"></div>
                                    </div>
                                    <span id="career-stat-form" class="career-stat-text">--</span>
                                </div>
                                <div class="career-bar-row">
                                    <span>Fatigue</span>
                                    <div class="career-bar">
                                        <div id="career-bar-fatigue" class="career-bar-fill"></div>
                                    </div>
                                    <span id="career-stat-fatigue-2">--</span>
                                </div>
                                <div class="career-bar-row">
                                    <span>Consistency</span>
                                    <div class="career-bar">
                                        <div id="career-bar-consistency" class="career-bar-fill"></div>
                                    </div>
                                    <span id="career-stat-consistency">--</span>
                                </div>
                            </section>

                            <section class="career-card">
                                <div class="career-card-title">Today</div>
                                <div id="career-day-summary" class="career-muted">No schedule yet</div>
                                <div id="career-day-events" class="career-day-events"></div>
                            </section>

                            <aside class="career-card" id="career-section-training">
                                <div class="career-card-title">Quick Actions</div>
                                <div class="career-actions">
                                    <button class="btn-hub-action" style="background:#2563eb;"
                                        onclick="Season.toggleTrainingPanel()">Training</button>
                                    <button class="btn-hub-action" style="background:#16a34a;"
                                        onclick="Season.performCareerRest(true)">Light Training</button>
                                    <button class="btn-hub-action" style="background:#444;"
                                        onclick="Season.performCareerRest(false)">Full Rest</button>
                                    <button class="btn-hub-action btn-sim" onclick="Season.simulateCareerDay()">Sim
                                        Day</button>
                                    <button class="btn-hub-action" style="background:#c49a1a;"
                                        onclick="Season.advanceCareerDayManual()">Next Day</button>
                                </div>
                                <div id="career-training-panel" class="career-training-panel" style="display:none;">
                                    <div class="career-label">Training Options</div>
                                    <div class="career-training-grid">
                                        <button class="career-training-btn"
                                            onclick="Season.trainCareerDay('scoring')">Scoring Session</button>
                                        <button class="career-training-btn"
                                            onclick="Season.trainCareerDay('checkout')">Checkout Drills</button>
                                        <button class="career-training-btn"
                                            onclick="Season.trainCareerDay('consistency')">Consistency Lab</button>
                                        <button class="career-training-btn"
                                            onclick="Season.trainCareerDay('stamina')">Stamina Session</button>
                                    </div>
                                </div>
                            </aside>

                            <section class="career-card career-calendar-card" id="career-section-calendar">
                                <button class="career-card-title career-link"
                                    onclick="Season.openCareerCalendarOverlay()">Season Calendar</button>
                                <div class="career-calendar-list" id="season-event-list"></div>
                            </section>

                            <section class="career-card" id="career-section-rankings">
                                <button class="career-card-title career-link"
                                    onclick="Season.openCareerRankingsOverlay()">Order of Merit</button>
                                <div id="career-oom-container"></div>
                            </section>
                        </div>
                    </main>
                </div>
            </div>

            <!-- MERGED STANDINGS TAB (HIDDEN) -->
            <div id="tab-standings" class="tab-content" style="display:none;">
                <div class="standings-nav">
                    <button class="std-btn active" onclick="switchStandingSection('oom')" id="std-btn-oom">Order of
                        Merit</button>
                    <button class="std-btn" onclick="switchStandingSection('premier')" id="std-btn-premier">Premier
                        League</button>
                    <button class="std-btn" onclick="switchStandingSection('qschool')"
                        id="std-btn-qschool">Q-School</button>
                </div>

                <!-- OOM SECTION -->
                <div id="section-oom" class="standing-section active">
                    <div style="display:flex; gap:5px; margin:10px 0;">
                        <button class="tab-btn active" onclick="switchOOMView('main')" id="oom-btn-main"
                            style="flex:1; padding:6px; font-size:10px;">MAIN</button>
                        <button class="tab-btn" onclick="switchOOMView('pro')" id="oom-btn-pro"
                            style="flex:1; padding:6px; font-size:10px;">PRO TOUR</button>
                        <button class="tab-btn" onclick="switchOOMView('challenge')" id="oom-btn-challenge"
                            style="flex:1; padding:6px; font-size:10px;">CHALLENGE</button>
                        <button class="tab-btn" onclick="switchOOMView('ws')" id="oom-btn-ws"
                            style="flex:1; padding:6px; font-size:10px;">W. SERIES</button>
                        <button class="tab-btn" onclick="switchOOMView('form')" id="oom-btn-form"
                            style="flex:1; padding:6px; font-size:10px;">FORM/FATIGUE</button>
                    </div>
                    <div class="oom-view active" id="oom-view-main">
                        <table class="oom-table" id="oom-hub-main"></table>
                    </div>
                    <div class="oom-view" id="oom-view-pro">
                        <table class="oom-table" id="oom-hub-pro"></table>
                    </div>
                    <div class="oom-view" id="oom-view-challenge">
                        <table class="oom-table" id="oom-hub-challenge"></table>
                    </div>
                    <div class="oom-view" id="oom-view-ws">
                        <table class="oom-table" id="oom-hub-ws"></table>
                    </div>
                    <div class="oom-view" id="oom-view-form">
                        <table class="oom-table" id="oom-hub-form"></table>
                    </div>
                </div>

                <!-- PREMIER LEAGUE SECTION -->
                <div id="section-premier" class="standing-section">
                    <div
                        style="text-align:center; margin:10px 0; font-size:16px; font-weight:bold; color:var(--pdc-gold);">
                        PREMIER LEAGUE</div>
                    <div id="premier-league-standings"></div>
                </div>

                <!-- Q-SCHOOL SECTION -->
                <div id="section-qschool" class="standing-section">
                    <div
                        style="text-align:center; margin:10px 0; font-size:16px; font-weight:bold; color:var(--pdc-gold);">
                        Q-SCHOOL</div>
                    <div style="display:flex; gap:10px; margin-bottom:10px;">
                        <button class="tab-btn active" onclick="switchQSchoolView('uk')" id="qschool-btn-uk"
                            style="flex:1; padding:8px;">UK</button>
                        <button class="tab-btn" onclick="switchQSchoolView('eu')" id="qschool-btn-eu"
                            style="flex:1; padding:8px;">EU</button>
                    </div>
                    <div id="qschool-standings-uk" class="qschool-view active"></div>
                    <div id="qschool-standings-eu" class="qschool-view"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- TOURNAMENT HUB -->
    <div id="tournament-hub">
        <div class="hub-header">
            <div class="hub-title" id="tourn-hub-title">TOURNAMENT</div>
            <div class="hub-actions">
                <button class="btn-hub-action btn-sim" onclick="Tournament.simulateCurrentRound()">Simulate Current
                    Round</button>
                <button class="btn-hub-action btn-watch" onclick="Tournament.startAutoPlay()">Watch Round</button>
                <button class="btn-hub-action" style="background:#3498db;" onclick="Tournament.leaveEvent()">‚Üê Leave
                    Event</button>
                <button class="btn-reset-hub" onclick="Persistence.clear()">RESET</button>
            </div>
        </div>

        <div id="career-match-banner" class="season-event" style="margin:10px 20px; display:none; cursor:default;">
            <div style="cursor:pointer;" onclick="Season.findPlayerInBracket()"
                title="Click to find your match in the bracket">
                <div class="s-date">YOUR MATCH</div>
                <div class="s-name" id="career-match-title">Player vs Opponent</div>
                <div class="s-winner" id="career-match-status"></div>
            </div>
            <div id="career-match-action"></div>
        </div>

        <div class="bracket-wrapper" id="tourn-bracket"></div>
    </div>

    <!-- CLEAN INTRO -->
    <div id="clean-intro">
        <img src="darts.png" class="dart-anim" onerror="this.style.display='none'">
        <div class="intro-bg-lines"></div>

        <div class="intro-side intro-left">
            <img class="intro-flag-img" id="ci-flag-1" src="" alt="">
            <div class="intro-side-text" id="ci-nation-1">ENG</div>
        </div>

        <div class="intro-card">
            <div class="intro-event" id="ci-event">EVENT NAME</div>
            <div class="intro-vs-box">
                <div>
                    <div class="intro-name" id="ci-p1">PLAYER 1</div>
                    <div class="intro-nation" id="ci-n1">ENGLAND</div>
                </div>
                <div class="intro-vs-text">VS</div>
                <div>
                    <div class="intro-name" id="ci-p2">PLAYER 2</div>
                    <div class="intro-nation" id="ci-n2">GERMANY</div>
                </div>
            </div>
            <div class="intro-sub">GAME ON</div>
        </div>

        <div class="intro-side intro-right">
            <img class="intro-flag-img" id="ci-flag-2" src="" alt="">
            <div class="intro-side-text" id="ci-nation-2">GER</div>
        </div>
    </div>

    <!-- MATCH SCREEN -->
    <div id="match-screen">
        <div class="event-bar">
            <button class="btn-exit-small" style="position: absolute; left: 10px; top: 5px; right:auto;"
                onclick="Persistence.clear()">EXIT</button>
            <img id="pdc-logo" src="https://seeklogo.com/images/P/pdc-darts-logo-A3945B413E-seeklogo.com.png" alt="PDC">
            <img id="event-logo" class="event-logo" src="" style="display:none;">
            <span id="txt-event-header">EVENT NAME</span>
            <button class="btn-icon" onclick="togglePause()"
                style="position: absolute; right: 10px; top: 0px; height: 36px;">‚è∏</button>
        </div>
        <div class="scoreboard-header" id="scoreboard-header">
            <div class="player-card" id="card-p0">
                <div class="name-strip">
                    <div class="starter-dot" id="dot-p0"></div>
                    <img class="flag" id="flag-p0" src="" alt="">
                    <span class="p-name" id="name-p0">PLAYER 1</span>
                </div>
                <div class="score-strip">
                    <div class="p-score" id="score-p0">501</div>
                    <div class="p-avg" id="avg-p0">AVG 0.00</div>
                </div>
            </div>
            <div class="player-card" id="card-p1">
                <div class="name-strip">
                    <div class="starter-dot" id="dot-p1"></div>
                    <img class="flag" id="flag-p1" src="" alt="">
                    <span class="p-name" id="name-p1">PLAYER 2</span>
                </div>
                <div class="score-strip">
                    <div class="p-score" id="score-p1">501</div>
                    <div class="p-avg" id="avg-p1">AVG 0.00</div>
                </div>
            </div>
        </div>
        <div class="visit-board" id="visit-container"></div>
        <div class="bottom-bar">
            <div class="legs-display">
                <div class="score-box-left">
                    <div class="leg-name" id="bot-name-p0">NAME</div>
                    <div class="main-score" id="bot-sets-p0">0</div>
                    <div class="sub-score" id="bot-legs-p0">0</div>
                </div>
                <div class="leg-label"><span id="lbl-score-type">SETS</span></div>
                <div class="score-box-right">
                    <div class="sub-score" id="bot-legs-p1">0</div>
                    <div class="main-score" id="bot-sets-p1">0</div>
                    <div class="leg-name" id="bot-name-p1">NAME</div>
                </div>
            </div>
        </div>
    </div>

    <!-- POST MATCH STATS -->
    <div id="post-match-screen">
        <div class="stats-header">
            <div class="stats-title">MATCH STATISTICS</div>
            <div class="stats-subtitle" id="stats-event-name">Event Name</div>
        </div>

        <div class="stats-grid">
            <div class="p-head" id="stats-p0-head">
                <img src="" id="stats-p0-flag">
                <span id="stats-p0-name">Player 1</span>
            </div>
            <div></div>
            <div class="p-head" id="stats-p1-head">
                <img src="" id="stats-p1-flag">
                <span id="stats-p1-name">Player 2</span>
            </div>

            <div class="stat-row">
                <div class="stat-val" id="st-avg-0">0.00</div>
                <div class="stat-label">3-Dart Avg</div>
                <div class="stat-val" id="st-avg-1">0.00</div>
            </div>
            <div class="stat-row">
                <div class="stat-val" id="st-180-0">0</div>
                <div class="stat-label">180s</div>
                <div class="stat-val" id="st-180-1">0</div>
            </div>
            <div class="stat-row">
                <div class="stat-val" id="st-co-0">0%</div>
                <div class="stat-label">Checkout %</div>
                <div class="stat-val" id="st-co-1">0%</div>
            </div>
            <div class="stat-row">
                <div class="stat-val" id="st-high-0">0</div>
                <div class="stat-label">Highest Out</div>
                <div class="stat-val" id="st-high-1">0</div>
            </div>
            <div class="stat-row">
                <div class="stat-val" id="st-tonplus-0">0</div>
                <div class="stat-label">100+ Checkouts</div>
                <div class="stat-val" id="st-tonplus-1">0</div>
            </div>
            <div class="stat-row" id="row-legs-won" style="display:none;">
                <div class="stat-val" id="st-legs-0">0</div>
                <div class="stat-label">Legs Won</div>
                <div class="stat-val" id="st-legs-1">0</div>
            </div>
        </div>

        <button class="btn-gold" id="btn-stats-continue" style="width:90%; max-width:400px; margin-bottom: 20px;"
            onclick="returnToMenu()">CONTINUE</button>
    </div>

    <!-- OVERLAYS -->
    <div id="overlay-intro" class="overlay">
        <div class="intro-box">
            <div class="intro-title" id="intro-title-txt" style="font-size:24px; font-weight:bold;">Leg 1</div>
            <div class="intro-name" id="intro-name-txt" style="font-size:30px; font-weight:bold; margin:10px 0;">
                Player
                Name</div>
            <div style="margin-top:10px; font-size:14px; color:#ddd;">TO THROW FIRST</div>
        </div>
    </div>
    <div id="overlay-shot" class="overlay"></div>
    <div id="overlay-180" class="overlay">
        <div class="one-eighty-box">180</div>
    </div>

    <div id="overlay-end" class="overlay">
        <div class="end-box">
            <img src="https://seeklogo.com/images/P/pdc-darts-logo-A3945B413E-seeklogo.com.png" height="40"
                style="margin-bottom:20px;">
            <div style="color:#aaa;">MATCH WINNER</div>
            <div class="end-winner" id="end-winner-name">PLAYER</div>
            <div class="end-score" id="end-score-txt">0 - 0</div>
            <button class="btn-gold" id="btn-end-match">VIEW STATS</button>
        </div>
    </div>

    <!-- PAUSE / RESUME OVERLAY -->
    <div id="overlay-resume" class="overlay">
        <div class="end-box">
            <div style="font-size:20px; font-weight:bold; margin-bottom:10px; color:var(--pdc-gold);">MATCH PAUSED
            </div>
            <div id="pause-info-text"
                style="color:white; font-size:14px; font-weight:bold; margin-bottom:20px; text-transform:uppercase;">
                FORMAT INFO</div>

            <button class="btn-gold" onclick="resumeFromReload()">RESUME MATCH</button>
            <!-- MOVED SIM BUTTON HERE -->
            <button class="btn-gold" style="background: var(--pdc-green); margin-top:10px;"
                onclick="simulateMatchToEnd()">‚ö° SIMULATE TO END</button>
            <button class="btn-gold" style="background: #444; border:1px solid #666; margin-top:10px;"
                onclick="Persistence.clear()">EXIT MATCH</button>
        </div>
    </div>

    <!-- ADVANCEMENT ANIMATION -->
    <div id="advancement-overlay">
        <div class="advancement-container">
            <div class="advancement-title" id="adv-title">PLAYERS ADVANCING</div>
            <div class="advancement-subtitle" id="adv-subtitle">TO QUARTER-FINALS</div>
            <div class="advancement-grid" id="adv-grid"></div>
            <button class="advancement-continue" onclick="Tournament.closeAdvancementOverlay()">CONTINUE</button>
        </div>
    </div>

    <!-- EVENT INFO MODAL -->
    <div id="event-info-modal">
        <div class="event-info-box">
            <div class="event-info-header" id="info-header">EVENT NAME</div>
            <div class="event-info-details" id="info-details"></div>
            <div id="info-results"></div>
            <button class="close-event-info" onclick="Season.closeEventInfo()">CLOSE</button>
        </div>
    </div>

    <!-- CAREER PLAYER MODAL -->
    <div id="career-player-modal">
        <div class="event-info-box career-player-box">
            <div class="event-info-header">CUSTOMIZE YOUR PLAYER</div>
            <div style="display:flex; gap:6px; margin-bottom:10px;">
                <button class="format-btn selected" id="career-tab-existing"
                    onclick="Season.switchCareerPlayerTab('existing')">EXISTING PRO</button>
                <button class="format-btn" id="career-tab-custom"
                    onclick="Season.switchCareerPlayerTab('custom')">CREATE PLAYER</button>
            </div>

            <div id="career-player-existing"
                style="display:flex; flex-direction:column; gap:8px; flex:1; overflow:hidden;">
                <label>Search Player</label>
                <input type="text" id="career-player-search" placeholder="Type a name..."
                    onkeyup="Season.filterCareerPlayerList()">
                <div id="career-player-list"
                    style="flex:1; overflow-y:auto; border:1px solid rgba(255,255,255,0.1); border-radius:6px; background:#111;">
                </div>
            </div>

            <div id="career-player-custom" style="display:none; flex-direction:column; gap:8px;">
                <div>
                    <label>PLAYER NAME</label>
                    <input type="text" id="career-custom-name" placeholder="Enter your name">
                </div>
                <div>
                    <label>NATIONALITY</label>
                    <select id="career-custom-country"></select>
                </div>
                <div>
                    <label>HOME CITY</label>
                    <input type="text" id="career-custom-city" placeholder="London">
                </div>
                <div>
                    <label>HOME COUNTRY</label>
                    <input type="text" id="career-custom-home-country" placeholder="England">
                </div>
                <div>
                    <label>HOME REGION (AFFECTS TRAVEL COSTS)</label>
                    <select id="career-custom-region"></select>
                </div>
                <div>
                    <label>STARTING AGE</label>
                    <input type="number" id="career-custom-age" min="16" max="60" value="25">
                </div>
                <div>
                    <label>STARTING MONEY</label>
                    <input type="number" id="career-custom-money" min="0" max="10000000" step="5000" value="5000">
                </div>
                <div>
                    <label>MATCH AVERAGE</label>
                    <div style="display:flex; align-items:center; gap:8px;">
                        <input type="range" id="career-custom-avg" min="60" max="110" step="0.1" value="60"
                            style="flex:1;">
                        <span id="career-custom-avg-display" style="min-width:50px; text-align:right;">60.0</span>
                    </div>
                </div>
                <div>
                    <label>CHECKOUT %</label>
                    <div style="display:flex; align-items:center; gap:8px;">
                        <input type="range" id="career-custom-co" min="20" max="60" step="0.1" value="35"
                            style="flex:1;">
                        <span id="career-custom-co-display" style="min-width:50px; text-align:right;">35.0%</span>
                    </div>
                </div>
                <div class="checkbox-row" onclick="const cb=this.querySelector('input'); cb.checked=!cb.checked;">
                    <input type="checkbox" id="career-custom-tourcard">
                    <label for="career-custom-tourcard"
                        style="margin:0; color:#ddd; font-size:12px; text-transform:none;">Tour Card Holder (Costs
                        additional qualification for major events)</label>
                </div>
                <button class="btn-gold" onclick="Season.createCustomCareerPlayer()">CREATE PLAYER</button>
            </div>

            <button class="close-event-info" onclick="Season.closeCareerPlayerModal()">CLOSE</button>
        </div>
    </div>

    <!-- CAREER CALENDAR OVERLAY -->
    <div id="career-calendar-overlay" class="career-overlay">
        <div class="career-overlay-card">
            <div class="career-overlay-topbar">
                <div class="career-overlay-title">Season Calendar</div>
                <button class="btn-gold" style="padding: 10px 24px; font-size: 13px;"
                    onclick="Season.closeCareerOverlay('career-calendar-overlay')">‚úï CLOSE</button>
            </div>
            <div class="career-overlay-content">
                <div id="career-calendar-overlay-list" class="career-calendar-list" style="max-height: none;"></div>
            </div>
        </div>
    </div>

    <!-- CAREER RANKINGS OVERLAY -->
    <div id="career-rankings-overlay" class="career-overlay">
        <div class="career-overlay-card">
            <div class="career-overlay-topbar">
                <div class="career-overlay-title">Order of Merit & Rankings</div>
                <button class="btn-gold" style="padding: 10px 24px; font-size: 13px;"
                    onclick="Season.closeCareerOverlay('career-rankings-overlay')">‚úï CLOSE</button>
            </div>
            <div class="career-overlay-content">
                <div class="career-overlay-panel">
                    <div class="oom-nav" style="margin-top:0; background: transparent; border: none;">
                        <button class="oom-nav-btn active" id="career-rank-main-btn"
                            onclick="Season.switchCareerRankingsTab('main')">Main</button>
                        <button class="oom-nav-btn" id="career-rank-pro-btn"
                            onclick="Season.switchCareerRankingsTab('pro')">Pro Tour</button>
                        <button class="oom-nav-btn" id="career-rank-challenge-btn"
                            onclick="Season.switchCareerRankingsTab('challenge')">Challenge Tour</button>
                        <button class="oom-nav-btn" id="career-rank-ws-btn"
                            onclick="Season.switchCareerRankingsTab('ws')">World Series</button>
                        <button class="oom-nav-btn" id="career-rank-premier-btn"
                            onclick="Season.switchCareerRankingsTab('premier')">Premier League</button>
                        <button class="oom-nav-btn" id="career-rank-qschool-btn"
                            onclick="Season.switchCareerRankingsTab('qschool')">Q-School</button>
                    </div>

                    <div id="career-rank-main" class="oom-view">
                        <table class="oom-table" id="career-rank-table-main"></table>
                    </div>
                    <div id="career-rank-pro" class="oom-view" style="display:none;">
                        <table class="oom-table" id="career-rank-table-pro"></table>
                    </div>
                    <div id="career-rank-challenge" class="oom-view" style="display:none;">
                        <table class="oom-table" id="career-rank-table-challenge"></table>
                    </div>
                    <div id="career-rank-ws" class="oom-view" style="display:none;">
                        <table class="oom-table" id="career-rank-table-ws"></table>
                    </div>
                    <div id="career-rank-premier" class="oom-view" style="display:none;"></div>
                    <div id="career-rank-qschool" class="oom-view" style="display:none;">
                        <div style="display:flex; gap:6px; margin-bottom:8px;">
                            <button class="career-standings-subtab active" id="career-rank-qschool-uk"
                                onclick="Season.switchCareerRankingsQSchool('uk')">UK</button>
                            <button class="career-standings-subtab" id="career-rank-qschool-eu"
                                onclick="Season.switchCareerRankingsQSchool('eu')">EU</button>
                        </div>
                        <div id="career-rank-qschool-uk-view"></div>
                        <div id="career-rank-qschool-eu-view" style="display:none;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- CAREER NEWS OVERLAY -->
    <div id="career-news-overlay" class="career-overlay">
        <div class="career-overlay-card">
            <div class="career-overlay-topbar">
                <div class="career-overlay-title">üì∞ Latest News</div>
                <button class="btn-gold" style="padding: 10px 24px; font-size: 13px;"
                    onclick="Season.closeCareerOverlay('career-news-overlay')">‚úï CLOSE</button>
            </div>
            <div class="career-overlay-content">
                <div class="career-overlay-panel">
                    <div id="career-news-feed" style="max-height: 600px; overflow-y: auto;">
                        <div style="text-align:center; padding:40px; color:#666; font-size:13px;">Loading news...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- CAREER FORM/FATIGUE OVERLAY -->
    <div id="career-form-overlay" class="career-overlay">
        <div class="career-overlay-card">
            <div class="career-overlay-topbar">
                <div class="career-overlay-title">üìä Form & Fatigue Chart</div>
                <button class="btn-gold" style="padding: 10px 24px; font-size: 13px;"
                    onclick="Season.closeCareerOverlay('career-form-overlay')">‚úï CLOSE</button>
            </div>
            <div class="career-overlay-content">
                <div class="career-overlay-panel">
                    <table class="oom-table" id="career-form-table" style="margin-top:10px;">
                        <thead>
                            <tr
                                style="background:#1a1f35; border-bottom:2px solid var(--pdc-gold); position:sticky; top:0;">
                                <th style="padding:8px; text-align:left; color:var(--pdc-gold);">Rank</th>
                                <th style="padding:8px; text-align:left; color:var(--pdc-gold);">Player</th>
                                <th style="padding:8px; text-align:center; color:var(--pdc-gold);">Form</th>
                                <th style="padding:8px; text-align:center; color:var(--pdc-gold);">Fatigue</th>
                                <th style="padding:8px; text-align:center; color:var(--pdc-gold);">Avg</th>
                            </tr>
                        </thead>
                        <tbody id="career-form-tbody"></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== SAFE ONCLICK WRAPPERS =====
        // These wrappers safely call App methods from onclick handlers
        function switchTab(tab) { App && App.switchTab(tab); }
        function switchStandingSection(section) { App && App.switchStandingSection(section); }
        function switchOOMView(view) { App && App.switchOOMView(view); }
        function switchQSchoolView(venue) { App && App.switchQSchoolView(venue); }
        function setMode(mode) { App && App.setMode(mode); }
        function startMatch() { App && App.startMatch(); }
        function togglePause() { App && App.togglePause(); }
        function returnToMenu() { App && App.returnToMenu(); }
        function resumeFromReload() { App && App.resumeFromReload(); }
        function simulateMatchToEnd() { App && App.simulateMatchToEnd(); }
        function selectPlayer(id, idx) { App && App.selectPlayer(id, idx); }

        function getBestFromCountry(code) {
            return [...PLAYERS_DB]
                .filter(p => p.country === code)
                .sort((a, b) => (Season.state.orderOfMerit[b.name] || 0) - (Season.state.orderOfMerit[a.name] || 0))[0];
        }

        function getBestFromRegion(region) {
            return [...PLAYERS_DB]
                .filter(p => REGION_MAP[region]?.includes(p.country))
                .sort((a, b) => (Season.state.orderOfMerit[b.name] || 0) - (Season.state.orderOfMerit[a.name] || 0))[0];
        }

        function getTopFromOOM(source, count, skipSet) {
            return Object.entries(source)
                .sort((a, b) => b[1] - a[1])
                .map(e => e[0])
                .filter(n => !skipSet.has(n))
                .slice(0, count);
        }

        // ================= WAKE LOCK =================
        let wakeLock = null;
        function toggleCustomTheme() {
            const el = document.getElementById('tourn-theme');
            const opts = document.getElementById('custom-theme-options');
            if (el && opts) {
                opts.style.display = (el.value === 'custom') ? 'block' : 'none';
            }
        }

        const requestWakeLock = async () => {
            if ('wakeLock' in navigator) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log('Wake Lock active');
                } catch (err) {
                    console.log('Wake Lock Error:', err.message);
                }
            }
        };
        document.addEventListener('visibilitychange', async () => {
            if (wakeLock !== null && document.visibilityState === 'visible') {
                await requestWakeLock();

            }
        });

        // ================= DATA =================
        // API URL for database operations
        const API_BASE = '/api';

        // Global event themes - initialized with defaults immediately, then merged with server data
        let EVENT_THEMES = {
            'matchplay': { color1: '#8B0000', color2: '#B22222', logo: 'worldmatchplay.png', theme: 'theme-matchplay', activeGradient: ['#B22222', '#8B0000'], legNameColor: 'white' },
            'uk-open': { color1: '#C8102E', color2: '#FFD100', logo: 'ukopen.png', theme: 'theme-uk-open', activeGradient: ['#8402db', '#C8102E'], legNameColor: 'white' },
            'playersf': { color1: '#111111', color2: '#C8102E', logo: 'playersc.png', theme: 'theme-players-championship', activeGradient: ['#C8102E', '#111111'], legNameColor: 'white' },
            'grandslam': { color1: '#FF8C00', color2: '#111111', logo: 'mrvegas.png', theme: 'theme-grand-slam', activeGradient: ['#FF8C00', '#D97706'], legNameColor: 'white' },
            'masters-final': { color1: '#7A0000', color2: '#000000', logo: 'worldseriesofdarts.png', theme: 'theme-world-series', activeGradient: ['#000000', '#7A0000'], legNameColor: 'white' },
            'grandprix': { color1: '#0033A0', color2: '#00AEEF', logo: 'grandprix.png', theme: 'theme-world-grandprix', activeGradient: ['#fd0202', '#000000'], legNameColor: 'white' },
            'winmaudm': { color1: '#000000', color2: '#FFFFFF', logo: 'worldmasters.png', theme: 'theme-winmau', activeGradient: ['#FFFFFF', '#000000'], legNameColor: '#000' },
            'wmasters-qual': { color1: '#000000', color2: '#FFFFFF', logo: 'worldmasters.png', theme: 'theme-winmau', activeGradient: ['#FFFFFF', '#000000'], legNameColor: '#000' },
            'europeanf': { color1: '#5B2D8B', color2: '#C0C0C0', logo: 'europeanchampionship.png', theme: 'theme-european', activeGradient: ['#C0C0C0', '#5B2D8B'], legNameColor: '#000' },
            'world': { color1: '#0C3B2E', color2: '#1E7F43', logo: 'worldchampionship.png', theme: 'theme-world-championship', activeGradient: ['#1E7F43', '#0C3B2E'], legNameColor: 'white' },
            'players': { color1: '#111111', color2: '#C8102E', logo: 'playersc.png', theme: 'theme-players-championship', activeGradient: ['#C8102E', '#111111'], legNameColor: 'white' },
            'premier-league': { color1: '#0A1AFF', color2: '#001B5E', logo: 'premierleague.png', theme: 'theme-premier-league', activeGradient: ['#FFD100', '#796d02'], legNameColor: 'white' },
            'premier-league-playoff': { color1: '#0A1AFF', color2: '#001B5E', logo: 'premierleague.png', theme: 'theme-premier-league', activeGradient: ['#FFD100', '#796d02'], legNameColor: 'white' },
            'masters': { color1: '#000000', color2: '#D4AF37', logo: 'worldseries.png', theme: 'theme-masters', activeGradient: ['#D4AF37', '#000000'], legNameColor: '#000' },
            'minor': { color1: '#1A1A1A', color2: '#2E2E2E', logo: '', theme: 'theme-minor', activeGradient: ['#2E2E2E', '#1A1A1A'], legNameColor: 'white' },
            'challenge': { color1: '#1A1A1A', color2: '#2E2E2E', logo: '', theme: 'theme-minor', activeGradient: ['#2E2E2E', '#1A1A1A'], legNameColor: 'white' },
            'q-school': { color1: '#1A1A1A', color2: '#2E2E2E', logo: '', theme: 'theme-minor', activeGradient: ['#2E2E2E', '#1A1A1A'], legNameColor: 'white' },
            'et-qual-tc': { color1: '#1A1A1A', color2: '#2E2E2E', logo: '', theme: 'theme-minor', activeGradient: ['#2E2E2E', '#1A1A1A'], legNameColor: 'white' },
            'et-host-nation': { color1: '#1A1A1A', color2: '#2E2E2E', logo: '', theme: 'theme-minor', activeGradient: ['#2E2E2E', '#1A1A1A'], legNameColor: 'white' },
            'et-east-european': { color1: '#1A1A1A', color2: '#2E2E2E', logo: '', theme: 'theme-minor', activeGradient: ['#2E2E2E', '#1A1A1A'], legNameColor: 'white' },
            'et-nordic-baltic': { color1: '#1A1A1A', color2: '#2E2E2E', logo: '', theme: 'theme-minor', activeGradient: ['#2E2E2E', '#1A1A1A'], legNameColor: 'white' },
            'ws-qual-tc': { color1: '#7A0000', color2: '#000000', logo: 'worldseries.png', theme: 'theme-world-series', activeGradient: ['#000000', '#7A0000'], legNameColor: 'white' },
            'gs-qual-tc': { color1: '#FF8C00', color2: '#111111', logo: 'mrvegas.png', theme: 'theme-grand-slam', activeGradient: ['#FF8C00', '#D97706'], legNameColor: 'white' },
            'wc-qual-intl': { color1: '#0C3B2E', color2: '#1E7F43', logo: 'worldchampionship.png', theme: 'theme-world-championship', activeGradient: ['#1E7F43', '#0C3B2E'], legNameColor: 'white' },
            'wc-qual-tc': { color1: '#0C3B2E', color2: '#1E7F43', logo: 'worldchampionship.png', theme: 'theme-world-championship', activeGradient: ['#1E7F43', '#0C3B2E'], legNameColor: 'white' }
        };

        // Database loader - tries to load from server, falls back to hardcoded
        const DataLoader = {
            async loadPlayers() {
                try {
                    const response = await fetch(API_BASE + '/players');
                    const data = await response.json();
                    if (data.success && data.players && data.players.length > 0) {
                        console.log('[DataLoader] Loaded ' + data.players.length + ' players from database');
                        return data.players;
                    }
                } catch (e) {
                    console.log('[DataLoader] Could not load players from database, using defaults');
                }
                return null; // Fall back to hardcoded
            },

            async loadTournaments() {
                try {
                    const response = await fetch(API_BASE + '/tournaments');
                    const data = await response.json();
                    if (data.success && data.tournaments && data.tournaments.length > 0) {
                        console.log('[DataLoader] Loaded ' + data.tournaments.length + ' tournaments from database');
                        // Convert eligibleRegions from JSON string to array if needed
                        return data.tournaments.map(t => ({
                            ...t,
                            cardRequired: Boolean(t.cardRequired),
                            eligibleRegions: typeof t.eligibleRegions === 'string' ? JSON.parse(t.eligibleRegions) : t.eligibleRegions
                        }));
                    }
                } catch (e) {
                    console.log('[DataLoader] Could not load tournaments from database, using defaults');
                }
                return null; // Fall back to hardcoded
            },

            async loadThemes() {
                // Always get fresh defaults from getDefaultThemes() - never copy from current EVENT_THEMES
                // This prevents issues if loadThemes is called multiple times
                const defaultThemes = DataLoader.getDefaultThemes();
                console.log('[DataLoader] Default themes from getDefaultThemes():', Object.keys(defaultThemes).length, 'keys');

                // Start with full defaults
                EVENT_THEMES = { ...defaultThemes };

                try {
                    const response = await fetch(API_BASE + '/themes');
                    const data = await response.json();
                    console.log('[DataLoader] Server response:', data);

                    if (data.success && data.themes) {
                        const serverThemes = data.themes;
                        const serverKeys = Object.keys(serverThemes);
                        console.log('[DataLoader] Server themes:', serverKeys.length, 'keys:', serverKeys);

                        // Merge server themes ON TOP of defaults (server overrides/adds)
                        for (const key of serverKeys) {
                            EVENT_THEMES[key] = serverThemes[key];
                        }

                        console.log('[DataLoader] After merge, EVENT_THEMES has', Object.keys(EVENT_THEMES).length, 'keys');
                        return EVENT_THEMES;
                    }
                } catch (e) {
                    console.log('[DataLoader] Could not load themes from server:', e);
                }
                console.log('[DataLoader] Using default themes, keys:', Object.keys(EVENT_THEMES).length);
                return EVENT_THEMES;
            },

            getDefaultThemes() {
                // EXACT copy from admin.html DEFAULT_APPEARANCE - keys match tournament types
                return {
                    'matchplay': { color1: '#8B0000', color2: '#B22222', logo: 'worldmatchplay.png', theme: 'theme-matchplay', activeGradient: ['#B22222', '#8B0000'], legNameColor: 'white' },
                    'uk-open': { color1: '#C8102E', color2: '#FFD100', logo: 'ukopen.png', theme: 'theme-uk-open', activeGradient: ['#8402db', '#C8102E'], legNameColor: 'white' },
                    'playersf': { color1: '#111111', color2: '#C8102E', logo: 'playersc.png', theme: 'theme-players-championship', activeGradient: ['#C8102E', '#111111'], legNameColor: 'white' },
                    'grandslam': { color1: '#FF8C00', color2: '#111111', logo: 'mrvegas.png', theme: 'theme-grand-slam', activeGradient: ['#FF8C00', '#D97706'], legNameColor: 'white' },
                    'masters-final': { color1: '#7A0000', color2: '#000000', logo: 'worldseriesofdarts.png', theme: 'theme-world-series', activeGradient: ['#000000', '#7A0000'], legNameColor: 'white' },
                    'grandprix': { color1: '#0033A0', color2: '#00AEEF', logo: 'grandprix.png', theme: 'theme-world-grandprix', activeGradient: ['#fd0202', '#000000'], legNameColor: 'white' },
                    'winmaudm': { color1: '#000000', color2: '#FFFFFF', logo: 'worldmasters.png', theme: 'theme-winmau', activeGradient: ['#FFFFFF', '#000000'], legNameColor: '#000' },
                    'wmasters-qual': { color1: '#000000', color2: '#FFFFFF', logo: 'worldmasters.png', theme: 'theme-winmau', activeGradient: ['#FFFFFF', '#000000'], legNameColor: '#000' },
                    'europeanf': { color1: '#5B2D8B', color2: '#C0C0C0', logo: 'europeanchampionship.png', theme: 'theme-european', activeGradient: ['#C0C0C0', '#5B2D8B'], legNameColor: '#000' },
                    'world': { color1: '#0C3B2E', color2: '#1E7F43', logo: 'worldchampionship.png', theme: 'theme-world-championship', activeGradient: ['#1E7F43', '#0C3B2E'], legNameColor: 'white' },
                    'players': { color1: '#111111', color2: '#C8102E', logo: 'playersc.png', theme: 'theme-players-championship', activeGradient: ['#C8102E', '#111111'], legNameColor: 'white' },
                    'premier-league': { color1: '#0A1AFF', color2: '#001B5E', logo: 'premierleague.png', theme: 'theme-premier-league', activeGradient: ['#FFD100', '#796d02'], legNameColor: 'white' },
                    'premier-league-playoff': { color1: '#0A1AFF', color2: '#001B5E', logo: 'premierleague.png', theme: 'theme-premier-league', activeGradient: ['#FFD100', '#796d02'], legNameColor: 'white' },
                    'masters': { color1: '#000000', color2: '#D4AF37', logo: 'worldseries.png', theme: 'theme-masters', activeGradient: ['#D4AF37', '#000000'], legNameColor: '#000' },
                    'minor': { color1: '#1A1A1A', color2: '#2E2E2E', logo: '', theme: 'theme-minor', activeGradient: ['#2E2E2E', '#1A1A1A'], legNameColor: 'white' },
                    'challenge': { color1: '#1A1A1A', color2: '#2E2E2E', logo: '', theme: 'theme-minor', activeGradient: ['#2E2E2E', '#1A1A1A'], legNameColor: 'white' },
                    'q-school': { color1: '#1A1A1A', color2: '#2E2E2E', logo: '', theme: 'theme-minor', activeGradient: ['#2E2E2E', '#1A1A1A'], legNameColor: 'white' },
                    'et-qual-tc': { color1: '#1A1A1A', color2: '#2E2E2E', logo: '', theme: 'theme-minor', activeGradient: ['#2E2E2E', '#1A1A1A'], legNameColor: 'white' },
                    'et-host-nation': { color1: '#1A1A1A', color2: '#2E2E2E', logo: '', theme: 'theme-minor', activeGradient: ['#2E2E2E', '#1A1A1A'], legNameColor: 'white' },
                    'et-east-european': { color1: '#1A1A1A', color2: '#2E2E2E', logo: '', theme: 'theme-minor', activeGradient: ['#2E2E2E', '#1A1A1A'], legNameColor: 'white' },
                    'et-nordic-baltic': { color1: '#1A1A1A', color2: '#2E2E2E', logo: '', theme: 'theme-minor', activeGradient: ['#2E2E2E', '#1A1A1A'], legNameColor: 'white' },
                    'ws-qual-tc': { color1: '#7A0000', color2: '#000000', logo: 'worldseries.png', theme: 'theme-world-series', activeGradient: ['#000000', '#7A0000'], legNameColor: 'white' },
                    'gs-qual-tc': { color1: '#FF8C00', color2: '#111111', logo: 'mrvegas.png', theme: 'theme-grand-slam', activeGradient: ['#FF8C00', '#D97706'], legNameColor: 'white' },
                    'wc-qual-intl': { color1: '#0C3B2E', color2: '#1E7F43', logo: 'worldchampionship.png', theme: 'theme-world-championship', activeGradient: ['#1E7F43', '#0C3B2E'], legNameColor: 'white' },
                    'wc-qual-tc': { color1: '#0C3B2E', color2: '#1E7F43', logo: 'worldchampionship.png', theme: 'theme-world-championship', activeGradient: ['#1E7F43', '#0C3B2E'], legNameColor: 'white' }
                };
            },

            // Find theme for an event by its type/theme key
            // Now themes are looked up directly by tournament type in EVENT_THEMES
            findThemeForEvent(eventName) {
                // Ensure EVENT_THEMES is populated with defaults
                if (!EVENT_THEMES || Object.keys(EVENT_THEMES).length === 0) {
                    EVENT_THEMES = DataLoader.getDefaultThemes();
                }
                // Return minor theme as fallback since themes should come from database
                const minorTheme = EVENT_THEMES['minor'];
                if (minorTheme) {
                    console.log('[findThemeForEvent] Returning minor theme');
                    return minorTheme;
                }
                // Ultimate fallback - return hardcoded minor theme
                console.log('[findThemeForEvent] Returning hardcoded fallback');
                return { color1: '#1A1A1A', color2: '#2E2E2E', logo: '', theme: 'theme-minor', activeGradient: ['#2E2E2E', '#1A1A1A'], legNameColor: 'white' };
            }
        };

        // Default players (fallback if database is empty or unavailable)
        const RAW_PLAYERS = [{ name: "Luke Littler", country: "eng", avg: 101.09, co: 46.0, fav: 20, money: 2770500, tourCard: true },
        { name: "Luke Humphries", country: "eng", avg: 98.69, co: 45.0, fav: 20, money: 1172000, tourCard: true },
        { name: "Gian van Veen", country: "nl", avg: 98.27, co: 44.0, fav: 20, money: 912500, tourCard: true },
        { name: "Michael van Gerwen", country: "nl", avg: 96.95, co: 42.0, fav: 20, money: 691250, tourCard: true },
        { name: "Jonny Clayton", country: "wal", avg: 96.43, co: 41.0, fav: 16, money: 625000, tourCard: true },
        { name: "Gary Anderson", country: "sco", avg: 97.92, co: 39.0, fav: 20, money: 609500, tourCard: true },
        { name: "Stephen Bunting", country: "eng", avg: 97.90, co: 40.0, fav: 20, money: 593750, tourCard: true },
        { name: "Ryan Searle", country: "eng", avg: 95.58, co: 38.0, fav: 20, money: 568000, tourCard: true },
        { name: "Josh Rock", country: "nir", avg: 98.15, co: 37.0, fav: 20, money: 555500, tourCard: true },
        { name: "Danny Noppert", country: "nl", avg: 94.97, co: 40.0, fav: 20, money: 550750, tourCard: true },
        { name: "James Wade", country: "eng", avg: 94.73, co: 45.0, fav: 16, money: 544250, tourCard: true },
        { name: "Gerwyn Price", country: "wal", avg: 97.95, co: 39.0, fav: 20, money: 521000, tourCard: true },
        { name: "Chris Dobey", country: "eng", avg: 96.88, co: 38.0, fav: 20, money: 505250, tourCard: true },
        { name: "Nathan Aspinall", country: "eng", avg: 95.72, co: 38.0, fav: 20, money: 460000, tourCard: true },
        { name: "Martin Schindler", country: "ger", avg: 94.19, co: 37.0, fav: 20, money: 458250, tourCard: true },
        { name: "Ross Smith", country: "eng", avg: 96.57, co: 37.0, fav: 20, money: 447750, tourCard: true },
        { name: "Damon Heta", country: "aus", avg: 94.76, co: 38.0, fav: 16, money: 439000, tourCard: true },
        { name: "Jermaine Wattimena", country: "nl", avg: 94.72, co: 37.0, fav: 20, money: 423000, tourCard: true },
        { name: "Mike De Decker", country: "bel", avg: 93.78, co: 39.0, fav: 20, money: 413500, tourCard: true },
        { name: "Rob Cross", country: "eng", avg: 95.89, co: 42.0, fav: 18, money: 389000, tourCard: true },
        { name: "Luke Woodhouse", country: "eng", avg: 92.74, co: 37.0, fav: 20, money: 383000, tourCard: true },
        { name: "Dave Chisnall", country: "eng", avg: 91.70, co: 36.0, fav: 20, money: 362500, tourCard: true },
        { name: "Daryl Gurney", country: "nir", avg: 93.10, co: 38.0, fav: 16, money: 346500, tourCard: true },
        { name: "Ryan Joyce", country: "eng", avg: 92.73, co: 36.0, fav: 20, money: 345000, tourCard: true },
        { name: "Dimitri Van den Bergh", country: "bel", avg: 88.89, co: 36.0, fav: 20, money: 335250, tourCard: true },
        { name: "Cameron Menzies", country: "sco", avg: 92.76, co: 39.0, fav: 20, money: 325250, tourCard: true },
        { name: "Ritchie Edhouse", country: "eng", avg: 91.00, co: 35.0, fav: 20, money: 324000, tourCard: true },
        { name: "Krzysztof Ratajski", country: "pl", avg: 94.57, co: 39.0, fav: 20, money: 322500, tourCard: true },
        { name: "Wessel Nijman", country: "nl", avg: 95.86, co: 38.0, fav: 20, money: 320750, tourCard: true },
        { name: "Dirk van Duijvenbode", country: "nl", avg: 96.60, co: 35.0, fav: 20, money: 319750, tourCard: true },
        { name: "Peter Wright", country: "sco", avg: 91.89, co: 37.0, fav: 20, money: 311500, tourCard: true },
        { name: "Michael Smith", country: "eng", avg: 92.70, co: 40.0, fav: 20, money: 303500, tourCard: true },
        { name: "Andrew Gilding", country: "eng", avg: 93.54, co: 40.0, fav: 20, money: 300000, tourCard: true },
        { name: "Ricardo Pietreczko", country: "ger", avg: 90.98, co: 34.0, fav: 20, money: 293000, tourCard: true },
        { name: "Joe Cullen", country: "eng", avg: 91.76, co: 36.0, fav: 20, money: 275000, tourCard: true },
        { name: "Raymond van Barneveld", country: "nl", avg: 91.51, co: 38.0, fav: 20, money: 246000, tourCard: true },
        { name: "Martin Lukeman", country: "eng", avg: 90.00, co: 36.0, fav: 20, money: 226500, tourCard: true },
        { name: "Kevin Doets", country: "nl", avg: 91.76, co: 35.0, fav: 20, money: 219000, tourCard: true },
        { name: "Callan Rydz", country: "eng", avg: 93.58, co: 38.0, fav: 20, money: 189000, tourCard: true },
        { name: "Ricky Evans", country: "eng", avg: 91.69, co: 35.0, fav: 20, money: 188000, tourCard: true },
        { name: "Brendan Dolan", country: "nir", avg: 90.91, co: 44.0, fav: 20, money: 183250, tourCard: true },
        { name: "Niels Zonneveld", country: "nl", avg: 93.04, co: 38.0, fav: 20, money: 182750, tourCard: true },
        { name: "William O'Connor", country: "irl", avg: 94.14, co: 37.0, fav: 20, money: 182250, tourCard: true },
        { name: "Scott Williams", country: "eng", avg: 91.34, co: 35.0, fav: 20, money: 173750, tourCard: true },
        { name: "Madars Razma", country: "lat", avg: 91.73, co: 34.0, fav: 20, money: 162500, tourCard: true },
        { name: "Mickey Mansell", country: "nir", avg: 91.59, co: 39.0, fav: 20, money: 159250, tourCard: true },
        { name: "Gabriel Clemens", country: "ger", avg: 91.69, co: 37.0, fav: 20, money: 154250, tourCard: true },
        { name: "James Hurrell", country: "eng", avg: 92.12, co: 38.0, fav: 20, money: 147000, tourCard: true },
        { name: "Connor Scutt", country: "eng", avg: 93.13, co: 36.0, fav: 20, money: 144750, tourCard: true },
        { name: "Justin Hood", country: "eng", avg: 92.24, co: 36.0, fav: 20, money: 139750, tourCard: true },
        { name: "Jeffrey de Graaf", country: "swe", avg: 90.30, co: 35.0, fav: 20, money: 139500, tourCard: true },
        { name: "Ian White", country: "eng", avg: 91.33, co: 36.0, fav: 20, money: 134500, tourCard: true },
        { name: "Alan Soutar", country: "sco", avg: 91.59, co: 37.0, fav: 20, money: 131500, tourCard: true },
        { name: "Niko Springer", country: "ger", avg: 93.74, co: 37.0, fav: 20, money: 129750, tourCard: true },
        { name: "Mensur Suljovic", country: "aut", avg: 91.68, co: 36.0, fav: 16, money: 127750, tourCard: true },
        { name: "Ryan Meikle", country: "eng", avg: 90.19, co: 35.0, fav: 20, money: 125500, tourCard: true },
        { name: "Richard Veenstra", country: "nl", avg: 90.72, co: 33.0, fav: 20, money: 117250, tourCard: true },
        { name: "Keane Barry", country: "irl", avg: 89.71, co: 32.0, fav: 20, money: 116250, tourCard: true },
        { name: "Nick Kenny", country: "wal", avg: 90.41, co: 34.0, fav: 20, money: 114500, tourCard: true },
        { name: "Kim Huybrechts", country: "bel", avg: 91.06, co: 35.0, fav: 20, money: 108000, tourCard: true },
        { name: "Thibault Tricole", country: "fra", avg: 89.44, co: 32.0, fav: 20, money: 106250, tourCard: true },
        { name: "Lukas Wenig", country: "ger", avg: 91.55, co: 35.0, fav: 20, money: 101250, tourCard: true },
        { name: "Rob Owen", country: "wal", avg: 90.07, co: 34.0, fav: 20, money: 95500, tourCard: true },
        { name: "Mario Vandenbogaerde", country: "bel", avg: 91.09, co: 36.0, fav: 20, money: 94750, tourCard: true },
        { name: "Karel Sedlacek", country: "cze", avg: 93.35, co: 34.0, fav: 20, money: 83000, tourCard: true },
        { name: "Bradley Brooks", country: "eng", avg: 93.01, co: 36.0, fav: 20, money: 78750, tourCard: true },
        { name: "Cam Crabtree", country: "eng", avg: 90.84, co: 34.0, fav: 20, money: 73000, tourCard: true },
        { name: "Wesley Plaisier", country: "nl", avg: 92.55, co: 36.0, fav: 20, money: 68500, tourCard: true },
        { name: "Sebastian Bialecki", country: "pol", avg: 90.36, co: 32.0, fav: 20, money: 63750, tourCard: true },
        { name: "Max Hopp", country: "ger", avg: 89.75, co: 34.0, fav: 20, money: 58250, tourCard: true },
        { name: "Adam Lipscombe", country: "eng", avg: 89.79, co: 32.0, fav: 20, money: 56750, tourCard: true },
        { name: "Dominik Gruellich", country: "ger", avg: 90.19, co: 33.0, fav: 20, money: 44250, tourCard: true },
        { name: "Cor Dekker", country: "nor", avg: 89.44, co: 33.0, fav: 20, money: 41250, tourCard: true },
        { name: "Maik Kuivenhoven", country: "nl", avg: 91.10, co: 34.0, fav: 20, money: 26000, tourCard: true },
        { name: "Andy Boulton", country: "eng", avg: 88.66, co: 31.0, fav: 20, money: 26000, tourCard: true },
        { name: "Tavis Dudeney", country: "eng", avg: 83.59, co: 29.0, fav: 20, money: 24500, tourCard: true },
        { name: "Oskar Lukasiak", country: "swe", avg: 86.91, co: 31.0, fav: 20, money: 24500, tourCard: true },
        { name: "Darryl Pilgrim", country: "eng", avg: 90.49, co: 33.0, fav: 20, money: 24250, tourCard: true },
        { name: "Tom Bissell", country: "eng", avg: 88.98, co: 32.0, fav: 20, money: 20250, tourCard: true },
        { name: "Christian Kist", country: "nl", avg: 90.42, co: 33.0, fav: 20, money: 20000, tourCard: true },
        { name: "Leon Weber", country: "ger", avg: 88.30, co: 32.0, fav: 20, money: 19750, tourCard: true },
        { name: "Dennie Olde Kalter", country: "nl", avg: 90.57, co: 33.0, fav: 20, money: 18500, tourCard: true },
        { name: "Jim Long", country: "can", avg: 87.40, co: 31.0, fav: 20, money: 17250, tourCard: true },
        { name: "Thomas Lovely", country: "eng", avg: 89.35, co: 32.0, fav: 20, money: 17250, tourCard: true },
        { name: "Marvin van Velzen", country: "nl", avg: 86.74, co: 31.0, fav: 20, money: 17250, tourCard: true },
        { name: "Viktor Tingstrom", country: "swe", avg: 88.87, co: 31.0, fav: 20, money: 16000, tourCard: true },
        { name: "Adam Warner", country: "eng", avg: 86.90, co: 31.0, fav: 20, money: 15500, tourCard: true },
        { name: "Greg Ritchie", country: "sco", avg: 89.12, co: 32.0, fav: 20, money: 13500, tourCard: true },
        { name: "Adam Paxton", country: "eng", avg: 87.10, co: 31.0, fav: 20, money: 11750, tourCard: true },
        { name: "Maximilian Czerwinski", country: "ger", avg: 84.82, co: 30.0, fav: 20, money: 11250, tourCard: true },
        { name: "Tytus Kanik", country: "pl", avg: 82.56, co: 29.0, fav: 20, money: 9250, tourCard: true },
        { name: "Stefaan Henderyck", country: "bel", avg: 86.57, co: 31.0, fav: 20, money: 8500, tourCard: true },
        { name: "Rusty-Jake Rodriguez", country: "aut", avg: 87.70, co: 32.0, fav: 20, money: 7500, tourCard: true },
        { name: "Pero Ljubic", country: "cro", avg: 82.87, co: 28.0, fav: 20, money: 5250, tourCard: true },
        { name: "Kai Gotthardt", country: "ger", avg: 90.06, co: 33.0, fav: 20, money: 5000, tourCard: true },
        { name: "Stefan Bellmont", country: "sui", avg: 86.60, co: 31.0, fav: 20, money: 0, tourCard: true },
        { name: "Darius Labanauskas", country: "lit", avg: 90.11, co: 33.0, fav: 20, money: 0, tourCard: true },
        { name: "Beau Greaves", country: "eng", avg: 95.03, co: 35.0, fav: 20, money: 0, tourCard: true },
        { name: "Owen Bates", country: "eng", avg: 91.52, co: 35.0, fav: 20, money: 0, tourCard: true },
        { name: "Rhys Griffin", country: "wal", avg: 87.33, co: 32.0, fav: 20, money: 0, tourCard: true },
        { name: "Adam Leek", country: "eng", avg: 85.00, co: 32.0, fav: 20, money: 0, tourCard: true },
        { name: "Carl Sneyd", country: "eng", avg: 89.86, co: 32.0, fav: 20, money: 0, tourCard: true },
        { name: "Niall Culleton", country: "irl", avg: 83.94, co: 50.68, fav: 16, money: 0, tourCard: true },
        { name: "Tom Sykes", country: "eng", avg: 88.78, co: 32.0, fav: 20, money: 0, tourCard: true },
        { name: "Shane McGuirk", country: "irl", avg: 89.87, co: 45.66, fav: 20, money: 0, tourCard: true },
        { name: "Charlie Manby", country: "eng", avg: 96.76, co: 42.0, fav: 20, money: 0, tourCard: true },
        { name: "Samuel Price", country: "eng", avg: 79.58, co: 48.29, fav: 16, money: 0, tourCard: true },
        { name: "Stephen Burton", country: "eng", avg: 89.78, co: 33.0, fav: 20, money: 0, tourCard: true },
        { name: "Mervyn King", country: "eng", avg: 90.23, co: 34.0, fav: 20, money: 0, tourCard: true },
        { name: "Tyler Thorpe", country: "eng", avg: 85.00, co: 30.0, fav: 20, money: 0, tourCard: true },
        { name: "Stephen Rosney", country: "eng", avg: 85.00, co: 30.0, fav: 20, money: 0, tourCard: true },
        { name: "David Sharp", country: "sco", avg: 90.32, co: 43.67, fav: 20, money: 0, tourCard: true },
        { name: "Filip Bereza", country: "pol", avg: 71.78, co: 45.14, fav: 16, money: 0, tourCard: true },
        { name: "Arno Merk", country: "ger", avg: 81.89, co: 29.0, fav: 20, money: 0, tourCard: true },
        { name: "Jeffrey Sparidaans", country: "nl", avg: 89.80, co: 32.0, fav: 20, money: 0, tourCard: true },
        { name: "Cristo Reyes", country: "esp", avg: 92.19, co: 36.0, fav: 20, money: 0, tourCard: true },
        { name: "Matthias Ehlers", country: "ger", avg: 83.48, co: 49.7, fav: 16, money: 0, tourCard: true },
        { name: "Yorick Hofkens", country: "bel", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: true },
        { name: "Jeffrey De Zwaan", country: "nl", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: true },
        { name: "Sietse Lap", country: "nl", avg: 83.37, co: 29.0, fav: 20, money: 0, tourCard: true },
        { name: "Jimmy van Schie", country: "nl", avg: 89.22, co: 32.0, fav: 20, money: 0, tourCard: true },
        { name: "Chris Landman", country: "nl", avg: 89.97, co: 33.0, fav: 20, money: 0, tourCard: true },
        { name: "Marvin Kraft", country: "ger", avg: 79.03, co: 19.71, fav: 20, money: 0, tourCard: true },
        { name: "Benjamin Pratnemer", country: "aut", avg: 89.00, co: 32.0, fav: 20, money: 0, tourCard: true },
        { name: "Adam Gawlas", country: "cze", avg: 87.00, co: 32.0, fav: 20, money: 0, tourCard: true },
        { name: "Jurjen van der Velde", country: "nl", avg: 88.50, co: 32.0, fav: 20, money: 0, tourCard: true },
        { name: "Alexander Merkx", country: "nl", avg: 90.99, co: 33.0, fav: 20, money: 0, tourCard: true },
        { name: "Pascal Rupprecht", country: "ger", avg: 88.00, co: 35.0, fav: 20, money: 0, tourCard: true },
        { name: "Adam Hunt", country: "eng", avg: 89.75, co: 33.0, fav: 20, money: 0, tourCard: false },
        { name: "Jim Williams", country: "wal", avg: 87.91, co: 31.0, fav: 20, money: 0, tourCard: false },
        { name: "Haupai Puha", country: "nzl", avg: 89.46, co: 32.0, fav: 20, money: 0, tourCard: false },
        { name: "Berry van Peer", country: "nl", avg: 87.17, co: 31.0, fav: 20, money: 0, tourCard: false },
        { name: "Patrick Geeraets", country: "nl", avg: 90.17, co: 32.0, fav: 20, money: 0, tourCard: false },
        { name: "Robert Grundy", country: "eng", avg: 89.17, co: 32.0, fav: 20, money: 0, tourCard: false },
        { name: "Nathan Rafferty", country: "nir", avg: 86.30, co: 31.0, fav: 20, money: 0, tourCard: false },
        { name: "Jitse Van der Wal", country: "nl", avg: 87.00, co: 32.0, fav: 20, money: 0, tourCard: false },
        { name: "Radek Szaganski", country: "pol", avg: 88.73, co: 33.0, fav: 20, money: 0, tourCard: false },
        { name: "Jelle Klaasen", country: "nl", avg: 88.54, co: 32.0, fav: 20, money: 0, tourCard: false },
        { name: "Martijn Dragt", country: "nl", avg: 88.88, co: 32.0, fav: 20, money: 0, tourCard: false },
        { name: "Jamai van den Herik", country: "nl", avg: 90.62, co: 33.0, fav: 20, money: 0, tourCard: false },
        { name: "Danny Lauby", country: "usa", avg: 85.87, co: 31.0, fav: 20, money: 0, tourCard: false },
        { name: "David Davies", country: "wal", avg: 88.86, co: 31.0, fav: 20, money: 0, tourCard: false },
        { name: "William Borland", country: "sco", avg: 89.84, co: 32.0, fav: 20, money: 0, tourCard: false },
        { name: "Benjamin Reus", country: "den", avg: 85.21, co: 31.0, fav: 20, money: 0, tourCard: false },
        { name: "Brett Claydon", country: "eng", avg: 86.46, co: 31.0, fav: 20, money: 0, tourCard: false },
        { name: "George Killington", country: "eng", avg: 86.01, co: 31.0, fav: 20, money: 0, tourCard: false },
        { name: "Adam Sevada", country: "usa", avg: 89.45, co: 32.0, fav: 20, money: 0, tourCard: false },
        { name: "David Munyua", country: "ken", avg: 85.50, co: 30.0, fav: 20, money: 0, tourCard: false },
        { name: "Joe Comito", country: "aus", avg: 85.50, co: 30.0, fav: 20, money: 0, tourCard: false },
        { name: "Jonny Tata", country: "aus", avg: 84.00, co: 30.0, fav: 20, money: 0, tourCard: false },
        { name: "Leonard Gates", country: "usa", avg: 88.00, co: 33.0, fav: 20, money: 0, tourCard: false },
        { name: "Motomu Sakai", country: "jpn", avg: 84.50, co: 30.0, fav: 20, money: 0, tourCard: false },
        { name: "Nitin Kumar", country: "ind", avg: 83.50, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Paul Lim", country: "sgp", avg: 86.50, co: 32.0, fav: 20, money: 0, tourCard: false },
        { name: "Ted Evetts", country: "eng", avg: 88.51, co: 32.0, fav: 20, money: 0, tourCard: false },
        { name: "Alexis Toylo", country: "phi", avg: 86.00, co: 31.0, fav: 20, money: 0, tourCard: false },
        { name: "Michele Turetta", country: "ita", avg: 87.20, co: 32.0, fav: 20, money: 0, tourCard: false },
        { name: "Alex Spellman", country: "usa", avg: 86.00, co: 31.0, fav: 20, money: 0, tourCard: false },
        { name: "Lisa Ashton", country: "eng", avg: 89.00, co: 33.0, fav: 20, money: 0, tourCard: false },
        { name: "Joshua Richardson", country: "eng", avg: 82.99, co: 30.0, fav: 20, money: 0, tourCard: false },
        { name: "Teemu Harju", country: "fin", avg: 87.50, co: 31.0, fav: 20, money: 0, tourCard: false },
        { name: "David Cameron", country: "can", avg: 88.00, co: 32.0, fav: 20, money: 0, tourCard: false },
        { name: "Gemma Hayter", country: "eng", avg: 88.00, co: 32.0, fav: 20, money: 0, tourCard: false },
        { name: "Jesus Salate", country: "arg", avg: 85.00, co: 30.0, fav: 20, money: 0, tourCard: false },
        { name: "Krzysztof Kciuk", country: "pl", avg: 88.00, co: 32.0, fav: 20, money: 0, tourCard: false },
        { name: "Lourence Ilagan", country: "phi", avg: 90.00, co: 33.0, fav: 20, money: 0, tourCard: false },
        { name: "Man Lok Leung", country: "hkg", avg: 88.00, co: 32.0, fav: 20, money: 0, tourCard: false },
        { name: "Mitsuhiko Tatsunami", country: "jpn", avg: 84.00, co: 30.0, fav: 20, money: 0, tourCard: false },
        { name: "Noa-Lynn van Leuven", country: "nl", avg: 88.00, co: 32.0, fav: 20, money: 0, tourCard: false },
        { name: "Paolo Nebrida", country: "phi", avg: 90.00, co: 33.0, fav: 20, money: 0, tourCard: false },
        { name: "Patrik Kovacs", country: "hun", avg: 85.00, co: 30.0, fav: 20, money: 0, tourCard: false },
        { name: "Ryusei Azemoto", country: "jpn", avg: 85.00, co: 30.0, fav: 20, money: 0, tourCard: false },
        { name: "Simon Whitlock", country: "aus", avg: 91.00, co: 35.0, fav: 20, money: 0, tourCard: false },
        { name: "Stowe Buntz", country: "usa", avg: 89.00, co: 32.0, fav: 20, money: 0, tourCard: false },
        { name: "Tim Pusey", country: "aus", avg: 86.00, co: 31.0, fav: 20, money: 0, tourCard: false },
        { name: "Matt Campbell", country: "can", avg: 90.34, co: 33.0, fav: 20, money: 0, tourCard: false },
        { name: "Dom Taylor", country: "eng", avg: 94.25, co: 34.0, fav: 20, money: 0, tourCard: false },
        { name: "Darren Beveridge", country: "eng", avg: 90.54, co: 34.0, fav: 20, money: 0, tourCard: false },
        { name: "Florian Hempel", country: "ger", avg: 89.36, co: 34.0, fav: 20, money: 0, tourCard: false },
        { name: "Andreas Harrysson", country: "swe", avg: 90.24, co: 35.0, fav: 20, money: 0, tourCard: false },
        { name: "Steve Lennon", country: "irl", avg: 90.91, co: 34.0, fav: 20, money: 0, tourCard: false },
        { name: "Matthew Dennant", country: "eng", avg: 90.88, co: 34.0, fav: 20, money: 0, tourCard: false },
        { name: "Andy Baetens", country: "bel", avg: 90.99, co: 35.0, fav: 20, money: 0, tourCard: false },
        { name: "Dylan Slevin", country: "irl", avg: 90.47, co: 33.0, fav: 20, money: 0, tourCard: false },
        { name: "Jose de Sousa", country: "por", avg: 88.15, co: 35.0, fav: 20, money: 0, tourCard: false },
        { name: "Boris Krcmar", country: "cro", avg: 89.29, co: 33.0, fav: 20, money: 0, tourCard: false },
        { name: "Fallon Sherrock", country: "eng", avg: 90.00, co: 34.0, fav: 20, money: 0, tourCard: false },
        { name: "Xiaochen Zong", country: "chn", avg: 85.00, co: 30.0, fav: 20, money: 0, tourCard: false },
        { name: "Graham Hall", country: "eng", avg: 89.72, co: 32.0, fav: 20, money: 0, tourCard: false },
        { name: "Danny van Trijp", country: "nl", avg: 89.61, co: 32.0, fav: 20, money: 0, tourCard: false },
        { name: "Kevin Burness", country: "sco", avg: 87.20, co: 31.0, fav: 20, money: 0, tourCard: false },
        { name: "Joe Hunt", country: "eng", avg: 90.97, co: 33.0, fav: 20, money: 0, tourCard: false },
        { name: "Tim Wolters", country: "nl", avg: 82.43, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Michael Unterbuchner", country: "ger", avg: 93.45, co: 37.0, fav: 20, money: 0, tourCard: false },
        { name: "Tommy Lishman", country: "eng", avg: 90.30, co: 33.0, fav: 20, money: 0, tourCard: false },
        { name: "Jack Tweddell", country: "eng", avg: 88.63, co: 32.0, fav: 20, money: 0, tourCard: false },
        { name: "Scott Waites", country: "eng", avg: 88.79, co: 32.0, fav: 20, money: 0, tourCard: false },
        { name: "Johan Engstrom", country: "swe", avg: 88.00, co: 31.0, fav: 20, money: 0, tourCard: false },
        { name: "Jarno Bottenberg", country: "nl", avg: 82.31, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Daniel Klose", country: "ger", avg: 85.00, co: 30.0, fav: 20, money: 0, tourCard: false },
        { name: "Henry Coates", country: "eng", avg: 87.07, co: 31.0, fav: 20, money: 0, tourCard: false },
        { name: "Jules van Dongen", country: "nl", avg: 62.27, co: 15.0, fav: 20, money: 0, tourCard: false },
        { name: "Dragutin Horvat", country: "cro", avg: 89.52, co: 33.0, fav: 20, money: 0, tourCard: false },
        { name: "Aden Kirk", country: "eng", avg: 85.29, co: 30.0, fav: 20, money: 0, tourCard: false },
        { name: "Lee Cocks", country: "eng", avg: 89.16, co: 32.0, fav: 20, money: 0, tourCard: false },
        { name: "Michael Flynn", country: "irl", avg: 89.14, co: 32.0, fav: 20, money: 0, tourCard: false },
        { name: "Nathan Girvan", country: "sco", avg: 90.76, co: 33.0, fav: 20, money: 0, tourCard: false },
        { name: "Scott Campbell", country: "sco", avg: 86.87, co: 31.0, fav: 20, money: 0, tourCard: false },
        { name: "Kevin Troppmann", country: "ger", avg: 82.50, co: 28.0, fav: 20, money: 0, tourCard: false },
        { name: "Martin Kramer", country: "ger", avg: 82.50, co: 28.0, fav: 20, money: 0, tourCard: false },
        { name: "Andras Borbely", country: "hun", avg: 82.50, co: 28.0, fav: 20, money: 0, tourCard: false },
        { name: "Sam Spivey", country: "usa", avg: 88.02, co: 32.0, fav: 20, money: 0, tourCard: false },
        { name: "Francois Schweyen", country: "fra", avg: 82.50, co: 28.0, fav: 20, money: 0, tourCard: false },
        { name: "Kevin Knopf", country: "ger", avg: 82.50, co: 28.0, fav: 20, money: 0, tourCard: false },
        { name: "Petr Krivka", country: "cze", avg: 82.50, co: 28.0, fav: 20, money: 0, tourCard: false },
        { name: "Paul Krohne", country: "ger", avg: 82.50, co: 28.0, fav: 20, money: 0, tourCard: false },
        { name: "Graham Usher", country: "eng", avg: 82.68, co: 28.0, fav: 20, money: 0, tourCard: false },
        { name: "Martin Thomas", country: "eng", avg: 86.93, co: 31.0, fav: 20, money: 0, tourCard: false },
        { name: "Felix Springer", country: "ger", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Tomislav Rosandic", country: "cro", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Andreas Toft Jorgensen", country: "den", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Ansh Sood", country: "ind", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Dalibor Smolik", country: "cze", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Denis Schnetzer", country: "ger", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Rocco Fulciniti", country: "ita", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Andreas Hyllgaardhus", country: "den", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Nandor Major", country: "hun", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Nandor Pres", country: "hun", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Filip Manak", country: "cze", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Jiri Brejcha", country: "cze", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Lukas Unger", country: "ger", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Xanti Van den Bergh", country: "bel", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Liam Maendl-Lawrance", country: "aut", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Miroslaw Grudziecki", country: "pl", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Joshua Hermann", country: "ger", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Moritz Bohrmann", country: "ger", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Jerry Hendriks", country: "nl", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Marcel Erba", country: "ger", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Christian Goedl", country: "aut", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Gyorgy Jehirszki", country: "hun", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Rowby-John Rodriguez", country: "aut", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Zoran Lerchbacher", country: "aut", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Finn Behrens", country: "ger", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Michael Rosenauer", country: "aut", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Rene Eidams", country: "ger", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Patrick Klingelhoefer", country: "ger", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Paul Goyer", country: "can", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Laurin Welk", country: "ger", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Marko Kantele", country: "fin", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Cedric Waegemans", country: "bel", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Patrick De Backer", country: "bel", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Sybren Gijbels", country: "bel", avg: 83.00, co: 29.0, fav: 20, money: 0, tourCard: false },
        { name: "Jenson Walker", country: "eng", avg: 85.37, co: 30.0, fav: 20, money: 0, tourCard: false },
        { name: "Ron Meulenkamp", country: "nl", avg: 87.68, co: 31.0, fav: 20, money: 0, tourCard: false },
        { name: "Paul Rowley", country: "eng", avg: 87.00, co: 31.0, fav: 20, money: 0, tourCard: false },
        { name: "Shaun Fox", country: "eng", avg: 86.00, co: 30.0, fav: 20, money: 0, tourCard: false },
        { name: "Simon Stevenson", country: "eng", avg: 86.00, co: 30.0, fav: 20, money: 0, tourCard: false },
        { name: "Tommy Morris", country: "eng", avg: 86.00, co: 30.0, fav: 20, money: 0, tourCard: false },
        { name: "Ryan Branley", country: "eng", avg: 85.00, co: 30.0, fav: 20, money: 0, tourCard: false },
        { name: "Brooks, Bradley", country: "eng", avg: 93.87, co: 50.27, fav: 20, money: 0, tourCard: false },
        { name: "Long, Jim", country: "can", avg: 93.35, co: 48.65, fav: 16, money: 0, tourCard: false },
        { name: "Kuivenhoven, Maik", country: "eng", avg: 91.27, co: 49.28, fav: 16, money: 0, tourCard: false },
        { name: "Pilgrim, Darryl", country: "eng", avg: 91.12, co: 52.24, fav: 16, money: 0, tourCard: false },
        { name: "Crabtree, Cam", country: "eng", avg: 90.4, co: 49.48, fav: 16, money: 0, tourCard: false },
        { name: "Sedlacek, Karel", country: "cze", avg: 90.38, co: 44.12, fav: 16, money: 0, tourCard: false },
        { name: "Gotthardt, Kai", country: "ger", avg: 90.35, co: 51.67, fav: 20, money: 0, tourCard: false },
        { name: "Boulton, Andy", country: "sco", avg: 90.18, co: 50.46, fav: 16, money: 0, tourCard: false },
        { name: "Tingstrom, Viktor", country: "swe", avg: 89.97, co: 47.59, fav: 16, money: 0, tourCard: false },
        { name: "Hood, Justin", country: "eng", avg: 89.79, co: 46.69, fav: 20, money: 0, tourCard: false },
        { name: "Ritchie, Greg", country: "sco", avg: 88.96, co: 52.64, fav: 16, money: 0, tourCard: false },
        { name: "Van Velzen, Marvin", country: "ned", avg: 88.28, co: 49.52, fav: 20, money: 0, tourCard: false },
        { name: "Paxton, Adam", country: "eng", avg: 87.67, co: 48.13, fav: 16, money: 0, tourCard: false },
        { name: "Rodriguez, Rusty-Jake", country: "aut", avg: 87.55, co: 47.9, fav: 20, money: 0, tourCard: false },
        { name: "Bissell, Tom", country: "eng", avg: 87.44, co: 53.25, fav: 20, money: 0, tourCard: false },
        { name: "Gruellich, Dominik", country: "ger", avg: 87.23, co: 47.01, fav: 16, money: 0, tourCard: false },
        { name: "Lovely, Thomas", country: "eng", avg: 86.62, co: 51.32, fav: 16, money: 0, tourCard: false },
        { name: "Henderyck, Stefaan", country: "bel", avg: 86.33, co: 50.24, fav: 16, money: 0, tourCard: false },
        { name: "Kanik, Tytus", country: "pol", avg: 85.91, co: 46.03, fav: 16, money: 0, tourCard: false },
        { name: "Lipscombe, Adam", country: "eng", avg: 85.71, co: 49.66, fav: 20, money: 0, tourCard: false },
        { name: "Dekker, Cor", country: "nor", avg: 85.52, co: 47.63, fav: 20, money: 0, tourCard: false },
        { name: "Dudeney, Tavis", country: "eng", avg: 85.43, co: 56.9, fav: 16, money: 0, tourCard: false },
        { name: "Olde Kalter, Dennie", country: "ned", avg: 85.17, co: 44.85, fav: 16, money: 0, tourCard: false },
        { name: "Weber, Leon", country: "ger", avg: 84.34, co: 45.61, fav: 16, money: 0, tourCard: false },
        { name: "Lukasiak, Oskar", country: "swe", avg: 84.29, co: 48.61, fav: 20, money: 0, tourCard: false },
        { name: "Warner, Adam", country: "eng", avg: 84.0, co: 47.14, fav: 16, money: 0, tourCard: false },
        { name: "Hopp, Max", country: "ger", avg: 83.92, co: 39.29, fav: 20, money: 0, tourCard: false },
        { name: "Ljubic, Pero", country: "cro", avg: 83.92, co: 50.51, fav: 20, money: 0, tourCard: false },
        { name: "Czerwinski, Maximilian", country: "ger", avg: 83.07, co: 50.94, fav: 16, money: 0, tourCard: false },
        { name: "Rowley, Paul", country: "eng", avg: 93.33, co: 50.33, fav: 20, money: 0, tourCard: false },
        { name: "King, Mervyn", country: "eng", avg: 92.42, co: 50.45, fav: 16, money: 0, tourCard: false },
        { name: "Greaves, Beau", country: "eng", avg: 91.78, co: 51.58, fav: 16, money: 0, tourCard: false },
        { name: "O'Shea, John", country: "irl", avg: 91.48, co: 49.84, fav: 16, money: 0, tourCard: false },
        { name: "De Zwaan, Jeffrey", country: "ned", avg: 90.52, co: 56.45, fav: 16, money: 0, tourCard: false },
        { name: "Sharp, David", country: "sco", avg: 90.32, co: 43.67, fav: 20, money: 0, tourCard: false },
        { name: "Waites, Scott", country: "eng", avg: 90.0, co: 59.89, fav: 20, money: 0, tourCard: false },
        { name: "Morris, Tommy", country: "eng", avg: 89.97, co: 48.49, fav: 20, money: 0, tourCard: false },
        { name: "McGuirk, Shane", country: "irl", avg: 89.87, co: 45.66, fav: 20, money: 0, tourCard: false },
        { name: "Smith-Neale, Adam", country: "eng", avg: 89.87, co: 46.31, fav: 20, money: 0, tourCard: false },
        { name: "Bellmont, Stefan", country: "sui", avg: 89.72, co: 57.35, fav: 20, money: 0, tourCard: false },
        { name: "Carroll, Shaun", country: "eng", avg: 89.72, co: 44.33, fav: 20, money: 0, tourCard: false },
        { name: "Hall, Graham", country: "eng", avg: 89.6, co: 59.84, fav: 16, money: 0, tourCard: false },
        { name: "Monk, Arron", country: "eng", avg: 89.09, co: 41.0, fav: 20, money: 0, tourCard: false },
        { name: "Evans, Lee", country: "eng", avg: 88.69, co: 55.5, fav: 20, money: 0, tourCard: false },
        { name: "Evetts, Ted", country: "eng", avg: 88.6, co: 50.02, fav: 16, money: 0, tourCard: false },
        { name: "Krcmar, Boris", country: "cro", avg: 88.5, co: 57.17, fav: 20, money: 0, tourCard: false },
        { name: "Tweddell, Jack", country: "eng", avg: 88.4, co: 48.67, fav: 20, money: 0, tourCard: false },
        { name: "Sykes, Tom", country: "eng", avg: 88.37, co: 50.77, fav: 16, money: 0, tourCard: false },
        { name: "Hamilton, Andy", country: "eng", avg: 88.33, co: 59.63, fav: 16, money: 0, tourCard: false },
        { name: "Cole, Jarred", country: "eng", avg: 88.27, co: 48.35, fav: 20, money: 0, tourCard: false },
        { name: "Grearson, Martin", country: "eng", avg: 88.11, co: 47.18, fav: 20, money: 0, tourCard: false },
        { name: "Atkins, Jamie", country: "eng", avg: 88.1, co: 48.18, fav: 16, money: 0, tourCard: false },
        { name: "Warburton, Mike", country: "wal", avg: 87.93, co: 55.82, fav: 20, money: 0, tourCard: false },
        { name: "Van Der Meijden, Gilbert", country: "ned", avg: 87.69, co: 45.09, fav: 16, money: 0, tourCard: false },
        { name: "Wickenden, Christopher", country: "eng", avg: 87.68, co: 47.38, fav: 20, money: 0, tourCard: false },
        { name: "Ulrich, Ricardo", country: "eng", avg: 87.6, co: 44.81, fav: 16, money: 0, tourCard: false },
        { name: "Hughes, Jamie", country: "eng", avg: 87.24, co: 55.91, fav: 16, money: 0, tourCard: false },
        { name: "Henderson, John", country: "sco", avg: 87.19, co: 46.41, fav: 16, money: 0, tourCard: false },
        { name: "Mol, Damian", country: "eng", avg: 87.17, co: 44.52, fav: 16, money: 0, tourCard: false },
        { name: "Barstow, Chas", country: "eng", avg: 87.15, co: 42.48, fav: 20, money: 0, tourCard: false },
        { name: "Van Schie, Jimmy", country: "ned", avg: 87.11, co: 49.75, fav: 20, money: 0, tourCard: false },
        { name: "Walker, Jenson", country: "eng", avg: 87.03, co: 41.65, fav: 20, money: 0, tourCard: false },
        { name: "Lonsdale, Tom", country: "eng", avg: 87.01, co: 54.86, fav: 16, money: 0, tourCard: false },
        { name: "Sneyd, Carl", country: "eng", avg: 86.97, co: 45.38, fav: 16, money: 0, tourCard: false },
        { name: "Hine, Steve", country: "eng", avg: 86.96, co: 56.24, fav: 20, money: 0, tourCard: false },
        { name: "Davies, David", country: "wal", avg: 86.88, co: 43.13, fav: 20, money: 0, tourCard: false },
        { name: "McGeeney, Mark", country: "eng", avg: 86.75, co: 50.67, fav: 20, money: 0, tourCard: false },
        { name: "Weening, Brandon", country: "aus", avg: 86.67, co: 58.7, fav: 16, money: 0, tourCard: false },
        { name: "Perez, Christian", country: "phi", avg: 86.66, co: 49.05, fav: 20, money: 0, tourCard: false },
        { name: "Jansen, Danny", country: "cze", avg: 86.61, co: 53.69, fav: 16, money: 0, tourCard: false },
        { name: "Banks, Thomas", country: "eng", avg: 86.6, co: 48.32, fav: 20, money: 0, tourCard: false },
        { name: "Labanauskas, Darius", country: "ltu", avg: 86.58, co: 53.15, fav: 20, money: 0, tourCard: false },
        { name: "Branley, Ryan", country: "eng", avg: 86.57, co: 48.83, fav: 20, money: 0, tourCard: false },
        { name: "Klose, Daniel", country: "ger", avg: 86.5, co: 44.2, fav: 16, money: 0, tourCard: false },
        { name: "McEwan, Jim", country: "sco", avg: 86.47, co: 46.94, fav: 16, money: 0, tourCard: false },
        { name: "Merkx, Alexander", country: "eng", avg: 86.4, co: 46.1, fav: 20, money: 0, tourCard: false },
        { name: "Williams, Alex", country: "wal", avg: 86.39, co: 51.65, fav: 20, money: 0, tourCard: false },
        { name: "O'Connor, Ryan", country: "eng", avg: 86.36, co: 45.32, fav: 16, money: 0, tourCard: false },
        { name: "Sherrock, Fallon", country: "eng", avg: 86.3, co: 45.72, fav: 20, money: 0, tourCard: false },
        { name: "Bogaert, Luc", country: "bel", avg: 86.24, co: 45.81, fav: 16, money: 0, tourCard: false },
        { name: "Halsall, Ieuan", country: "wal", avg: 86.24, co: 44.92, fav: 16, money: 0, tourCard: false },
        { name: "Van Den Herik, Jamai", country: "ned", avg: 86.23, co: 43.66, fav: 20, money: 0, tourCard: false },
        { name: "Harrysson, Andreas", country: "swe", avg: 86.15, co: 48.77, fav: 16, money: 0, tourCard: false },
        { name: "Leadenham, Kevin", country: "eng", avg: 86.04, co: 42.22, fav: 16, money: 0, tourCard: false },
        { name: "Leung, Kai Fan", country: "hkg", avg: 85.88, co: 50.72, fav: 20, money: 0, tourCard: false },
        { name: "Van Der Velde, Jurjen", country: "ned", avg: 85.84, co: 39.6, fav: 20, money: 0, tourCard: false },
        { name: "Parry, Kurt", country: "wal", avg: 85.8, co: 52.05, fav: 16, money: 0, tourCard: false },
        { name: "Ayres, Daniel", country: "eng", avg: 85.78, co: 45.19, fav: 20, money: 0, tourCard: false },
        { name: "Wilson, Carl", country: "eng", avg: 85.77, co: 53.66, fav: 20, money: 0, tourCard: false },
        { name: "Cameron, David", country: "can", avg: 85.67, co: 45.73, fav: 20, money: 0, tourCard: false },
        { name: "Martin, Charlie", country: "eng", avg: 85.66, co: 55.51, fav: 16, money: 0, tourCard: false },
        { name: "Burgoyne, Peter", country: "eng", avg: 85.62, co: 42.71, fav: 20, money: 0, tourCard: false },
        { name: "Payne, Josh", country: "eng", avg: 85.57, co: 50.63, fav: 20, money: 0, tourCard: false },
        { name: "Beeton, James", country: "eng", avg: 85.53, co: 43.02, fav: 20, money: 0, tourCard: false },
        { name: "Proosten, Davy", country: "eng", avg: 85.48, co: 51.25, fav: 20, money: 0, tourCard: false },
        { name: "Lishman, Tommy", country: "eng", avg: 85.43, co: 50.0, fav: 16, money: 0, tourCard: false },
        { name: "Campbell, Scott", country: "sco", avg: 85.37, co: 47.73, fav: 20, money: 0, tourCard: false },
        { name: "Turner, Shane", country: "eng", avg: 85.29, co: 47.0, fav: 20, money: 0, tourCard: false },
        { name: "Trueman, Danny", country: "sco", avg: 85.26, co: 53.06, fav: 16, money: 0, tourCard: false },
        { name: "Finn Forde, Dean", country: "irl", avg: 85.24, co: 51.31, fav: 20, money: 0, tourCard: false },
        { name: "Fagg, Jeremy", country: "aus", avg: 85.15, co: 45.33, fav: 16, money: 0, tourCard: false },
        { name: "Frauenfelder, Levy", country: "eng", avg: 85.12, co: 49.92, fav: 16, money: 0, tourCard: false },
        { name: "Linwood, Paul", country: "wal", avg: 85.09, co: 42.1, fav: 20, money: 0, tourCard: false },
        { name: "Moston, Jim", country: "eng", avg: 84.96, co: 45.6, fav: 16, money: 0, tourCard: false },
        { name: "Wares, Stuart", country: "sco", avg: 84.96, co: 36.87, fav: 20, money: 0, tourCard: false },
        { name: "Kirk, Aden", country: "eng", avg: 84.86, co: 50.25, fav: 20, money: 0, tourCard: false },
        { name: "Coates, Henry", country: "eng", avg: 84.85, co: 57.2, fav: 16, money: 0, tourCard: false },
        { name: "Thomas, Keenan", country: "wal", avg: 84.72, co: 45.93, fav: 16, money: 0, tourCard: false },
        { name: "Petersen, Devon", country: "rsa", avg: 84.69, co: 38.89, fav: 16, money: 0, tourCard: false },
        { name: "Williams, Lee", country: "wal", avg: 84.64, co: 43.2, fav: 16, money: 0, tourCard: false },
        { name: "Hunt, Joe", country: "eng", avg: 84.61, co: 49.91, fav: 20, money: 0, tourCard: false },
        { name: "Rodriguez, Rowby-John", country: "aut", avg: 84.61, co: 53.2, fav: 16, money: 0, tourCard: false },
        { name: "Astbury, Daniel", country: "eng", avg: 84.53, co: 56.52, fav: 20, money: 0, tourCard: false },
        { name: "Roetzsch, Franz", country: "ger", avg: 84.52, co: 55.49, fav: 20, money: 0, tourCard: false },
        { name: "Van Trijp, Danny", country: "ned", avg: 84.52, co: 52.41, fav: 20, money: 0, tourCard: false },
        { name: "Hughes, James Howard", country: "eng", avg: 84.48, co: 40.71, fav: 16, money: 0, tourCard: false },
        { name: "Owens, Jamie", country: "eng", avg: 84.48, co: 47.54, fav: 20, money: 0, tourCard: false },
        { name: "Mitchell, Scott", country: "eng", avg: 84.47, co: 49.45, fav: 20, money: 0, tourCard: false },
        { name: "Norris, Alan", country: "eng", avg: 84.47, co: 45.84, fav: 20, money: 0, tourCard: false },
        { name: "Pratnemer, Benjamin", country: "svn", avg: 84.47, co: 45.58, fav: 20, money: 0, tourCard: false },
        { name: "Greaves, Taylor", country: "eng", avg: 84.44, co: 42.46, fav: 20, money: 0, tourCard: false },
        { name: "Potter, Nathan", country: "eng", avg: 84.43, co: 48.94, fav: 16, money: 0, tourCard: false },
        { name: "Rosandic, Tomislav", country: "cro", avg: 84.28, co: 44.23, fav: 16, money: 0, tourCard: false },
        { name: "Tringler, Patrick", country: "aut", avg: 84.25, co: 49.95, fav: 16, money: 0, tourCard: false },
        { name: "Whitlock, Simon", country: "aus", avg: 84.22, co: 47.85, fav: 20, money: 0, tourCard: false },
        { name: "Robbe, Mario", country: "eng", avg: 84.21, co: 44.63, fav: 16, money: 0, tourCard: false },
        { name: "Beck, Adam", country: "eng", avg: 84.15, co: 42.4, fav: 20, money: 0, tourCard: false },
        { name: "Walters, Scott", country: "eng", avg: 84.08, co: 50.31, fav: 16, money: 0, tourCard: false },
        { name: "Whitlock, Mason", country: "aus", avg: 84.06, co: 49.0, fav: 16, money: 0, tourCard: false },
        { name: "Fisher, Sean", country: "wal", avg: 84.03, co: 52.07, fav: 20, money: 0, tourCard: false },
        { name: "Goffin, Callum", country: "wal", avg: 84.01, co: 50.63, fav: 16, money: 0, tourCard: false },
        { name: "Pride, Lewis", country: "eng", avg: 83.99, co: 43.73, fav: 16, money: 0, tourCard: false },
        { name: "Cass, Andrew", country: "eng", avg: 83.97, co: 50.29, fav: 20, money: 0, tourCard: false },
        { name: "Burkhill, Trevor", country: "gbr", avg: 83.95, co: 46.09, fav: 16, money: 0, tourCard: false },
        { name: "Culleton, Niall", country: "irl", avg: 83.94, co: 50.68, fav: 16, money: 0, tourCard: false },
        { name: "Ostlund, Anton", country: "swe", avg: 83.91, co: 44.67, fav: 20, money: 0, tourCard: false },
        { name: "Klingelhoefer, Patrick", country: "ger", avg: 83.79, co: 47.94, fav: 20, money: 0, tourCard: false },
        { name: "Colley, Reece", country: "eng", avg: 83.72, co: 52.06, fav: 20, money: 0, tourCard: false },
        { name: "Osborne, Colin", country: "eng", avg: 83.67, co: 50.32, fav: 20, money: 0, tourCard: false },
        { name: "Heneghan, Conor", country: "irl", avg: 83.66, co: 53.26, fav: 20, money: 0, tourCard: false },
        { name: "Walpen, Marcel", country: "sui", avg: 83.66, co: 43.99, fav: 20, money: 0, tourCard: false },
        { name: "Worsley, Jon", country: "wal", avg: 83.56, co: 50.05, fav: 16, money: 0, tourCard: false },
        { name: "Ellis, Nicholas", country: "eng", avg: 83.55, co: 43.44, fav: 20, money: 0, tourCard: false },
        { name: "Smolik, Dalibor", country: "cze", avg: 83.55, co: 52.13, fav: 20, money: 0, tourCard: false },
        { name: "Perry, Daniel", country: "eng", avg: 83.52, co: 43.18, fav: 16, money: 0, tourCard: false },
        { name: "Ehlers, Matthias", country: "ger", avg: 83.48, co: 49.7, fav: 16, money: 0, tourCard: false },
        { name: "Pallett, David", country: "eng", avg: 83.48, co: 48.78, fav: 16, money: 0, tourCard: false },
        { name: "Heaver, Jason", country: "eng", avg: 83.45, co: 48.38, fav: 20, money: 0, tourCard: false },
        { name: "Manby, Charlie", country: "eng", avg: 83.44, co: 50.13, fav: 16, money: 0, tourCard: false },
        { name: "Baker, Scott", country: "eng", avg: 83.43, co: 40.5, fav: 20, money: 0, tourCard: false },
        { name: "Bristow, Jimmy", country: "eng", avg: 83.33, co: 46.41, fav: 20, money: 0, tourCard: false },
        { name: "Gwynne, Jacob", country: "eng", avg: 83.3, co: 51.92, fav: 16, money: 0, tourCard: false },
        { name: "Dudbridge, Mark", country: "eng", avg: 83.26, co: 51.44, fav: 20, money: 0, tourCard: false },
        { name: "O'Neill, Keith", country: "sco", avg: 83.26, co: 49.82, fav: 16, money: 0, tourCard: false },
        { name: "Telnekes, Derk", country: "eng", avg: 83.25, co: 52.92, fav: 20, money: 0, tourCard: false },
        { name: "Flynn, Michael", country: "irl", avg: 83.23, co: 41.52, fav: 20, money: 0, tourCard: false },
        { name: "Unterbuchner, Michael", country: "ger", avg: 83.21, co: 47.9, fav: 20, money: 0, tourCard: false },
        { name: "Smejda, Michal", country: "cze", avg: 83.18, co: 50.35, fav: 16, money: 0, tourCard: false },
        { name: "Justicia, Jose", country: "esp", avg: 83.16, co: 42.23, fav: 20, money: 0, tourCard: false },
        { name: "Burness, Kevin", country: "nir", avg: 83.14, co: 52.76, fav: 20, money: 0, tourCard: false },
        { name: "Burnett, Richie", country: "wal", avg: 83.05, co: 54.81, fav: 20, money: 0, tourCard: false },
        { name: "Williams, Patrik", country: "eng", avg: 83.05, co: 47.86, fav: 20, money: 0, tourCard: false },
        { name: "Thornton, Robert", country: "sco", avg: 82.96, co: 41.4, fav: 16, money: 0, tourCard: false },
        { name: "Lane, Kevin", country: "wal", avg: 82.95, co: 45.64, fav: 16, money: 0, tourCard: false },
        { name: "Kantele, Marko", country: "fin", avg: 82.92, co: 46.73, fav: 20, money: 0, tourCard: false },
        { name: "Maclean, Derek", country: "sco", avg: 82.92, co: 48.61, fav: 20, money: 0, tourCard: false },
        { name: "Van Klompenburg, Danny", country: "ned", avg: 82.92, co: 43.13, fav: 16, money: 0, tourCard: false },
        { name: "Meulenkamp, Ron", country: "eng", avg: 82.87, co: 48.85, fav: 16, money: 0, tourCard: false },
        { name: "Dowling, Dylan", country: "irl", avg: 82.85, co: 38.59, fav: 20, money: 0, tourCard: false },
        { name: "Budgen, Lee", country: "eng", avg: 82.83, co: 51.91, fav: 20, money: 0, tourCard: false },
        { name: "Kciuk, Krzysztof", country: "pol", avg: 82.8, co: 44.2, fav: 20, money: 0, tourCard: false },
        { name: "Balsamo, Angelo", country: "ita", avg: 82.73, co: 53.04, fav: 16, money: 0, tourCard: false },
        { name: "Bremermann, Jannes", country: "ger", avg: 82.71, co: 45.44, fav: 16, money: 0, tourCard: false },
        { name: "Lever, Ian", country: "eng", avg: 82.64, co: 41.0, fav: 16, money: 0, tourCard: false },
        { name: "Roelofs, Owen", country: "eng", avg: 82.58, co: 42.58, fav: 16, money: 0, tourCard: false },
        { name: "Wynn, Jonathan", country: "eng", avg: 82.58, co: 48.23, fav: 20, money: 0, tourCard: false },
        { name: "Croft, Joe", country: "eng", avg: 82.53, co: 45.8, fav: 20, money: 0, tourCard: false },
        { name: "O'Keefe, Kelvin", country: "wal", avg: 82.5, co: 42.94, fav: 20, money: 0, tourCard: false },
        { name: "Usher, Graham", country: "eng", avg: 82.5, co: 41.23, fav: 16, money: 0, tourCard: false },
        { name: "Gawlas, Adam", country: "cze", avg: 82.34, co: 52.0, fav: 20, money: 0, tourCard: false },
        { name: "Maiden, Owen", country: "eng", avg: 82.34, co: 46.17, fav: 20, money: 0, tourCard: false },
        { name: "Ansell, Frankie", country: "eng", avg: 82.26, co: 48.64, fav: 16, money: 0, tourCard: false },
        { name: "Hohnstedt, Kilian", country: "ger", avg: 82.22, co: 43.95, fav: 16, money: 0, tourCard: false },
        { name: "Nicholls, Daniel", country: "eng", avg: 82.22, co: 59.81, fav: 20, money: 0, tourCard: false },
        { name: "Haggerty, Steve", country: "eng", avg: 82.18, co: 41.9, fav: 16, money: 0, tourCard: false },
        { name: "Wirotius, Pascal", country: "ger", avg: 82.18, co: 46.0, fav: 16, money: 0, tourCard: false },
        { name: "Bauerdick, Daniel", country: "ger", avg: 82.17, co: 51.8, fav: 16, money: 0, tourCard: false },
        { name: "Huntley, Michael", country: "wal", avg: 82.15, co: 42.38, fav: 16, money: 0, tourCard: false },
        { name: "Palmer, Ryan", country: "eng", avg: 82.15, co: 47.49, fav: 16, money: 0, tourCard: false },
        { name: "Care, Nathan", country: "eng", avg: 82.09, co: 43.58, fav: 16, money: 0, tourCard: false },
        { name: "Brown, John", country: "eng", avg: 82.07, co: 49.1, fav: 16, money: 0, tourCard: false },
        { name: "Coward, Phil", country: "eng", avg: 82.07, co: 51.6, fav: 20, money: 0, tourCard: false },
        { name: "Higgins, Paul", country: "wal", avg: 82.01, co: 45.93, fav: 16, money: 0, tourCard: false },
        { name: "Noster, Steven", country: "ger", avg: 81.95, co: 53.86, fav: 16, money: 0, tourCard: false },
        { name: "Cromwell, Thomas", country: "eng", avg: 81.92, co: 43.6, fav: 16, money: 0, tourCard: false },
        { name: "Smith, Luke", country: "eng", avg: 81.88, co: 34.42, fav: 16, money: 0, tourCard: false },
        { name: "Mould, Adam", country: "eng", avg: 81.86, co: 50.57, fav: 16, money: 0, tourCard: false },
        { name: "Thuillier, Nicolas", country: "fra", avg: 81.86, co: 47.95, fav: 20, money: 0, tourCard: false },
        { name: "Challenger, Mark", country: "wal", avg: 81.85, co: 48.68, fav: 16, money: 0, tourCard: false },
        { name: "Troppmann, Kevin", country: "ger", avg: 81.85, co: 52.33, fav: 16, money: 0, tourCard: false },
        { name: "Brouwers, Rohan", country: "eng", avg: 81.81, co: 51.93, fav: 20, money: 0, tourCard: false },
        { name: "Wilson, Jason", country: "eng", avg: 81.78, co: 55.86, fav: 16, money: 0, tourCard: false },
        { name: "Whitehead, Conan", country: "eng", avg: 81.77, co: 44.81, fav: 20, money: 0, tourCard: false },
        { name: "Vetjens, Damian", country: "eng", avg: 81.75, co: 45.44, fav: 16, money: 0, tourCard: false },
        { name: "Mitchell, Oliver", country: "eng", avg: 81.7, co: 50.02, fav: 16, money: 0, tourCard: false },
        { name: "Manton, Kyle", country: "eng", avg: 81.67, co: 34.1, fav: 16, money: 0, tourCard: false },
        { name: "Thomas, Sion", country: "wal", avg: 81.6, co: 56.0, fav: 16, money: 0, tourCard: false },
        { name: "Richardson, James", country: "eng", avg: 81.54, co: 58.17, fav: 20, money: 0, tourCard: false },
        { name: "Furness, Ryan", country: "eng", avg: 81.49, co: 48.66, fav: 16, money: 0, tourCard: false },
        { name: "Girvan, Nathan", country: "sco", avg: 81.43, co: 47.52, fav: 20, money: 0, tourCard: false },
        { name: "Grudziecki, Miroslaw", country: "pol", avg: 81.39, co: 36.63, fav: 16, money: 0, tourCard: false },
        { name: "McKeon, Sean", country: "irl", avg: 81.37, co: 51.13, fav: 16, money: 0, tourCard: false },
        { name: "Preis, Florian", country: "ger", avg: 81.37, co: 45.25, fav: 16, money: 0, tourCard: false },
        { name: "Armstrong, Darren", country: "sco", avg: 81.32, co: 64.78, fav: 16, money: 0, tourCard: false },
        { name: "Mioch, Jeroen", country: "eng", avg: 81.3, co: 52.22, fav: 20, money: 0, tourCard: false },
        { name: "Brown, Keegan", country: "eng", avg: 81.28, co: 42.64, fav: 20, money: 0, tourCard: false },
        { name: "Beeney, Aaron", country: "eng", avg: 81.26, co: 42.14, fav: 16, money: 0, tourCard: false },
        { name: "Gallagher, Dean", country: "irl", avg: 81.23, co: 45.27, fav: 16, money: 0, tourCard: false },
        { name: "Gibson, Colin", country: "sco", avg: 81.22, co: 47.55, fav: 20, money: 0, tourCard: false },
        { name: "Otter, Marcel", country: "eng", avg: 81.13, co: 46.99, fav: 20, money: 0, tourCard: false },
        { name: "Labre, Jacques", country: "fra", avg: 81.12, co: 45.39, fav: 20, money: 0, tourCard: false },
        { name: "McDine, Kevin", country: "eng", avg: 81.09, co: 43.33, fav: 20, money: 0, tourCard: false },
        { name: "Thomas, Martin", country: "wal", avg: 81.05, co: 48.0, fav: 16, money: 0, tourCard: false },
        { name: "Jehirszki, Gyorgy", country: "hun", avg: 81.04, co: 44.4, fav: 20, money: 0, tourCard: false },
        { name: "Althaus, Marcel", country: "ger", avg: 81.0, co: 48.45, fav: 20, money: 0, tourCard: false },
        { name: "Schmidt, Jan", country: "ger", avg: 80.9, co: 70.0, fav: 20, money: 0, tourCard: false },
        { name: "Van Den Bergh, Xanti", country: "bel", avg: 80.88, co: 46.12, fav: 20, money: 0, tourCard: false },
        { name: "Busscher, Michael", country: "ger", avg: 80.81, co: 51.41, fav: 16, money: 0, tourCard: false },
        { name: "Gray, Adrian", country: "eng", avg: 80.81, co: 44.62, fav: 20, money: 0, tourCard: false },
        { name: "Mueller (Ffo), Oliver", country: "ger", avg: 80.79, co: 43.24, fav: 20, money: 0, tourCard: false },
        { name: "Barnes, Jonny", country: "eng", avg: 80.77, co: 46.72, fav: 20, money: 0, tourCard: false },
        { name: "Williams, David", country: "eng", avg: 80.76, co: 57.27, fav: 16, money: 0, tourCard: false },
        { name: "Goodger, Ben", country: "gbr", avg: 80.72, co: 46.07, fav: 16, money: 0, tourCard: false },
        { name: "Fidler, Chris", country: "eng", avg: 80.7, co: 36.0, fav: 16, money: 0, tourCard: false },
        { name: "Robb, Ben", country: "nzl", avg: 80.64, co: 34.47, fav: 20, money: 0, tourCard: false },
        { name: "Harrington, Ryan", country: "eng", avg: 80.61, co: 40.67, fav: 16, money: 0, tourCard: false },
        { name: "Davies, Rhys Peris", country: "wal", avg: 80.57, co: 46.68, fav: 16, money: 0, tourCard: false },
        { name: "Bell, Lewis", country: "gbr", avg: 80.53, co: 56.38, fav: 16, money: 0, tourCard: false },
        { name: "Gerdon, Marcel", country: "ger", avg: 80.52, co: 20.0, fav: 16, money: 0, tourCard: false },
        { name: "Hands, Dan", country: "eng", avg: 80.51, co: 54.68, fav: 20, money: 0, tourCard: false },
        { name: "Szekely, Pal", country: "hun", avg: 80.49, co: 57.5, fav: 20, money: 0, tourCard: false },
        { name: "Eidams, Rene", country: "ger", avg: 80.47, co: 30.79, fav: 16, money: 0, tourCard: false },
        { name: "Prior, Nigel", country: "eng", avg: 80.38, co: 46.98, fav: 16, money: 0, tourCard: false },
        { name: "Lankhuizen, Kevin", country: "bel", avg: 80.37, co: 43.05, fav: 16, money: 0, tourCard: false },
        { name: "Vermeer, Gerrit", country: "eng", avg: 80.35, co: 41.48, fav: 16, money: 0, tourCard: false },
        { name: "Knops, Robbie", country: "bel", avg: 80.34, co: 53.48, fav: 20, money: 0, tourCard: false },
        { name: "Merk, Arno", country: "ger", avg: 80.28, co: 40.93, fav: 16, money: 0, tourCard: false },
        { name: "Grbavac, Romeo", country: "cro", avg: 80.22, co: 44.74, fav: 20, money: 0, tourCard: false },
        { name: "Ramnath, Vinay", country: "eng", avg: 80.19, co: 45.0, fav: 20, money: 0, tourCard: false },
        { name: "Racoveanu, Daniel", country: "rou", avg: 80.14, co: 47.15, fav: 16, money: 0, tourCard: false },
        { name: "Gurney, Lewis", country: "eng", avg: 80.13, co: 39.36, fav: 20, money: 0, tourCard: false },
        { name: "West, Steve", country: "eng", avg: 80.06, co: 37.57, fav: 20, money: 0, tourCard: false },
        { name: "Gallett, Matt", country: "eng", avg: 80.02, co: 50.5, fav: 20, money: 0, tourCard: false },
        { name: "Richardson, Brandon Lewis", country: "eng", avg: 79.97, co: 42.07, fav: 20, money: 0, tourCard: false },
        { name: "Walker, Jim", country: "sco", avg: 79.96, co: 45.57, fav: 16, money: 0, tourCard: false },
        { name: "Caron, Jeroen", country: "bel", avg: 79.95, co: 47.23, fav: 20, money: 0, tourCard: false },
        { name: "Sedlak, Vitezslav", country: "cze", avg: 79.87, co: 47.72, fav: 20, money: 0, tourCard: false },
        { name: "Neyens, Kenny", country: "bel", avg: 79.81, co: 41.17, fav: 20, money: 0, tourCard: false },
        { name: "Avory, Myles", country: "eng", avg: 79.79, co: 48.92, fav: 16, money: 0, tourCard: false },
        { name: "Scurfield, Pat", country: "eng", avg: 79.76, co: 37.08, fav: 20, money: 0, tourCard: false },
        { name: "Rawlings, Jordan-Lee", country: "eng", avg: 79.74, co: 49.61, fav: 20, money: 0, tourCard: false },
        { name: "Smees, Robin", country: "eng", avg: 79.69, co: 43.52, fav: 16, money: 0, tourCard: false },
        { name: "Vincent, Jack", country: "eng", avg: 79.68, co: 37.8, fav: 16, money: 0, tourCard: false },
        { name: "Scholz, Tim", country: "ger", avg: 79.62, co: 40.22, fav: 16, money: 0, tourCard: false },
        { name: "Lovely, Eddie", country: "eng", avg: 79.6, co: 50.2, fav: 20, money: 0, tourCard: false },
        { name: "Price, Samuel", country: "eng", avg: 79.58, co: 48.29, fav: 16, money: 0, tourCard: false },
        { name: "Palmer, Ricky", country: "gbr", avg: 79.57, co: 46.07, fav: 16, money: 0, tourCard: false },
        { name: "Parkin, James", country: "eng", avg: 79.57, co: 50.44, fav: 20, money: 0, tourCard: false },
        { name: "Barrow, Lee", country: "eng", avg: 79.54, co: 47.47, fav: 16, money: 0, tourCard: false },
        { name: "Van Leuven, Noa-Lynn", country: "ned", avg: 79.52, co: 43.63, fav: 16, money: 0, tourCard: false },
        { name: "Major, Nandor", country: "hun", avg: 79.35, co: 44.15, fav: 20, money: 0, tourCard: false },
        { name: "Williams, Karl", country: "eng", avg: 79.35, co: 49.56, fav: 16, money: 0, tourCard: false },
        { name: "Durrant, Jamie", country: "eng", avg: 79.31, co: 46.68, fav: 16, money: 0, tourCard: false },
        { name: "Stoeckli, Bruno", country: "sui", avg: 79.31, co: 46.21, fav: 16, money: 0, tourCard: false },
        { name: "Blum, Nico", country: "ger", avg: 79.3, co: 43.44, fav: 16, money: 0, tourCard: false },
        { name: "Bruns, Frank", country: "ger", avg: 79.26, co: 43.9, fav: 16, money: 0, tourCard: false },
        { name: "Lowe, Kevin", country: "eng", avg: 79.2, co: 38.19, fav: 16, money: 0, tourCard: false },
        { name: "Male, Jack", country: "eng", avg: 79.15, co: 42.86, fav: 20, money: 0, tourCard: false },
        { name: "Moore, Martyn", country: "eng", avg: 79.12, co: 46.0, fav: 16, money: 0, tourCard: false },
        { name: "Blades, Gary", country: "eng", avg: 79.09, co: 40.7, fav: 20, money: 0, tourCard: false },
        { name: "Sparidaans, Jeffrey", country: "eng", avg: 79.08, co: 46.47, fav: 16, money: 0, tourCard: false },
        { name: "Kay, Keelan", country: "eng", avg: 79.06, co: 46.17, fav: 20, money: 0, tourCard: false },
        { name: "Kohnlein, Thomas", country: "ger", avg: 79.06, co: 48.0, fav: 16, money: 0, tourCard: false },
        { name: "Kraft, Marvin", country: "ger", avg: 79.03, co: 19.71, fav: 20, money: 0, tourCard: false },
        { name: "Mitchell, Paul", country: "gbr", avg: 79.03, co: 44.8, fav: 16, money: 0, tourCard: false },
        { name: "Cavajda, Dominik", country: "cze", avg: 79.02, co: 40.64, fav: 20, money: 0, tourCard: false },
        { name: "Shire, Jack", country: "eng", avg: 79.02, co: 39.14, fav: 20, money: 0, tourCard: false },
        { name: "Raman, Brian", country: "bel", avg: 79.0, co: 48.86, fav: 16, money: 0, tourCard: false },
        { name: "Krivka, Petr", country: "cze", avg: 78.94, co: 52.93, fav: 16, money: 0, tourCard: false },
        { name: "Garcia Del Pozo, Jorge", country: "esp", avg: 78.93, co: 46.52, fav: 20, money: 0, tourCard: false },
        { name: "Marcone, Francesco", country: "ita", avg: 78.93, co: 39.74, fav: 20, money: 0, tourCard: false },
        { name: "Robbie, Hayden", country: "eng", avg: 78.84, co: 44.94, fav: 16, money: 0, tourCard: false },
        { name: "Roberts, Deian", country: "wal", avg: 78.84, co: 31.0, fav: 20, money: 0, tourCard: false },
        { name: "Hilger, Moritz", country: "ger", avg: 78.83, co: 47.95, fav: 16, money: 0, tourCard: false },
        { name: "De Jong, Max", country: "ned", avg: 78.8, co: 31.67, fav: 20, money: 0, tourCard: false },
        { name: "Blankley, Ashley", country: "gbr", avg: 78.76, co: 30.0, fav: 20, money: 0, tourCard: false },
        { name: "Sumner, David", country: "eng", avg: 78.74, co: 45.43, fav: 20, money: 0, tourCard: false },
        { name: "Hofkens, Yorick", country: "ger", avg: 78.73, co: 43.57, fav: 20, money: 0, tourCard: false },
        { name: "Baur, Travis", country: "nir", avg: 78.68, co: 41.55, fav: 20, money: 0, tourCard: false },
        { name: "Bailey, James", country: "aus", avg: 78.66, co: 44.82, fav: 16, money: 0, tourCard: false },
        { name: "Tibbe, Gerko", country: "eng", avg: 78.63, co: 46.66, fav: 16, money: 0, tourCard: false },
        { name: "Riding, Tom", country: "eng", avg: 78.58, co: 49.78, fav: 20, money: 0, tourCard: false },
        { name: "Socha, Florian", country: "ger", avg: 78.58, co: 52.11, fav: 20, money: 0, tourCard: false },
        { name: "Kelly, Liam", country: "eng", avg: 78.54, co: 43.56, fav: 16, money: 0, tourCard: false },
        { name: "Taylor, Scott", country: "eng", avg: 78.54, co: 60.43, fav: 16, money: 0, tourCard: false },
        { name: "Teehan, Ciaran", country: "irl", avg: 78.52, co: 38.36, fav: 20, money: 0, tourCard: false },
        { name: "Hurds, Chris", country: "eng", avg: 78.51, co: 48.55, fav: 20, money: 0, tourCard: false },
        { name: "Quinn, Patrick", country: "irl", avg: 78.5, co: 40.85, fav: 20, money: 0, tourCard: false },
        { name: "Vleghert, Marc", country: "eng", avg: 78.47, co: 42.48, fav: 16, money: 0, tourCard: false },
        { name: "Dekker, Patrick", country: "eng", avg: 78.38, co: 48.91, fav: 16, money: 0, tourCard: false },
        { name: "Bradshaw, Justin", country: "eng", avg: 78.35, co: 44.07, fav: 20, money: 0, tourCard: false },
        { name: "Admiraal, Laurens", country: "eng", avg: 78.33, co: 47.19, fav: 16, money: 0, tourCard: false },
        { name: "Erba, Marcel", country: "ger", avg: 78.31, co: 45.25, fav: 20, money: 0, tourCard: false },
        { name: "Becker, Jarod", country: "ger", avg: 78.3, co: 52.32, fav: 16, money: 0, tourCard: false },
        { name: "Davey, John", country: "wal", avg: 78.25, co: 49.38, fav: 16, money: 0, tourCard: false },
        { name: "Michael, John", country: "gre", avg: 78.16, co: 42.5, fav: 20, money: 0, tourCard: false },
        { name: "Jansen, Javanico", country: "cze", avg: 78.14, co: 47.7, fav: 20, money: 0, tourCard: false },
        { name: "Goedl, Christian", country: "aut", avg: 78.13, co: 33.9, fav: 16, money: 0, tourCard: false },
        { name: "Baba, Yoshihisa", country: "jpn", avg: 78.12, co: 47.8, fav: 16, money: 0, tourCard: false },
        { name: "Caste, Mat", country: "eng", avg: 78.04, co: 41.47, fav: 20, money: 0, tourCard: false },
        { name: "Schiertz, Felix", country: "sui", avg: 78.04, co: 43.81, fav: 16, money: 0, tourCard: false },
        { name: "Lap, Sietse", country: "eng", avg: 77.99, co: 43.57, fav: 20, money: 0, tourCard: false },
        { name: "Krassen, Sergio", country: "ita", avg: 77.98, co: 40.43, fav: 16, money: 0, tourCard: false },
        { name: "Koehoorn, Gillian", country: "eng", avg: 77.96, co: 43.56, fav: 16, money: 0, tourCard: false },
        { name: "Vanbesien, James", country: "bel", avg: 77.96, co: 50.02, fav: 16, money: 0, tourCard: false },
        { name: "Nirschl, Maximilian", country: "ger", avg: 77.94, co: 45.1, fav: 16, money: 0, tourCard: false },
        { name: "Madgwick, John", country: "eng", avg: 77.93, co: 43.31, fav: 16, money: 0, tourCard: false },
        { name: "Moravcik, Dominik", country: "cze", avg: 77.91, co: 44.71, fav: 20, money: 0, tourCard: false },
        { name: "Znutins, Edgar", country: "lat", avg: 77.87, co: 52.89, fav: 20, money: 0, tourCard: false },
        { name: "Barkhausen, Jannis", country: "ger", avg: 77.8, co: 47.46, fav: 20, money: 0, tourCard: false },
        { name: "Rollinson, Jamie", country: "eng", avg: 77.8, co: 44.4, fav: 16, money: 0, tourCard: false },
        { name: "Milne, Kayden", country: "nzl", avg: 77.79, co: 46.64, fav: 20, money: 0, tourCard: false },
        { name: "Remde, Leon", country: "ger", avg: 77.77, co: 49.14, fav: 16, money: 0, tourCard: false },
        { name: "Spivey, Sam", country: "eng", avg: 77.74, co: 38.75, fav: 16, money: 0, tourCard: false },
        { name: "Bottenberg, Jarno", country: "ger", avg: 77.73, co: 46.71, fav: 20, money: 0, tourCard: false },
        { name: "Koch, Marvin", country: "ger", avg: 77.67, co: 40.5, fav: 20, money: 0, tourCard: false },
        { name: "Hill, David", country: "eng", avg: 77.64, co: 34.16, fav: 20, money: 0, tourCard: false },
        { name: "Jones, Timothy", country: "gbr", avg: 77.6, co: 57.0, fav: 16, money: 0, tourCard: false },
        { name: "Francis, Callum", country: "eng", avg: 77.59, co: 27.63, fav: 16, money: 0, tourCard: false },
        { name: "Mesters, Ruben", country: "eng", avg: 77.59, co: 51.82, fav: 20, money: 0, tourCard: false },
        { name: "Hexel, Marcel", country: "ger", avg: 77.58, co: 57.17, fav: 16, money: 0, tourCard: false },
        { name: "Lane, Harry", country: "eng", avg: 77.58, co: 45.88, fav: 16, money: 0, tourCard: false },
        { name: "Barauskas, Mindaugas", country: "ltu", avg: 77.56, co: 47.8, fav: 16, money: 0, tourCard: false },
        { name: "Masek, Alexander", country: "cze", avg: 77.56, co: 36.08, fav: 16, money: 0, tourCard: false },
        { name: "McDyer, Ultan", country: "irl", avg: 77.51, co: 43.08, fav: 20, money: 0, tourCard: false },
        { name: "Teysen, Simon", country: "bel", avg: 77.51, co: 43.97, fav: 16, money: 0, tourCard: false },
        { name: "De Ruyter, Kirk", country: "eng", avg: 77.47, co: 47.0, fav: 20, money: 0, tourCard: false },
        { name: "Dees, Stefan", country: "eng", avg: 77.46, co: 41.04, fav: 20, money: 0, tourCard: false },
        { name: "Symons, Charlie", country: "eng", avg: 77.41, co: 38.57, fav: 20, money: 0, tourCard: false },
        { name: "Knopf, Kevin", country: "ger", avg: 77.4, co: 43.44, fav: 20, money: 0, tourCard: false },
        { name: "Schlueter, Lenny", country: "ger", avg: 77.37, co: 38.23, fav: 16, money: 0, tourCard: false },
        { name: "Schroder, Stefan", country: "ger", avg: 77.29, co: 37.2, fav: 20, money: 0, tourCard: false },
        { name: "Devine, Adrian", country: "nir", avg: 77.23, co: 46.78, fav: 16, money: 0, tourCard: false },
        { name: "Ferrero, Dominic", country: "ger", avg: 77.23, co: 40.44, fav: 20, money: 0, tourCard: false },
        { name: "Richardson, Kyle", country: "gbr", avg: 77.2, co: 62.21, fav: 16, money: 0, tourCard: false },
        { name: "Keen, Jeffrey", country: "eng", avg: 77.17, co: 45.89, fav: 20, money: 0, tourCard: false },
        { name: "Micheletti, Andrea", country: "ita", avg: 77.16, co: 45.15, fav: 16, money: 0, tourCard: false },
        { name: "Camacho, Luis", country: "por", avg: 77.15, co: 36.05, fav: 20, money: 0, tourCard: false },
        { name: "Morgan-Williams, Brett", country: "sco", avg: 77.13, co: 49.75, fav: 20, money: 0, tourCard: false },
        { name: "Waite, James", country: "eng", avg: 77.09, co: 50.33, fav: 20, money: 0, tourCard: false },
        { name: "Van Zeele, Stefano", country: "ned", avg: 77.04, co: 45.25, fav: 16, money: 0, tourCard: false },
        { name: "Duerbeck, Joachim", country: "ger", avg: 77.0, co: 49.19, fav: 16, money: 0, tourCard: false },
        { name: "Goddard, Danny", country: "eng", avg: 76.98, co: 42.82, fav: 16, money: 0, tourCard: false },
        { name: "Callary, Andrew", country: "sco", avg: 76.95, co: 50.92, fav: 20, money: 0, tourCard: false },
        { name: "Crouwel, Nick", country: "eng", avg: 76.86, co: 55.54, fav: 16, money: 0, tourCard: false },
        { name: "Bulen, Patrick", country: "bel", avg: 76.82, co: 34.23, fav: 20, money: 0, tourCard: false },
        { name: "Evans, Kieran", country: "eng", avg: 76.81, co: 45.5, fav: 16, money: 0, tourCard: false },
        { name: "Goyer, Paul", country: "ger", avg: 76.72, co: 44.81, fav: 20, money: 0, tourCard: false },
        { name: "Zhukov, Dmitriy", country: "lat", avg: 76.71, co: 44.62, fav: 16, money: 0, tourCard: false },
        { name: "Steyer, Sebastian", country: "pol", avg: 76.64, co: 40.03, fav: 16, money: 0, tourCard: false },
        { name: "Stothart, Simon", country: "eng", avg: 76.63, co: 34.43, fav: 16, money: 0, tourCard: false },
        { name: "Deysel, Hugo Albertus", country: "rsa", avg: 76.61, co: 55.4, fav: 20, money: 0, tourCard: false },
        { name: "Te Hennepe, Lorenzo", country: "eng", avg: 76.61, co: 36.58, fav: 16, money: 0, tourCard: false },
        { name: "Van Peer, Carlo", country: "ned", avg: 76.61, co: 52.83, fav: 16, money: 0, tourCard: false },
        { name: "Hall, Matthew", country: "eng", avg: 76.56, co: 37.5, fav: 20, money: 0, tourCard: false },
        { name: "Maendl-Lawrance, Liam", country: "ger", avg: 76.54, co: 41.35, fav: 20, money: 0, tourCard: false },
        { name: "Schmitt, Felix", country: "ger", avg: 76.52, co: 40.4, fav: 16, money: 0, tourCard: false },
        { name: "Castelli, Riccardo", country: "ita", avg: 76.4, co: 57.4, fav: 20, money: 0, tourCard: false },
        { name: "Bayton, Dave", country: "eng", avg: 76.36, co: 24.83, fav: 16, money: 0, tourCard: false },
        { name: "Hitchen, Anthony Paul", country: "gbr", avg: 76.29, co: 32.73, fav: 20, money: 0, tourCard: false },
        { name: "Scholz, Dennis", country: "ger", avg: 76.28, co: 39.11, fav: 16, money: 0, tourCard: false },
        { name: "Dante, Massimo", country: "ita", avg: 76.27, co: 39.45, fav: 20, money: 0, tourCard: false },
        { name: "Dueckers, Jan", country: "ger", avg: 76.26, co: 40.0, fav: 20, money: 0, tourCard: false },
        { name: "Kemp, Charlie", country: "eng", avg: 76.15, co: 32.82, fav: 16, money: 0, tourCard: false },
        { name: "Michiels, Michel", country: "eng", avg: 76.13, co: 50.55, fav: 20, money: 0, tourCard: false },
        { name: "Schunke, Nico", country: "ger", avg: 76.13, co: 45.12, fav: 20, money: 0, tourCard: false },
        { name: "Welk, Laurin", country: "ger", avg: 76.06, co: 43.61, fav: 20, money: 0, tourCard: false },
        { name: "Evans, David", country: "eng", avg: 76.05, co: 30.56, fav: 16, money: 0, tourCard: false },
        { name: "McKinnon, Jamie", country: "eng", avg: 76.0, co: 48.0, fav: 16, money: 0, tourCard: false },
        { name: "Nuijten, Jurgen", country: "eng", avg: 75.83, co: 36.35, fav: 16, money: 0, tourCard: false },
        { name: "Janowicz, Kamil", country: "pol", avg: 75.81, co: 49.92, fav: 20, money: 0, tourCard: false },
        { name: "Zalewski, Aleksander", country: "pol", avg: 75.79, co: 54.57, fav: 16, money: 0, tourCard: false },
        { name: "Straver, Dustin", country: "eng", avg: 75.77, co: 39.6, fav: 16, money: 0, tourCard: false },
        { name: "Coleman, Ashley", country: "eng", avg: 75.74, co: 32.11, fav: 16, money: 0, tourCard: false },
        { name: "Mossou, Maikel", country: "eng", avg: 75.74, co: 53.65, fav: 16, money: 0, tourCard: false },
        { name: "Parry, Neil", country: "wal", avg: 75.74, co: 49.67, fav: 16, money: 0, tourCard: false },
        { name: "Mcnally, Stephen", country: "eng", avg: 75.73, co: 51.11, fav: 16, money: 0, tourCard: false },
        { name: "Trommler, Simon", country: "ger", avg: 75.72, co: 42.88, fav: 20, money: 0, tourCard: false },
        { name: "Waclawski, Lukasz", country: "pol", avg: 75.72, co: 48.17, fav: 20, money: 0, tourCard: false },
        { name: "Part, John", country: "can", avg: 75.64, co: 61.92, fav: 16, money: 0, tourCard: false },
        { name: "Cocks, Nick", country: "gbr", avg: 75.61, co: 42.29, fav: 20, money: 0, tourCard: false },
        { name: "Dicken, Matthew", country: "eng", avg: 75.61, co: 43.3, fav: 20, money: 0, tourCard: false },
        { name: "Dalla Rosa, Massimo", country: "ita", avg: 75.53, co: 58.64, fav: 16, money: 0, tourCard: false },
        { name: "Schlichting, David", country: "ger", avg: 75.47, co: 52.76, fav: 16, money: 0, tourCard: false },
        { name: "Van Den Berg, Loek", country: "ned", avg: 75.43, co: 39.5, fav: 20, money: 0, tourCard: false },
        { name: "Devroey, Pascal", country: "bel", avg: 75.42, co: 43.52, fav: 16, money: 0, tourCard: false },
        { name: "Van Velzen, Keanu", country: "ned", avg: 75.36, co: 49.24, fav: 20, money: 0, tourCard: false },
        { name: "Ulrych, Jindrich", country: "cze", avg: 75.35, co: 48.5, fav: 16, money: 0, tourCard: false },
        { name: "Green, James", country: "eng", avg: 75.31, co: 48.43, fav: 20, money: 0, tourCard: false },
        { name: "Kristensen, Tom Veje", country: "den", avg: 75.31, co: 43.62, fav: 16, money: 0, tourCard: false },
        { name: "Whitehouse, Connor", country: "eng", avg: 75.26, co: 42.67, fav: 20, money: 0, tourCard: false },
        { name: "McCormack, Killian", country: "irl", avg: 75.22, co: 48.82, fav: 20, money: 0, tourCard: false },
        { name: "Hausotter, Marcel", country: "ger", avg: 75.11, co: 27.36, fav: 16, money: 0, tourCard: false },
        { name: "Sturm, Rainer", country: "aut", avg: 75.1, co: 31.33, fav: 16, money: 0, tourCard: false },
        { name: "Van Deest, Marvin", country: "ned", avg: 75.1, co: 47.5, fav: 20, money: 0, tourCard: false },
        { name: "Boardman, Jack", country: "eng", avg: 74.97, co: 42.75, fav: 20, money: 0, tourCard: false },
        { name: "Hijmans, Nick", country: "eng", avg: 74.97, co: 41.96, fav: 20, money: 0, tourCard: false },
        { name: "Bridle, Joseph", country: "eng", avg: 74.89, co: 41.71, fav: 20, money: 0, tourCard: false },
        { name: "Trinker, Bernhard", country: "aut", avg: 74.82, co: 43.32, fav: 20, money: 0, tourCard: false },
        { name: "Moss, Steven", country: "eng", avg: 74.81, co: 36.93, fav: 16, money: 0, tourCard: false },
        { name: "Lambertsen, Bent", country: "den", avg: 74.72, co: 45.85, fav: 20, money: 0, tourCard: false },
        { name: "Toonders, Christopher", country: "ger", avg: 74.7, co: 45.9, fav: 20, money: 0, tourCard: false },
        { name: "Kustermans, Maikel", country: "eng", avg: 74.65, co: 34.82, fav: 16, money: 0, tourCard: false },
        { name: "McDonagh, Ronan", country: "irl", avg: 74.57, co: 50.67, fav: 16, money: 0, tourCard: false },
        { name: "Rech, Riccardo", country: "ger", avg: 74.56, co: 46.38, fav: 16, money: 0, tourCard: false },
        { name: "Wilson, Stu", country: "eng", avg: 74.56, co: 44.64, fav: 16, money: 0, tourCard: false },
        { name: "Long, Robbie", country: "eng", avg: 74.54, co: 44.8, fav: 16, money: 0, tourCard: false },
        { name: "Stecconi, Giovanni", country: "ita", avg: 74.54, co: 38.94, fav: 20, money: 0, tourCard: false },
        { name: "Wille, Sven", country: "ger", avg: 74.52, co: 49.0, fav: 16, money: 0, tourCard: false },
        { name: "Aldous, Bradley", country: "eng", avg: 74.5, co: 38.67, fav: 20, money: 0, tourCard: false },
        { name: "Karcz, Lukasz", country: "pol", avg: 74.5, co: 39.43, fav: 20, money: 0, tourCard: false },
        { name: "Schwab, Patrick", country: "ger", avg: 74.46, co: 34.63, fav: 20, money: 0, tourCard: false },
        { name: "Van Der Vegt, Wouter", country: "ned", avg: 74.35, co: 45.43, fav: 16, money: 0, tourCard: false },
        { name: "Brouder, Neilie", country: "irl", avg: 74.31, co: 35.4, fav: 20, money: 0, tourCard: false },
        { name: "Mandiau, Remo", country: "bel", avg: 74.31, co: 41.83, fav: 16, money: 0, tourCard: false },
        { name: "Jongen, Martin", country: "eng", avg: 74.3, co: 44.54, fav: 16, money: 0, tourCard: false },
        { name: "Guener, Yasa", country: "ger", avg: 74.26, co: 48.25, fav: 20, money: 0, tourCard: false },
        { name: "Christodoulou, Petros", country: "cyp", avg: 74.19, co: 74.5, fav: 16, money: 0, tourCard: false },
        { name: "Grace, Lee", country: "eng", avg: 74.19, co: 43.64, fav: 20, money: 0, tourCard: false },
        { name: "Bezjian, Alberto", country: "hun", avg: 74.18, co: 38.75, fav: 16, money: 0, tourCard: false },
        { name: "Searle, Craig", country: "eng", avg: 74.18, co: 39.8, fav: 16, money: 0, tourCard: false },
        { name: "Unger, Lukas", country: "cze", avg: 74.17, co: 39.58, fav: 20, money: 0, tourCard: false },
        { name: "Valyi, Attila", country: "hun", avg: 74.12, co: 34.0, fav: 16, money: 0, tourCard: false },
        { name: "Coleman, Karl", country: "eng", avg: 74.11, co: 54.09, fav: 16, money: 0, tourCard: false },
        { name: "Moeller, Christopher", country: "ger", avg: 74.06, co: 47.22, fav: 20, money: 0, tourCard: false },
        { name: "Abelmann, Ralf", country: "ger", avg: 73.94, co: 39.91, fav: 20, money: 0, tourCard: false },
        { name: "Bohrmann, Moritz", country: "ger", avg: 73.93, co: 41.3, fav: 16, money: 0, tourCard: false },
        { name: "Knudsen, Mikkel Devantie", country: "den", avg: 73.92, co: 32.4, fav: 16, money: 0, tourCard: false },
        { name: "Vermeersch, Gino", country: "bel", avg: 73.91, co: 49.56, fav: 16, money: 0, tourCard: false },
        { name: "Kuhlig, Elias", country: "ger", avg: 73.87, co: 38.92, fav: 20, money: 0, tourCard: false },
        { name: "Rogov, Dmitrii", country: "isr", avg: 73.86, co: 39.44, fav: 20, money: 0, tourCard: false },
        { name: "Inkpen, Steven", country: "wal", avg: 73.85, co: 59.56, fav: 20, money: 0, tourCard: false },
        { name: "James, Gavin", country: "wal", avg: 73.84, co: 31.83, fav: 16, money: 0, tourCard: false },
        { name: "Ryan, Sean", country: "sco", avg: 73.79, co: 37.36, fav: 20, money: 0, tourCard: false },
        { name: "Diller, Danny", country: "ger", avg: 73.78, co: 38.9, fav: 16, money: 0, tourCard: false },
        { name: "Bihl, Fabian", country: "ger", avg: 73.74, co: 39.11, fav: 16, money: 0, tourCard: false },
        { name: "Kitchen, Liam", country: "eng", avg: 73.74, co: 41.13, fav: 16, money: 0, tourCard: false },
        { name: "Rajnoha, Miroslav", country: "svk", avg: 73.74, co: 48.92, fav: 20, money: 0, tourCard: false },
        { name: "Kirchmann, Marcus", country: "ger", avg: 73.73, co: 49.04, fav: 16, money: 0, tourCard: false },
        { name: "Procter, Tony", country: "eng", avg: 73.73, co: 75.8, fav: 20, money: 0, tourCard: false },
        { name: "Van Put, Born", country: "bel", avg: 73.68, co: 43.51, fav: 20, money: 0, tourCard: false },
        { name: "Kobylarz, Jerzy", country: "pol", avg: 73.67, co: 64.23, fav: 16, money: 0, tourCard: false },
        { name: "Heath, Geoffrey", country: "gbr", avg: 73.66, co: 49.54, fav: 20, money: 0, tourCard: false },
        { name: "Hurtz, Michael", country: "ger", avg: 73.65, co: 42.06, fav: 16, money: 0, tourCard: false },
        { name: "Bota Ramos, Pau", country: "esp", avg: 73.63, co: 31.86, fav: 20, money: 0, tourCard: false },
        { name: "Sheppard, Jack Anthony", country: "nzl", avg: 73.58, co: 40.88, fav: 20, money: 0, tourCard: false },
        { name: "Limburg, Jan Luca", country: "ger", avg: 73.56, co: 47.05, fav: 20, money: 0, tourCard: false },
        { name: "Delgado, Dani", country: "esp", avg: 73.54, co: 49.62, fav: 16, money: 0, tourCard: false },
        { name: "Scheurwater, Donny", country: "ger", avg: 73.52, co: 44.76, fav: 20, money: 0, tourCard: false },
        { name: "Radosavljevic, Mladen", country: "srb", avg: 73.5, co: 43.08, fav: 16, money: 0, tourCard: false },
        { name: "Gater, Thomas", country: "eng", avg: 73.49, co: 61.4, fav: 16, money: 0, tourCard: false },
        { name: "Rollo, Gabriel", country: "ita", avg: 73.48, co: 41.44, fav: 16, money: 0, tourCard: false },
        { name: "Phillips, Cavan", country: "wal", avg: 73.43, co: 40.21, fav: 20, money: 0, tourCard: false },
        { name: "Rosi, David", country: "cze", avg: 73.42, co: 37.33, fav: 16, money: 0, tourCard: false },
        { name: "White, Bailey", country: "eng", avg: 73.37, co: 38.6, fav: 20, money: 0, tourCard: false },
        { name: "Michalczyk, Alexander", country: "ger", avg: 73.34, co: 41.65, fav: 16, money: 0, tourCard: false },
        { name: "Smith (Chester), Luke", country: "eng", avg: 73.33, co: 42.5, fav: 20, money: 0, tourCard: false },
        { name: "Boardman, Mark", country: "eng", avg: 73.28, co: 64.7, fav: 20, money: 0, tourCard: false },
        { name: "Jorgensen, Andreas Toft", country: "den", avg: 73.24, co: 33.83, fav: 20, money: 0, tourCard: false },
        { name: "Adams, Ben", country: "wal", avg: 73.23, co: 50.5, fav: 20, money: 0, tourCard: false },
        { name: "Smith, Alfie", country: "eng", avg: 73.23, co: 35.55, fav: 20, money: 0, tourCard: false },
        { name: "Sewell, Steve", country: "gbr", avg: 73.21, co: 38.63, fav: 16, money: 0, tourCard: false },
        { name: "Lindour, Kieran", country: "ger", avg: 73.2, co: 55.93, fav: 20, money: 0, tourCard: false },
        { name: "Patel, Bhav", country: "eng", avg: 73.19, co: 26.43, fav: 16, money: 0, tourCard: false },
        { name: "Richter, Moritz", country: "ger", avg: 73.19, co: 38.32, fav: 16, money: 0, tourCard: false },
        { name: "Fridriksson, Matthias Orn", country: "isl", avg: 73.18, co: 51.63, fav: 20, money: 0, tourCard: false },
        { name: "Jungwirth, Marco", country: "aut", avg: 73.17, co: 36.89, fav: 16, money: 0, tourCard: false },
        { name: "Baulcomb, Max", country: "eng", avg: 73.13, co: 44.75, fav: 16, money: 0, tourCard: false },
        { name: "Schweder, Philipp", country: "ger", avg: 73.13, co: 36.05, fav: 16, money: 0, tourCard: false },
        { name: "Holroyd, Rob", country: "eng", avg: 73.11, co: 52.5, fav: 16, money: 0, tourCard: false },
        { name: "Burt, Simon", country: "eng", avg: 73.1, co: 44.4, fav: 16, money: 0, tourCard: false },
        { name: "Robijns, Davy", country: "bel", avg: 73.09, co: 38.67, fav: 20, money: 0, tourCard: false },
        { name: "Fink, Domenik", country: "ger", avg: 73.06, co: 41.32, fav: 20, money: 0, tourCard: false },
        { name: "Parradine, Tom", country: "eng", avg: 73.06, co: 38.12, fav: 16, money: 0, tourCard: false },
        { name: "Poulsen, Ivan Springborg", country: "den", avg: 73.06, co: 41.82, fav: 16, money: 0, tourCard: false },
        { name: "Rosenauer, Michael", country: "ger", avg: 73.03, co: 38.74, fav: 20, money: 0, tourCard: false },
        { name: "Dispa, Jan-Willem", country: "cze", avg: 72.95, co: 63.63, fav: 20, money: 0, tourCard: false },
        { name: "Yildiz, Halil Can", country: "tur", avg: 72.94, co: 34.63, fav: 16, money: 0, tourCard: false },
        { name: "Bennett, Stuart", country: "eng", avg: 72.93, co: 43.0, fav: 16, money: 0, tourCard: false },
        { name: "Brogan, James", country: "irl", avg: 72.86, co: 44.15, fav: 20, money: 0, tourCard: false },
        { name: "Trutalli, Paolo", country: "ita", avg: 72.82, co: 39.89, fav: 20, money: 0, tourCard: false },
        { name: "Tonks, Martin", country: "eng", avg: 72.81, co: 33.42, fav: 20, money: 0, tourCard: false },
        { name: "Ozbolt, Danijel", country: "cro", avg: 72.8, co: 37.93, fav: 16, money: 0, tourCard: false },
        { name: "Spoolder, Clemens", country: "eng", avg: 72.71, co: 38.84, fav: 20, money: 0, tourCard: false },
        { name: "Bereths, Paul", country: "ger", avg: 72.66, co: 39.64, fav: 16, money: 0, tourCard: false },
        { name: "Atellinghusen, Justin", country: "eng", avg: 72.64, co: 49.63, fav: 20, money: 0, tourCard: false },
        { name: "Szlanyina, Jozsef", country: "hun", avg: 72.6, co: 33.9, fav: 20, money: 0, tourCard: false },
        { name: "Rizzo, Giuseppe", country: "ita", avg: 72.52, co: 39.84, fav: 16, money: 0, tourCard: false },
        { name: "Ungethuem, Ronny", country: "ger", avg: 72.51, co: 47.3, fav: 16, money: 0, tourCard: false },
        { name: "Scholing, Rob", country: "ger", avg: 72.44, co: 45.84, fav: 16, money: 0, tourCard: false },
        { name: "Kelly, Michael", country: "irl", avg: 72.43, co: 46.0, fav: 20, money: 0, tourCard: false },
        { name: "Zadach, Daniel", country: "ger", avg: 72.42, co: 39.9, fav: 16, money: 0, tourCard: false },
        { name: "Hermann, Joshua", country: "ger", avg: 72.4, co: 37.09, fav: 16, money: 0, tourCard: false },
        { name: "Moreira, Stevie", country: "eng", avg: 72.39, co: 49.5, fav: 20, money: 0, tourCard: false },
        { name: "Burmeister, Marc", country: "ger", avg: 72.38, co: 41.85, fav: 20, money: 0, tourCard: false },
        { name: "Di Poce, Stefano", country: "ita", avg: 72.38, co: 33.2, fav: 20, money: 0, tourCard: false },
        { name: "Heard, Robert", country: "wal", avg: 72.32, co: 46.92, fav: 16, money: 0, tourCard: false },
        { name: "Ziman, Martin", country: "svk", avg: 72.31, co: 48.0, fav: 16, money: 0, tourCard: false },
        { name: "Borzsei, Janos", country: "hun", avg: 72.3, co: 41.87, fav: 16, money: 0, tourCard: false },
        { name: "Watkins, Craig", country: "gbr", avg: 72.25, co: 32.75, fav: 16, money: 0, tourCard: false },
        { name: "Nelson, Robert", country: "sco", avg: 72.19, co: 35.91, fav: 20, money: 0, tourCard: false },
        { name: "Saxon, Liam", country: "eng", avg: 72.13, co: 40.0, fav: 20, money: 0, tourCard: false },
        { name: "Harms, Kevin", country: "eng", avg: 72.09, co: 33.8, fav: 20, money: 0, tourCard: false },
        { name: "Rodriguez, Angel", country: "esp", avg: 72.04, co: 36.0, fav: 16, money: 0, tourCard: false },
        { name: "Tuik, Niek", country: "eng", avg: 72.04, co: 47.76, fav: 20, money: 0, tourCard: false },
        { name: "Baughan, Tom", country: "eng", avg: 72.02, co: 40.17, fav: 16, money: 0, tourCard: false },
        { name: "Ham, Ricardo", country: "eng", avg: 72.0, co: 51.14, fav: 20, money: 0, tourCard: false },
        { name: "Radford, Ellis", country: "eng", avg: 71.98, co: 43.2, fav: 16, money: 0, tourCard: false },
        { name: "Lageweg, Martijn", country: "eng", avg: 71.96, co: 47.68, fav: 16, money: 0, tourCard: false },
        { name: "Gomula, Marcel", country: "ger", avg: 71.9, co: 47.0, fav: 16, money: 0, tourCard: false },
        { name: "Selby-Rivas, Jaikob", country: "eng", avg: 71.88, co: 44.44, fav: 20, money: 0, tourCard: false },
        { name: "Hamrozi, Tomas", country: "cze", avg: 71.85, co: 28.0, fav: 16, money: 0, tourCard: false },
        { name: "Fredriksen, Bastiaan", country: "eng", avg: 71.83, co: 45.33, fav: 20, money: 0, tourCard: false },
        { name: "Barnard, Michael", country: "eng", avg: 71.78, co: 37.91, fav: 16, money: 0, tourCard: false },
        { name: "Bereza, Filip", country: "pol", avg: 71.78, co: 45.14, fav: 16, money: 0, tourCard: false },
        { name: "Hesse, Stefan", country: "ger", avg: 71.77, co: 35.17, fav: 16, money: 0, tourCard: false },
        { name: "Weaver, Ashley", country: "eng", avg: 71.75, co: 40.0, fav: 20, money: 0, tourCard: false },
        { name: "Konterman, Arjan", country: "cze", avg: 71.68, co: 49.45, fav: 20, money: 0, tourCard: false },
        { name: "Van Der Ende, Dennis", country: "ned", avg: 71.56, co: 40.75, fav: 16, money: 0, tourCard: false },
        { name: "Castle, Stephen", country: "wal", avg: 71.53, co: 56.25, fav: 20, money: 0, tourCard: false },
        { name: "Hill, Janek", country: "eng", avg: 71.52, co: 48.07, fav: 16, money: 0, tourCard: false },
        { name: "Garcia, Kevin", country: "eng", avg: 71.5, co: 36.0, fav: 20, money: 0, tourCard: false },
        { name: "Elzinga, Luitsen", country: "eng", avg: 71.48, co: 40.22, fav: 16, money: 0, tourCard: false },
        { name: "Evans-Bradford, James", country: "eng", avg: 71.47, co: 43.18, fav: 16, money: 0, tourCard: false },
        { name: "Barham, Paul", country: "eng", avg: 71.46, co: 24.86, fav: 20, money: 0, tourCard: false },
        { name: "Worsley, Jack", country: "gbr", avg: 71.39, co: 60.17, fav: 16, money: 0, tourCard: false },
        { name: "Testroote, Jordy", country: "eng", avg: 71.35, co: 49.57, fav: 20, money: 0, tourCard: false },
        { name: "Twist, Mark", country: "eng", avg: 71.32, co: 47.93, fav: 16, money: 0, tourCard: false },
        { name: "Price, Lee", country: "eng", avg: 71.26, co: 30.56, fav: 20, money: 0, tourCard: false },
        { name: "Hogg, Chris", country: "eng", avg: 71.22, co: 15.0, fav: 16, money: 0, tourCard: false },
        { name: "Redhead, Terry", country: "eng", avg: 71.21, co: 32.33, fav: 16, money: 0, tourCard: false },
        { name: "Acar, Baris", country: "ger", avg: 71.17, co: 44.8, fav: 20, money: 0, tourCard: false },
        { name: "Wellinger, Roman", country: "sui", avg: 71.11, co: 44.0, fav: 16, money: 0, tourCard: false },
        { name: "Yamada, Yuki", country: "jpn", avg: 71.09, co: 33.39, fav: 16, money: 0, tourCard: false },
        { name: "Ehlers, Thomas", country: "ger", avg: 71.07, co: 28.79, fav: 20, money: 0, tourCard: false },
        { name: "Smith, Daniel", country: "eng", avg: 71.07, co: 40.92, fav: 20, money: 0, tourCard: false },
        { name: "Lewandowski, Witold", country: "pol", avg: 71.06, co: 46.35, fav: 16, money: 0, tourCard: false },
        { name: "Jeske, David", country: "ger", avg: 71.05, co: 41.42, fav: 20, money: 0, tourCard: false },
        { name: "Ling, Ash", country: "gbr", avg: 70.92, co: 61.45, fav: 16, money: 0, tourCard: false },
        { name: "Lakatos, Gergely", country: "hun", avg: 70.81, co: 39.33, fav: 16, money: 0, tourCard: false },
        { name: "Arsenijevic, Max", country: "ger", avg: 70.75, co: 52.06, fav: 16, money: 0, tourCard: false },
        { name: "Stuhlemmer, Sascha", country: "ger", avg: 70.6, co: 45.17, fav: 16, money: 0, tourCard: false },
        { name: "Menzel, Bryan", country: "ger", avg: 70.57, co: 44.39, fav: 16, money: 0, tourCard: false },
        { name: "Gutgesell, Maurice", country: "ger", avg: 70.54, co: 38.35, fav: 20, money: 0, tourCard: false },
        { name: "Watts, Steven", country: "eng", avg: 70.54, co: 37.0, fav: 16, money: 0, tourCard: false },
        { name: "Enxuto, Nuno", country: "por", avg: 70.52, co: 37.62, fav: 20, money: 0, tourCard: false },
        { name: "Kniest, Jens", country: "ger", avg: 70.45, co: 41.8, fav: 20, money: 0, tourCard: false },
        { name: "Nowak, Boris", country: "ger", avg: 70.44, co: 47.0, fav: 16, money: 0, tourCard: false },
        { name: "Hein, Felix", country: "ger", avg: 70.42, co: 31.46, fav: 16, money: 0, tourCard: false },
        { name: "Mulder, Bert Jan", country: "cze", avg: 70.37, co: 27.33, fav: 20, money: 0, tourCard: false },
        { name: "Olar, Gabriel Florin", country: "rou", avg: 70.23, co: 48.33, fav: 16, money: 0, tourCard: false },
        { name: "Tobback, Jody", country: "bel", avg: 70.21, co: 51.93, fav: 16, money: 0, tourCard: false },
        { name: "Hertig, Roger", country: "sui", avg: 70.18, co: 56.0, fav: 20, money: 0, tourCard: false },
        { name: "Balogh, Richard", country: "hun", avg: 70.14, co: 53.71, fav: 16, money: 0, tourCard: false },
        { name: "Harrison, Michael", country: "gbr", avg: 70.13, co: 49.75, fav: 16, money: 0, tourCard: false },
        { name: "Horvat, Dragutin", country: "ger", avg: 70.07, co: 63.33, fav: 16, money: 0, tourCard: false },
        { name: "Grochotzky, Daniel", country: "ger", avg: 70.02, co: 45.11, fav: 16, money: 0, tourCard: false },
        { name: "Heuberger, Juergen", country: "aut", avg: 69.98, co: 48.6, fav: 20, money: 0, tourCard: false },
        { name: "Graversen, Jonas", country: "den", avg: 69.95, co: 44.33, fav: 16, money: 0, tourCard: false },
        { name: "Gustorf, Mitja", country: "ger", avg: 69.93, co: 34.5, fav: 16, money: 0, tourCard: false },
        { name: "Hyllgaardhus, Andreas", country: "den", avg: 69.92, co: 24.85, fav: 20, money: 0, tourCard: false },
        { name: "Nicolai, Calvin", country: "eng", avg: 69.9, co: 31.89, fav: 16, money: 0, tourCard: false },
        { name: "Gutjahr, Manuel", country: "ger", avg: 69.89, co: 30.0, fav: 20, money: 0, tourCard: false },
        { name: "Boelen, Jan", country: "cze", avg: 69.84, co: 50.2, fav: 20, money: 0, tourCard: false },
        { name: "Jozee, Jordy", country: "eng", avg: 69.84, co: 48.0, fav: 16, money: 0, tourCard: false },
        { name: "Sutton, Ashley", country: "eng", avg: 69.81, co: 32.09, fav: 20, money: 0, tourCard: false },
        { name: "Uguz, Nazmi", country: "tur", avg: 69.79, co: 37.53, fav: 20, money: 0, tourCard: false },
        { name: "Whyte, George", country: "eng", avg: 69.79, co: 35.83, fav: 20, money: 0, tourCard: false },
        { name: "Lang, Frieder", country: "ger", avg: 69.77, co: 40.71, fav: 16, money: 0, tourCard: false },
        { name: "Hartung, Pascal", country: "ger", avg: 69.72, co: 36.13, fav: 16, money: 0, tourCard: false },
        { name: "McKirdy, Jimmy", country: "sco", avg: 69.69, co: 39.8, fav: 16, money: 0, tourCard: false },
        { name: "Purgy, Marek", country: "svk", avg: 69.69, co: 39.79, fav: 16, money: 0, tourCard: false },
        { name: "Nielsen, Niels Aagaard", country: "den", avg: 69.67, co: 33.85, fav: 16, money: 0, tourCard: false },
        { name: "Booth, Sam", country: "eng", avg: 69.66, co: 35.36, fav: 20, money: 0, tourCard: false },
        { name: "Pfaff, Luca", country: "ger", avg: 69.61, co: 31.7, fav: 16, money: 0, tourCard: false },
        { name: "Flueckiger, Mika", country: "sui", avg: 69.56, co: 46.5, fav: 20, money: 0, tourCard: false },
        { name: "Peters, Frank", country: "ger", avg: 69.56, co: 36.4, fav: 20, money: 0, tourCard: false },
        { name: "Jeske, Cedric", country: "ger", avg: 69.51, co: 54.75, fav: 16, money: 0, tourCard: false },
        { name: "Nentjes, Geert", country: "eng", avg: 69.5, co: 48.86, fav: 20, money: 0, tourCard: false },
        { name: "Jacobi, Tim", country: "ger", avg: 69.41, co: 28.56, fav: 16, money: 0, tourCard: false },
        { name: "Zwick, Hilger", country: "ger", avg: 69.4, co: 37.94, fav: 20, money: 0, tourCard: false },
        { name: "Hauser, Dylan", country: "eng", avg: 69.37, co: 47.11, fav: 16, money: 0, tourCard: false },
        { name: "Blagden, Ronnie", country: "gbr", avg: 69.36, co: 28.0, fav: 20, money: 0, tourCard: false },
        { name: "Goncalves, Joaquim", country: "por", avg: 69.26, co: 46.37, fav: 20, money: 0, tourCard: false },
        { name: "Barker, Kristian", country: "eng", avg: 69.25, co: 50.0, fav: 20, money: 0, tourCard: false },
        { name: "Sarens, Kristof", country: "bel", avg: 69.21, co: 39.67, fav: 16, money: 0, tourCard: false },
        { name: "Sennikov, Denys", country: "ukr", avg: 69.18, co: 56.17, fav: 20, money: 0, tourCard: false },
        { name: "Humphries, Daniel", country: "gbr", avg: 69.12, co: 41.3, fav: 20, money: 0, tourCard: false },
        { name: "Fraulob, Lukas", country: "ger", avg: 69.09, co: 33.29, fav: 16, money: 0, tourCard: false },
        { name: "Newton, Ryan", country: "eng", avg: 69.09, co: 31.45, fav: 20, money: 0, tourCard: false },
        { name: "Olejnik, Miguel", country: "ger", avg: 69.07, co: 27.63, fav: 16, money: 0, tourCard: false },
        { name: "Newton, Josh", country: "eng", avg: 68.98, co: 82.0, fav: 16, money: 0, tourCard: false },
        { name: "Borbely, Andras", country: "hun", avg: 68.94, co: 35.94, fav: 20, money: 0, tourCard: false },
        { name: "Schockaert, Mathias", country: "bel", avg: 68.89, co: 23.83, fav: 16, money: 0, tourCard: false },
        { name: "Ozdemir, Ceyhan", country: "aut", avg: 68.88, co: 31.14, fav: 20, money: 0, tourCard: false },
        { name: "Ameel, Rino", country: "bel", avg: 68.86, co: 72.5, fav: 20, money: 0, tourCard: false },
        { name: "Hubrich, Dennis", country: "ger", avg: 68.85, co: 58.78, fav: 20, money: 0, tourCard: false },
        { name: "Carr, David", country: "eng", avg: 68.82, co: 21.0, fav: 16, money: 0, tourCard: false },
        { name: "Wagenaar, Richard", country: "eng", avg: 68.81, co: 34.32, fav: 20, money: 0, tourCard: false },
        { name: "Van Trijp, Wesley", country: "ned", avg: 68.74, co: 35.29, fav: 20, money: 0, tourCard: false },
        { name: "Bendoni, Fabio", country: "ita", avg: 68.67, co: 32.2, fav: 20, money: 0, tourCard: false },
        { name: "Aulich, Marcel", country: "ger", avg: 68.65, co: 31.67, fav: 20, money: 0, tourCard: false },
        { name: "Nebe, Dominik", country: "ger", avg: 68.51, co: 39.23, fav: 16, money: 0, tourCard: false },
        { name: "Cibula, Vojtech", country: "cze", avg: 68.47, co: 41.17, fav: 20, money: 0, tourCard: false },
        { name: "Antunes, Alexandre", country: "por", avg: 68.35, co: 35.33, fav: 16, money: 0, tourCard: false },
        { name: "De Vries, Hans", country: "ned", avg: 68.28, co: 38.26, fav: 20, money: 0, tourCard: false },
        { name: "Hessing, Rick", country: "eng", avg: 68.27, co: 37.0, fav: 16, money: 0, tourCard: false },
        { name: "Marquardt, Hendrik", country: "ger", avg: 68.26, co: 30.75, fav: 16, money: 0, tourCard: false },
        { name: "Van Hove - Speltincx, Kevin", country: "bel", avg: 68.23, co: 43.11, fav: 16, money: 0, tourCard: false },
        { name: "Gugger, Marcel", country: "sui", avg: 68.17, co: 49.86, fav: 16, money: 0, tourCard: false },
        { name: "Babik, Miroslav", country: "svk", avg: 68.11, co: 32.28, fav: 20, money: 0, tourCard: false },
        { name: "Heinsoe, Niels", country: "den", avg: 68.11, co: 32.8, fav: 16, money: 0, tourCard: false },
        { name: "Moore, Danny", country: "eng", avg: 68.1, co: 28.0, fav: 20, money: 0, tourCard: false },
        { name: "Scheffler, Steffen", country: "ger", avg: 68.09, co: 48.0, fav: 20, money: 0, tourCard: false },
        { name: "Bracke, Xavier", country: "bel", avg: 68.06, co: 54.63, fav: 20, money: 0, tourCard: false },
        { name: "Behrens, Finn", country: "ger", avg: 68.03, co: 45.0, fav: 16, money: 0, tourCard: false },
        { name: "Pedersen, Jonny", country: "nor", avg: 68.0, co: 52.18, fav: 16, money: 0, tourCard: false },
        { name: "Clari, Mark", country: "ger", avg: 67.92, co: 48.67, fav: 20, money: 0, tourCard: false },
        { name: "Heinz, Simeon", country: "ger", avg: 67.84, co: 42.64, fav: 16, money: 0, tourCard: false },
        { name: "Van De Putte, Roger", country: "ned", avg: 67.81, co: 60.89, fav: 16, money: 0, tourCard: false },
        { name: "Parvaneh, Jonathan", country: "ger", avg: 67.76, co: 44.5, fav: 20, money: 0, tourCard: false },
        { name: "Dietrich, Matthias", country: "sui", avg: 67.69, co: 34.75, fav: 20, money: 0, tourCard: false },
        { name: "Egli, Sandro", country: "sui", avg: 67.64, co: 43.44, fav: 16, money: 0, tourCard: false },
        { name: "Beretta, Sergio", country: "ita", avg: 67.58, co: 67.83, fav: 20, money: 0, tourCard: false },
        { name: "Klasens, Martijn", country: "eng", avg: 67.57, co: 40.64, fav: 20, money: 0, tourCard: false },
        { name: "Taylor, Sean", country: "gbr", avg: 67.52, co: 39.75, fav: 20, money: 0, tourCard: false },
        { name: "Maranhao, Lionel", country: "fra", avg: 67.47, co: 42.11, fav: 20, money: 0, tourCard: false },
        { name: "Roberts, Conor", country: "gbr", avg: 67.45, co: 26.0, fav: 20, money: 0, tourCard: false },
        { name: "Andrews, Lee", country: "eng", avg: 67.42, co: 43.93, fav: 16, money: 0, tourCard: false },
        { name: "Bos, Robin", country: "eng", avg: 67.41, co: 42.0, fav: 20, money: 0, tourCard: false },
        { name: "Pigache, Sebastian", country: "ger", avg: 67.4, co: 40.33, fav: 20, money: 0, tourCard: false },
        { name: "Moscelli, Michele", country: "ita", avg: 67.18, co: 36.0, fav: 16, money: 0, tourCard: false },
        { name: "Willems, Frederic", country: "bel", avg: 67.16, co: 47.79, fav: 20, money: 0, tourCard: false },
        { name: "Maranelli, Samuele", country: "ita", avg: 67.07, co: 49.67, fav: 16, money: 0, tourCard: false },
        { name: "Fey, Sebastian", country: "ger", avg: 66.92, co: 50.89, fav: 16, money: 0, tourCard: false },
        { name: "Perak, Igor", country: "cro", avg: 66.9, co: 60.89, fav: 16, money: 0, tourCard: false },
        { name: "Karbowiak, Sylwester", country: "pol", avg: 66.88, co: 36.84, fav: 16, money: 0, tourCard: false },
        { name: "Ascsillan, Gergo", country: "hun", avg: 66.87, co: 42.1, fav: 16, money: 0, tourCard: false },
        { name: "Backer, Tim", country: "ger", avg: 66.86, co: 33.35, fav: 16, money: 0, tourCard: false },
        { name: "Stocker, Mark", country: "gbr", avg: 66.68, co: 81.0, fav: 16, money: 0, tourCard: false },
        { name: "Timmers, Max", country: "eng", avg: 66.67, co: 30.57, fav: 16, money: 0, tourCard: false },
        { name: "Callis, Josh", country: "eng", avg: 66.6, co: 50.86, fav: 16, money: 0, tourCard: false },
        { name: "Claeys, Jason", country: "bel", avg: 66.45, co: 40.33, fav: 20, money: 0, tourCard: false },
        { name: "Beasley, Steven", country: "eng", avg: 66.32, co: 69.4, fav: 20, money: 0, tourCard: false },
        { name: "Watson, Spencer", country: "gbr", avg: 66.22, co: 41.83, fav: 20, money: 0, tourCard: false },
        { name: "Guyot, Jessy", country: "bel", avg: 66.18, co: 29.15, fav: 16, money: 0, tourCard: false },
        { name: "Woraczek, Michael", country: "aut", avg: 66.09, co: 40.38, fav: 16, money: 0, tourCard: false },
        { name: "Bahor, Rok", country: "svn", avg: 66.07, co: 39.86, fav: 16, money: 0, tourCard: false },
        { name: "Lucas-Carter, Louis", country: "gbr", avg: 66.04, co: 34.33, fav: 16, money: 0, tourCard: false },
        { name: "Taylor, Steven", country: "eng", avg: 66.04, co: 31.63, fav: 20, money: 0, tourCard: false },
        { name: "Schoenmakers, Martijn", country: "ger", avg: 66.03, co: 36.43, fav: 16, money: 0, tourCard: false },
        { name: "Rickner, Ronnie", country: "eng", avg: 65.99, co: 49.75, fav: 20, money: 0, tourCard: false },
        { name: "Schoonheydt, Zeno", country: "bel", avg: 65.95, co: 64.67, fav: 16, money: 0, tourCard: false },
        { name: "Singh Nagi, Coni", country: "ind", avg: 65.95, co: 29.17, fav: 16, money: 0, tourCard: false },
        { name: "Windeck, Stefan", country: "ger", avg: 65.94, co: 38.0, fav: 20, money: 0, tourCard: false },
        { name: "Coleman, Tommie", country: "eng", avg: 65.88, co: 16.0, fav: 20, money: 0, tourCard: false },
        { name: "Tomczak, Roman", country: "pol", avg: 65.86, co: 48.05, fav: 20, money: 0, tourCard: false },
        { name: "Flohr, Alex", country: "lux", avg: 65.84, co: 33.6, fav: 16, money: 0, tourCard: false },
        { name: "Luft, Viktor", country: "ger", avg: 65.79, co: 38.0, fav: 20, money: 0, tourCard: false },
        { name: "Paesschesoone, Steven", country: "bel", avg: 65.74, co: 49.0, fav: 16, money: 0, tourCard: false },
        { name: "Schmitz, Martin", country: "ger", avg: 65.68, co: 29.33, fav: 20, money: 0, tourCard: false },
        { name: "Kern, Rene", country: "aut", avg: 65.66, co: 41.63, fav: 20, money: 0, tourCard: false },
        { name: "Roeschlein, Noah", country: "ger", avg: 65.66, co: 24.67, fav: 16, money: 0, tourCard: false },
        { name: "Kaehler, Rene", country: "ger", avg: 65.62, co: 39.95, fav: 20, money: 0, tourCard: false },
        { name: "Schor, Fabian", country: "sui", avg: 65.6, co: 43.81, fav: 20, money: 0, tourCard: false },
        { name: "Bervoets, Ferre", country: "bel", avg: 65.38, co: 37.26, fav: 16, money: 0, tourCard: false },
        { name: "Egilsson, Hallgrimur", country: "isl", avg: 65.36, co: 37.8, fav: 20, money: 0, tourCard: false },
        { name: "Labbozzetta, Daniel", country: "ita", avg: 65.19, co: 33.13, fav: 16, money: 0, tourCard: false },
        { name: "Jonsson, Karl", country: "isl", avg: 65.01, co: 38.47, fav: 16, money: 0, tourCard: false },
        { name: "Steernberg, Kai", country: "ger", avg: 64.96, co: 41.67, fav: 16, money: 0, tourCard: false },
        { name: "Krekacs, Barna", country: "hun", avg: 64.95, co: 43.25, fav: 20, money: 0, tourCard: false },
        { name: "Pijpers, Robert", country: "eng", avg: 64.92, co: 32.07, fav: 20, money: 0, tourCard: false },
        { name: "Fritz, Dominic", country: "ger", avg: 64.84, co: 54.57, fav: 16, money: 0, tourCard: false },
        { name: "Seghers, Diederik", country: "bel", avg: 64.79, co: 45.56, fav: 16, money: 0, tourCard: false },
        { name: "Secular, Jack", country: "irl", avg: 64.78, co: 32.4, fav: 16, money: 0, tourCard: false },
        { name: "Materna, Tomas", country: "cze", avg: 64.76, co: 30.96, fav: 20, money: 0, tourCard: false },
        { name: "Vanhorenbeek, Bram", country: "bel", avg: 64.73, co: 39.11, fav: 16, money: 0, tourCard: false },
        { name: "De Veth, Rubin", country: "ned", avg: 64.71, co: 64.25, fav: 16, money: 0, tourCard: false },
        { name: "Vanlaer, David", country: "bel", avg: 64.64, co: 46.63, fav: 20, money: 0, tourCard: false },
        { name: "Teixeira Rodrigues, Pedro", country: "por", avg: 64.58, co: 29.78, fav: 20, money: 0, tourCard: false },
        { name: "Taferner, Stefan", country: "aut", avg: 64.57, co: 38.67, fav: 20, money: 0, tourCard: false },
        { name: "Koehler, Maik", country: "ger", avg: 64.37, co: 33.5, fav: 20, money: 0, tourCard: false },
        { name: "Clarke, Ashley", country: "eng", avg: 64.23, co: 28.0, fav: 16, money: 0, tourCard: false },
        { name: "Wierling, Niclas", country: "ger", avg: 64.23, co: 71.0, fav: 16, money: 0, tourCard: false },
        { name: "Bishop, Jack", country: "eng", avg: 64.15, co: 36.4, fav: 16, money: 0, tourCard: false },
        { name: "Dallmann, Lukas", country: "ger", avg: 64.13, co: 29.71, fav: 20, money: 0, tourCard: false },
        { name: "Hoentsch, Marcel", country: "ger", avg: 64.11, co: 66.0, fav: 20, money: 0, tourCard: false },
        { name: "Filippi, Dominik", country: "ger", avg: 64.09, co: 51.33, fav: 20, money: 0, tourCard: false },
        { name: "Sorensen, Jonas", country: "den", avg: 63.99, co: 39.71, fav: 16, money: 0, tourCard: false },
        { name: "Verhelst, Brian", country: "bel", avg: 63.62, co: 31.5, fav: 20, money: 0, tourCard: false },
        { name: "Germonpre, Bjorn", country: "bel", avg: 63.61, co: 42.07, fav: 20, money: 0, tourCard: false },
        { name: "Ellwart, Julian", country: "ger", avg: 63.6, co: 21.89, fav: 20, money: 0, tourCard: false },
        { name: "Kaya, Fetih", country: "tur", avg: 63.53, co: 27.62, fav: 20, money: 0, tourCard: false },
        { name: "Mayoh, Jack", country: "eng", avg: 63.5, co: 15.0, fav: 20, money: 0, tourCard: false },
        { name: "Rangel, Bruno", country: "bra", avg: 63.46, co: 32.8, fav: 20, money: 0, tourCard: false },
        { name: "Balfoort, Ronald", country: "eng", avg: 63.42, co: 61.0, fav: 20, money: 0, tourCard: false },
        { name: "Varga, Sasa", country: "cro", avg: 63.29, co: 39.33, fav: 16, money: 0, tourCard: false },
        { name: "Meijer, Raoul", country: "eng", avg: 63.24, co: 26.75, fav: 16, money: 0, tourCard: false },
        { name: "Jennings, Chris", country: "eng", avg: 63.23, co: 68.5, fav: 20, money: 0, tourCard: false },
        { name: "Elia, Alexander", country: "cyp", avg: 63.04, co: 70.0, fav: 16, money: 0, tourCard: false },
        { name: "Tvorogov, Egor", country: "ger", avg: 63.04, co: 32.75, fav: 16, money: 0, tourCard: false },
        { name: "Medema, Damon", country: "eng", avg: 62.94, co: 29.67, fav: 20, money: 0, tourCard: false },
        { name: "Warren, Michael", country: "eng", avg: 62.88, co: 26.0, fav: 20, money: 0, tourCard: false },
        { name: "Mielke, Gerrit", country: "ger", avg: 62.8, co: 27.57, fav: 20, money: 0, tourCard: false },
        { name: "Klein, Oliver", country: "ger", avg: 62.77, co: 40.41, fav: 16, money: 0, tourCard: false },
        { name: "Ough, Terry", country: "eng", avg: 62.77, co: 22.4, fav: 20, money: 0, tourCard: false },
        { name: "Berben, Cois", country: "bel", avg: 62.51, co: 37.22, fav: 16, money: 0, tourCard: false },
        { name: "Roland, Brandon", country: "bel", avg: 62.45, co: 15.0, fav: 16, money: 0, tourCard: false },
        { name: "Hendriks, Raoul", country: "eng", avg: 62.36, co: 54.44, fav: 16, money: 0, tourCard: false },
        { name: "Dierckx, Wim", country: "bel", avg: 62.18, co: 38.15, fav: 16, money: 0, tourCard: false },
        { name: "Vandewalle, Dylan", country: "bel", avg: 62.06, co: 48.14, fav: 16, money: 0, tourCard: false },
        { name: "Mus, Mike", country: "bel", avg: 61.98, co: 45.62, fav: 20, money: 0, tourCard: false },
        { name: "Wolter, Fabian", country: "ger", avg: 61.97, co: 27.13, fav: 20, money: 0, tourCard: false },
        { name: "Hoare, Andrew", country: "eng", avg: 61.83, co: 8.0, fav: 16, money: 0, tourCard: false },
        { name: "Drewes, Daniel", country: "ger", avg: 61.45, co: 43.75, fav: 20, money: 0, tourCard: false },
        { name: "Bacu00edk, Radek", country: "eng", avg: 61.39, co: 38.0, fav: 16, money: 0, tourCard: false },
        { name: "Gosch, Frank", country: "ger", avg: 61.3, co: 63.33, fav: 16, money: 0, tourCard: false },
        { name: "Stahlhut, Nils", country: "ger", avg: 61.29, co: 56.89, fav: 16, money: 0, tourCard: false },
        { name: "Giles, Justin", country: "eng", avg: 61.27, co: 56.0, fav: 20, money: 0, tourCard: false },
        { name: "Schoen, Fabian", country: "sui", avg: 61.15, co: 43.0, fav: 16, money: 0, tourCard: false },
        { name: "Mollink, Rik", country: "eng", avg: 61.06, co: 34.0, fav: 20, money: 0, tourCard: false },
        { name: "Zimmermann, Janick", country: "ger", avg: 60.84, co: 33.2, fav: 20, money: 0, tourCard: false },
        { name: "Quidousse, Kurt", country: "bel", avg: 60.67, co: 47.78, fav: 16, money: 0, tourCard: false },
        { name: "Paunoch, Martin", country: "hun", avg: 60.66, co: 29.27, fav: 20, money: 0, tourCard: false },
        { name: "Wilanowski, Przemyslaw", country: "pol", avg: 60.63, co: 54.0, fav: 16, money: 0, tourCard: false },
        { name: "Alan, Ersan", country: "ger", avg: 60.11, co: 24.0, fav: 16, money: 0, tourCard: false },
        { name: "Alukic, Alen", country: "aut", avg: 60.06, co: 15.0, fav: 16, money: 0, tourCard: false },
        { name: "Heimann, Andreas", country: "ger", avg: 59.96, co: 41.2, fav: 16, money: 0, tourCard: false },
        { name: "Bernhardt, Christian", country: "ger", avg: 59.94, co: 47.5, fav: 16, money: 0, tourCard: false },
        { name: "Fanning, Stephen", country: "gbr", avg: 59.73, co: 47.0, fav: 20, money: 0, tourCard: false },
        { name: "Allard, Thomas", country: "bel", avg: 59.59, co: 55.5, fav: 16, money: 0, tourCard: false },
        { name: "Thiel, Dominik", country: "ger", avg: 59.53, co: 38.75, fav: 16, money: 0, tourCard: false },
        { name: "Nees, Dimitri", country: "bel", avg: 59.45, co: 39.83, fav: 16, money: 0, tourCard: false },
        { name: "Daemen, Ruben", country: "bel", avg: 59.43, co: 37.0, fav: 16, money: 0, tourCard: false },
        { name: "Debaus, Matthias", country: "bel", avg: 59.39, co: 32.0, fav: 16, money: 0, tourCard: false },
        { name: "Kalashnikov, Paul", country: "hun", avg: 59.31, co: 27.71, fav: 20, money: 0, tourCard: false },
        { name: "Meulenmeesters, Erik", country: "eng", avg: 59.16, co: 39.17, fav: 20, money: 0, tourCard: false },
        { name: "Reschke, Bjorn", country: "ger", avg: 58.94, co: 32.0, fav: 20, money: 0, tourCard: false },
        { name: "Sanderson, Andrew", country: "wal", avg: 58.88, co: 15.0, fav: 16, money: 0, tourCard: false },
        { name: "Sato, Naoya", country: "jpn", avg: 58.85, co: 57.0, fav: 20, money: 0, tourCard: false },
        { name: "Massilge, Chris", country: "ger", avg: 58.83, co: 24.17, fav: 16, money: 0, tourCard: false },
        { name: "Moeller, Fabian", country: "ger", avg: 58.77, co: 41.0, fav: 16, money: 0, tourCard: false },
        { name: "Bonsch, Bartholomaus", country: "ger", avg: 58.62, co: 42.08, fav: 20, money: 0, tourCard: false },
        { name: "Reichenpfader, Marco", country: "aut", avg: 58.59, co: 28.33, fav: 16, money: 0, tourCard: false },
        { name: "O'Neill, Kalen", country: "irl", avg: 58.27, co: 36.0, fav: 16, money: 0, tourCard: false },
        { name: "Brisset, Serge", country: "fra", avg: 57.96, co: 24.5, fav: 16, money: 0, tourCard: false },
        { name: "Rehak, Jiri", country: "cze", avg: 57.95, co: 31.0, fav: 16, money: 0, tourCard: false },
        { name: "Fukar, Jan", country: "cze", avg: 57.42, co: 15.0, fav: 16, money: 0, tourCard: false },
        { name: "Harbert, Steven", country: "eng", avg: 56.97, co: 32.0, fav: 20, money: 0, tourCard: false },
        { name: "Sperling, James", country: "eng", avg: 56.81, co: 42.0, fav: 16, money: 0, tourCard: false },
        { name: "Vaisar, Zdenek", country: "cze", avg: 56.48, co: 78.0, fav: 20, money: 0, tourCard: false },
        { name: "Elsenheimer, Lars", country: "ger", avg: 56.45, co: 59.0, fav: 20, money: 0, tourCard: false },
        { name: "Dupke, Sascha", country: "ger", avg: 56.41, co: 15.0, fav: 16, money: 0, tourCard: false },
        { name: "Hrbek, Bohuslav", country: "cze", avg: 56.4, co: 74.0, fav: 20, money: 0, tourCard: false },
        { name: "Hofmann, Jan", country: "ger", avg: 56.21, co: 44.0, fav: 20, money: 0, tourCard: false },
        { name: "Van Meer, Dennis", country: "ned", avg: 55.81, co: 76.75, fav: 20, money: 0, tourCard: false },
        { name: "Rosted, Gustav Valdemar", country: "den", avg: 55.57, co: 22.0, fav: 16, money: 0, tourCard: false },
        { name: "Link, Patrick", country: "ger", avg: 54.98, co: 35.0, fav: 20, money: 0, tourCard: false },
        { name: "Schmiedlau, Clemens", country: "ger", avg: 54.65, co: 40.0, fav: 16, money: 0, tourCard: false },
        { name: "Till, Christian", country: "aut", avg: 54.57, co: 15.0, fav: 16, money: 0, tourCard: false },
        { name: "Rosenberger, Colin", country: "ger", avg: 54.24, co: 39.0, fav: 20, money: 0, tourCard: false },
        { name: "Schroeder, Frank", country: "sui", avg: 54.08, co: 25.0, fav: 20, money: 0, tourCard: false },
        { name: "Quiel, Niko", country: "ger", avg: 53.51, co: 15.0, fav: 20, money: 0, tourCard: false },
        { name: "Houf, Andreas", country: "ger", avg: 52.92, co: 34.0, fav: 20, money: 0, tourCard: false },
        { name: "Vekemans, Stijn", country: "bel", avg: 52.66, co: 29.67, fav: 16, money: 0, tourCard: false },
        { name: "Heinrich, Angela", country: "sui", avg: 52.13, co: 38.0, fav: 20, money: 0, tourCard: false },
        { name: "Reetz, Maurice", country: "ger", avg: 51.97, co: 33.33, fav: 16, money: 0, tourCard: false },
        { name: "Kaynarcalidan, Guerkan", country: "ger", avg: 51.83, co: 32.67, fav: 20, money: 0, tourCard: false },
        { name: "Tran, Chi-Minh", country: "sui", avg: 51.11, co: 40.0, fav: 16, money: 0, tourCard: false },
        { name: "Blum, Daniel", country: "ger", avg: 50.77, co: 15.0, fav: 20, money: 0, tourCard: false },
        { name: "Castrovinci, Maurizio", country: "ita", avg: 50.43, co: 15.0, fav: 20, money: 0, tourCard: false },
        { name: "Jansen, Ulrich", country: "ger", avg: 49.0, co: 19.33, fav: 20, money: 0, tourCard: false },
        { name: "Frese, Tobias", country: "ger", avg: 48.9, co: 15.0, fav: 20, money: 0, tourCard: false },
        { name: "Schroeder, Stefan", country: "ger", avg: 48.17, co: 24.0, fav: 20, money: 0, tourCard: false },
        { name: "Csato, Laszlo B", country: "hun", avg: 47.92, co: 15.0, fav: 20, money: 0, tourCard: false },
        { name: "Buergin, Benjamin", country: "sui", avg: 47.81, co: 15.0, fav: 16, money: 0, tourCard: false },
        { name: "Baines, Ross", country: "eng", avg: 47.55, co: 21.0, fav: 20, money: 0, tourCard: false },
        { name: "Whitehead, Bradley", country: "eng", avg: 47.37, co: 20.0, fav: 16, money: 0, tourCard: false },
        { name: "Rubes, Helena", country: "cze", avg: 47.3, co: 44.0, fav: 20, money: 0, tourCard: false },
        { name: "Coussaert, Ulrich", country: "bel", avg: 46.78, co: 15.0, fav: 20, money: 0, tourCard: false },
        { name: "Bailey, Joe", country: "eng", avg: 45.14, co: 15.0, fav: 20, money: 0, tourCard: false },
        { name: "Winkelmann, Dennis", country: "ger", avg: 44.9, co: 15.0, fav: 16, money: 0, tourCard: false },
        { name: "Kammann, Sven", country: "ger", avg: 44.75, co: 9.4, fav: 16, money: 0, tourCard: false },
        { name: "Walchshaeusl, Markus", country: "ger", avg: 42.45, co: 36.0, fav: 16, money: 0, tourCard: false },
        { name: "Kilian, Marciano", country: "eng", avg: 42.05, co: 20.0, fav: 16, money: 0, tourCard: false },
        { name: "Foster, Jamie", country: "eng", avg: 41.89, co: 15.0, fav: 20, money: 0, tourCard: false },
        { name: "Allen, Benjamin", country: "eng", avg: 41.73, co: 15.0, fav: 16, money: 0, tourCard: false },
        { name: "Bout, Marco", country: "ned", avg: 40.32, co: 15.0, fav: 16, money: 0, tourCard: false },
        { name: "Kelemen, Peter", country: "hun", avg: 82.53, co: 53.09, fav: 20, money: 0, tourCard: false },
        { name: "Jagicza, Gabor", country: "hun", avg: 81.33, co: 34.50, fav: 16, money: 0, tourCard: false },
        { name: "Balogh, Richard", country: "hun", avg: 76.97, co: 21.33, fav: 20, money: 0, tourCard: false },
        { name: "Ancsin, Laszlo", country: "hun", avg: 76.95, co: 26.00, fav: 16, money: 0, tourCard: false },
        { name: "Csoka, Andras", country: "hun", avg: 76.32, co: 33.73, fav: 20, money: 0, tourCard: false },
        { name: "Antal, Levente", country: "hun", avg: 75.98, co: 37.27, fav: 16, money: 0, tourCard: false },
        { name: "Horvath, Bence", country: "hun", avg: 75.57, co: 61.00, fav: 20, money: 0, tourCard: false },
        { name: "Melisek, Zsolt", country: "hun", avg: 75.54, co: 45.00, fav: 16, money: 0, tourCard: false },
        { name: "Vegso, Janos", country: "hun", avg: 75.33, co: 57.38, fav: 20, money: 0, tourCard: false },
        { name: "Bai, Zsolt", country: "hun", avg: 74.53, co: 29.09, fav: 16, money: 0, tourCard: false },
        { name: "Lauko, Mark", country: "hun", avg: 74.34, co: 53.00, fav: 20, money: 0, tourCard: false },
        { name: "Borzsei, Janos", country: "hun", avg: 72.13, co: 40.91, fav: 16, money: 0, tourCard: false },
        { name: "Vida, Mihaly", country: "hun", avg: 72.10, co: 38.50, fav: 20, money: 0, tourCard: false },
        { name: "Egedi, Bence", country: "hun", avg: 70.39, co: 38.22, fav: 16, money: 0, tourCard: false },
        { name: "Lovei, Milan", country: "hun", avg: 69.39, co: 37.33, fav: 20, money: 0, tourCard: false },
        { name: "Turjak, Tamas", country: "hun", avg: 69.11, co: 15.0, fav: 16, money: 0, tourCard: false },
        { name: "Bolla, Ferenc", country: "hun", avg: 68.20, co: 38.40, fav: 20, money: 0, tourCard: false },
        { name: "Domosi, Andras Daniel", country: "hun", avg: 67.62, co: 28.00, fav: 16, money: 0, tourCard: false },
        { name: "Vojtek, Tamas", country: "hun", avg: 65.98, co: 15.0, fav: 20, money: 0, tourCard: false },
        { name: "Honti, Mark", country: "hun", avg: 65.35, co: 48.50, fav: 16, money: 0, tourCard: false },
        { name: "Pataki, Andras", country: "hun", avg: 64.43, co: 32.67, fav: 20, money: 0, tourCard: false },
        { name: "Berki, Gabor", country: "hun", avg: 64.28, co: 13.00, fav: 16, money: 0, tourCard: false },
        { name: "Olah, Sandor Balazs", country: "hun", avg: 63.54, co: 44.00, fav: 20, money: 0, tourCard: false },
        { name: "Daranyi, Zoltan", country: "hun", avg: 62.51, co: 30.75, fav: 16, money: 0, tourCard: false },
        { name: "Uveges, Kristof", country: "hun", avg: 59.30, co: 15.0, fav: 20, money: 0, tourCard: false },
        { name: "Haluska, Benedek", country: "hun", avg: 55.67, co: 15.0, fav: 16, money: 0, tourCard: false },
        { name: "Moricz, Istvan", country: "hun", avg: 35.58, co: 15.0, fav: 20, money: 0, tourCard: false },
        { name: "Sarai, Levente", country: "hun", avg: 82.28, co: 56.04, fav: 20, money: 0, tourCard: false },
        { name: "Bagi, Janos", country: "hun", avg: 82.28, co: 43.00, fav: 20, money: 0, tourCard: false },
        { name: "Balogh, Bela", country: "hun", avg: 79.97, co: 40.67, fav: 16, money: 0, tourCard: false },
        { name: "Petelen, Andras", country: "hun", avg: 78.45, co: 35.00, fav: 20, money: 0, tourCard: false },
        { name: "Rucska, Jozsef", country: "hun", avg: 77.35, co: 41.46, fav: 16, money: 0, tourCard: false },
        { name: "Torda, Tibor", country: "hun", avg: 74.95, co: 33.50, fav: 20, money: 0, tourCard: false },
        { name: "Antal, Gergely", country: "hun", avg: 73.49, co: 44.50, fav: 16, money: 0, tourCard: false },
        { name: "Nagy, Mark", country: "hun", avg: 73.21, co: 51.00, fav: 20, money: 0, tourCard: false },
        { name: "Biro, Milan", country: "hun", avg: 72.20, co: 39.11, fav: 16, money: 0, tourCard: false },
        { name: "Felfoldi, Adam", country: "hun", avg: 71.06, co: 32.47, fav: 20, money: 0, tourCard: false },
        { name: "Ferenc, Zsebedics", country: "hun", avg: 69.10, co: 40.50, fav: 16, money: 0, tourCard: false },
        { name: "Farkas, Gergo", country: "hun", avg: 67.98, co: 50.25, fav: 20, money: 0, tourCard: false },
        { name: "Gyuriczky, Adrian", country: "hun", avg: 67.64, co: 41.00, fav: 16, money: 0, tourCard: false },
        { name: "Farkas, Roland", country: "hun", avg: 65.83, co: 15.0, fav: 20, money: 0, tourCard: false },
        { name: "Balla, Gabor", country: "hun", avg: 64.90, co: 20.00, fav: 16, money: 0, tourCard: false },
        { name: "Ruska, Zoltan", country: "hun", avg: 63.34, co: 63.00, fav: 20, money: 0, tourCard: false },
        { name: "Czotter, Gabor", country: "hun", avg: 62.43, co: 36.00, fav: 16, money: 0, tourCard: false },
        { name: "Biro, Pal", country: "hun", avg: 61.15, co: 15.0, fav: 20, money: 0, tourCard: false },
        { name: "Erl, Attila", country: "hun", avg: 59.55, co: 47.33, fav: 16, money: 0, tourCard: false },
        { name: "Szots, Istvan", country: "hun", avg: 58.96, co: 2.00, fav: 20, money: 0, tourCard: false },
        { name: "Viranyi, Andras", country: "hun", avg: 58.89, co: 15.0, fav: 16, money: 0, tourCard: false },
        { name: "Papp, Gabor", country: "hun", avg: 57.38, co: 29.00, fav: 20, money: 0, tourCard: false },
        { name: "Skornyak, Daniel", country: "hun", avg: 56.88, co: 15.0, fav: 16, money: 0, tourCard: false },
        { name: "Acs, Gergely", country: "hun", avg: 53.80, co: 15.0, fav: 20, money: 0, tourCard: false },
        { name: "Plosz, Adam", country: "hun", avg: 45.0, co: 20.00, fav: 20, money: 0, tourCard: false },
        { name: "Goenka, Ankit", country: "ind", avg: 67.93, co: 43.95, fav: 20, money: 0, tourCard: false },
        { name: "Roy, Sangam Kumar", country: "ind", avg: 67.92, co: 36.65, fav: 20, money: 0, tourCard: false },
        { name: "Goel, Mohan Kumar", country: "ind", avg: 63.75, co: 35.26, fav: 20, money: 0, tourCard: false },
        { name: "Suohu, Vikehelie", country: "ind", avg: 62.83, co: 34.10, fav: 20, money: 0, tourCard: false },
        { name: "Limatoshi, Limatoshi", country: "ind", avg: 62.25, co: 33.67, fav: 20, money: 0, tourCard: false },
        { name: "Agarwal, Shashank", country: "ind", avg: 61.74, co: 36.57, fav: 20, money: 0, tourCard: false },
        { name: "Kothari, Vikash", country: "ind", avg: 59.66, co: 28.53, fav: 20, money: 0, tourCard: false },
        { name: "Dixit, Shailender", country: "ind", avg: 58.47, co: 34.41, fav: 20, money: 0, tourCard: false },
        { name: "Sha, Apurba", country: "ind", avg: 57.25, co: 39.76, fav: 20, money: 0, tourCard: false },
        { name: "Daga, Chirag", country: "ind", avg: 56.90, co: 34.69, fav: 20, money: 0, tourCard: false },
        { name: "Dalmiya, Harsh", country: "ind", avg: 56.38, co: 29.47, fav: 20, money: 0, tourCard: false },
        { name: "Sadani, Mudit", country: "ind", avg: 55.93, co: 32.92, fav: 20, money: 0, tourCard: false },
        { name: "Chauhan, Piyush", country: "ind", avg: 55.62, co: 26.21, fav: 20, money: 0, tourCard: false },
        { name: "Sayed, Ashfaque", country: "ind", avg: 55.26, co: 31.15, fav: 20, money: 0, tourCard: false },
        { name: "Singh, Akhand Pratap", country: "ind", avg: 55.17, co: 34.97, fav: 20, money: 0, tourCard: false },
        { name: "Bhat, Ravi", country: "ind", avg: 55.12, co: 42.75, fav: 20, money: 0, tourCard: false },
        { name: "Mehta, Vishal", country: "ind", avg: 54.51, co: 23.54, fav: 20, money: 0, tourCard: false },
        { name: "Chheda, Raj", country: "ind", avg: 54.25, co: 24.35, fav: 20, money: 0, tourCard: false },
        { name: "Shah, Sashank", country: "ind", avg: 54.19, co: 35.43, fav: 20, money: 0, tourCard: false },
        { name: "Mehta, Viral D", country: "ind", avg: 53.72, co: 35.83, fav: 20, money: 0, tourCard: false },
        { name: "Paul, Arijit", country: "ind", avg: 53.06, co: 32.85, fav: 20, money: 0, tourCard: false },
        { name: "Kapoor, Raahat", country: "ind", avg: 52.91, co: 34.88, fav: 20, money: 0, tourCard: false },
        { name: "Bosmia, Mahi", country: "ind", avg: 52.68, co: 32.71, fav: 20, money: 0, tourCard: false },
        { name: "Datta, Abhishek", country: "ind", avg: 52.47, co: 16.00, fav: 20, money: 0, tourCard: false },
        { name: "Semou, Kezhaletuo", country: "ind", avg: 52.39, co: 29.38, fav: 20, money: 0, tourCard: false },
        { name: "Kothari, Aayush", country: "ind", avg: 52.07, co: 20.62, fav: 20, money: 0, tourCard: false },
        { name: "Jhajharia, Vikash", country: "ind", avg: 51.47, co: 29.17, fav: 20, money: 0, tourCard: false },
        { name: "Hawaldar, Amar Pratapsinh", country: "ind", avg: 51.24, co: 39.58, fav: 20, money: 0, tourCard: false },
        { name: "Goenka, Vidhul", country: "ind", avg: 51.01, co: 24.54, fav: 20, money: 0, tourCard: false },
        { name: "Tiruvasu, Phalgun", country: "ind", avg: 50.98, co: 33.13, fav: 20, money: 0, tourCard: false },
        { name: "Giri, Suraj", country: "ind", avg: 50.82, co: 23.94, fav: 20, money: 0, tourCard: false },
        { name: "Vegad, Heet", country: "ind", avg: 50.10, co: 34.07, fav: 20, money: 0, tourCard: false },
        { name: "Shaw, Deep Kumar", country: "ind", avg: 49.84, co: 12.33, fav: 20, money: 0, tourCard: false },
        { name: "Fernandes, Jeremy", country: "ind", avg: 49.73, co: 30.43, fav: 20, money: 0, tourCard: false },
        { name: "Sen, Pushan Kumar", country: "ind", avg: 49.56, co: 27.80, fav: 20, money: 0, tourCard: false },
        { name: "Dhanuka, Abhisek", country: "ind", avg: 49.49, co: 29.46, fav: 20, money: 0, tourCard: false },
        { name: "Bajpai, Ashwray", country: "ind", avg: 48.92, co: 25.50, fav: 20, money: 0, tourCard: false },
        { name: "Haque, MD Farmanul", country: "ind", avg: 48.71, co: 25.27, fav: 20, money: 0, tourCard: false },
        { name: "Bhattacharya, Laksh", country: "ind", avg: 48.70, co: 32.44, fav: 20, money: 0, tourCard: false },
        { name: "Chadha, Ravi", country: "ind", avg: 48.63, co: 27.00, fav: 20, money: 0, tourCard: false },
        { name: "Kajaria, Neiraj", country: "ind", avg: 48.28, co: 7.33, fav: 20, money: 0, tourCard: false },
        { name: "Sumi, Viboto H", country: "ind", avg: 47.92, co: 27.71, fav: 20, money: 0, tourCard: false },
        { name: "Singh, Avijit Arun", country: "ind", avg: 47.89, co: 30.36, fav: 20, money: 0, tourCard: false },
        { name: "Dasgupta, Saubhadra", country: "ind", avg: 47.56, co: 31.45, fav: 20, money: 0, tourCard: false },
        { name: "Kapur, Ashish", country: "ind", avg: 47.38, co: 38.33, fav: 20, money: 0, tourCard: false },
        { name: "Zatsu, Kikruneizo", country: "ind", avg: 47.20, co: 20.92, fav: 20, money: 0, tourCard: false },
        { name: "Khan, Aiyan", country: "ind", avg: 46.92, co: 23.64, fav: 20, money: 0, tourCard: false },
        { name: "Sondhi, Aman", country: "ind", avg: 46.89, co: 36.50, fav: 20, money: 0, tourCard: false },
        { name: "Sultana, Rima", country: "ind", avg: 46.66, co: 22.29, fav: 20, money: 0, tourCard: false },
        { name: "Ghaznavi, Daniel", country: "ind", avg: 46.59, co: 33.43, fav: 20, money: 0, tourCard: false },
        { name: "Bhattacharya, Satadru", country: "ind", avg: 45.84, co: 32.00, fav: 20, money: 0, tourCard: false },
        { name: "Thakker, Dishant", country: "ind", avg: 45.84, co: 43.33, fav: 20, money: 0, tourCard: false },
        { name: "Chowdhary, Abdul Wahab", country: "ind", avg: 45.65, co: 35.00, fav: 20, money: 0, tourCard: false },
        { name: "Sanyal, Rohit", country: "ind", avg: 45.59, co: 21.26, fav: 20, money: 0, tourCard: false },
        { name: "Angami, Simon Kelio", country: "ind", avg: 45.41, co: 17.60, fav: 20, money: 0, tourCard: false },
        { name: "Rahman, Tamim", country: "ind", avg: 45.32, co: 0, fav: 20, money: 0, tourCard: false },
        { name: "Raha, Arnab", country: "ind", avg: 45.12, co: 30.50, fav: 20, money: 0, tourCard: false },
        { name: "Shroff, Gopal", country: "ind", avg: 45.11, co: 0, fav: 20, money: 0, tourCard: false },
        { name: "Bhatt, Nachiket", country: "ind", avg: 45.07, co: 27.40, fav: 20, money: 0, tourCard: false },
        { name: "Singh, Kumarial Kunal", country: "ind", avg: 44.58, co: 50.00, fav: 20, money: 0, tourCard: false },
        { name: "Banerji, Tia", country: "ind", avg: 44.55, co: 22.80, fav: 20, money: 0, tourCard: false },
        { name: "Roy, Rajdeb", country: "ind", avg: 44.52, co: 23.00, fav: 20, money: 0, tourCard: false },
        { name: "Mittal, Vijay", country: "ind", avg: 44.12, co: 43.60, fav: 20, money: 0, tourCard: false },
        { name: "Ganeriwalla, Rohit", country: "ind", avg: 43.46, co: 28.67, fav: 20, money: 0, tourCard: false },
        { name: "Todi, Sanjay", country: "ind", avg: 43.44, co: 27.45, fav: 20, money: 0, tourCard: false },
        { name: "Agarwalla, Yash", country: "ind", avg: 43.40, co: 34.00, fav: 20, money: 0, tourCard: false },
        { name: "Malakar, Goutam", country: "ind", avg: 43.35, co: 27.67, fav: 20, money: 0, tourCard: false },
        { name: "Doshi, Tejash", country: "ind", avg: 43.27, co: 26.44, fav: 20, money: 0, tourCard: false },
        { name: "Casyab, Ravi", country: "ind", avg: 43.20, co: 28.00, fav: 20, money: 0, tourCard: false },
        { name: "Chokhani, Manasvi", country: "ind", avg: 43.00, co: 0, fav: 20, money: 0, tourCard: false },
        { name: "Singh, Vijay", country: "ind", avg: 42.71, co: 27.13, fav: 20, money: 0, tourCard: false },
        { name: "Mulay, Atharva", country: "ind", avg: 42.59, co: 27.00, fav: 20, money: 0, tourCard: false },
        { name: "Singh, Amandeep", country: "ind", avg: 42.46, co: 11.00, fav: 20, money: 0, tourCard: false },
        { name: "Bhasin, Vivek", country: "ind", avg: 42.19, co: 0, fav: 20, money: 0, tourCard: false },
        { name: "Chakraborty, Ayush", country: "ind", avg: 42.07, co: 35.00, fav: 20, money: 0, tourCard: false },
        { name: "Agarwal, Sarvesh", country: "ind", avg: 42.06, co: 0, fav: 20, money: 0, tourCard: false },
        { name: "Khanna, Jacqueline Sharon", country: "ind", avg: 42.01, co: 41.50, fav: 20, money: 0, tourCard: false },
        { name: "Malhotra, Samit", country: "ind", avg: 41.50, co: 0, fav: 20, money: 0, tourCard: false },
        { name: "Gohil, Sanjana", country: "ind", avg: 41.39, co: 0, fav: 20, money: 0, tourCard: false },
        { name: "Sayed, Izhaan Ashfaque", country: "ind", avg: 40.96, co: 36.14, fav: 20, money: 0, tourCard: false },
        { name: "Kothari, Kriti Chugh", country: "ind", avg: 40.95, co: 20.78, fav: 20, money: 0, tourCard: false },
        { name: "Bansal, Rajiv", country: "ind", avg: 40.76, co: 15.50, fav: 20, money: 0, tourCard: false },
        { name: "Panja, Rahul", country: "ind", avg: 40.75, co: 19.45, fav: 20, money: 0, tourCard: false },
        { name: "Varma, Mukta", country: "ind", avg: 40.38, co: 0, fav: 20, money: 0, tourCard: false },
        { name: "Sharma, Harshvardhan", country: "ind", avg: 40.36, co: 25.80, fav: 20, money: 0, tourCard: false },
        { name: "Kaur, Gagandeep", country: "ind", avg: 40.35, co: 28.33, fav: 20, money: 0, tourCard: false },
        { name: "Singh, Baljit", country: "ind", avg: 40.00, co: 21.80, fav: 20, money: 0, tourCard: false },
        { name: "Gupta, Sachin Kumar", country: "ind", avg: 39.51, co: 20.00, fav: 20, money: 0, tourCard: false },
        { name: "Pai, S Viswanath", country: "ind", avg: 39.41, co: 54.00, fav: 20, money: 0, tourCard: false },
        { name: "Shah, Ashwin", country: "ind", avg: 39.27, co: 0, fav: 20, money: 0, tourCard: false },
        { name: "Agarwal, Ashish", country: "ind", avg: 38.93, co: 0, fav: 20, money: 0, tourCard: false },
        { name: "Sardar, Priyanka", country: "ind", avg: 38.93, co: 23.20, fav: 20, money: 0, tourCard: false },
        { name: "Meyase, Khrielhoutuo", country: "ind", avg: 38.83, co: 13.67, fav: 20, money: 0, tourCard: false },
        { name: "Agarwal, Vivek", country: "ind", avg: 38.46, co: 0, fav: 20, money: 0, tourCard: false },
        { name: "Nathani, Manoj", country: "ind", avg: 38.46, co: 51.00, fav: 20, money: 0, tourCard: false },
        { name: "White, Lorraine", country: "ind", avg: 38.39, co: 54.00, fav: 20, money: 0, tourCard: false },
        { name: "Gillausseyn, Stephanie", country: "ind", avg: 38.13, co: 50.00, fav: 20, money: 0, tourCard: false },
        { name: "Kumawat, Tanay", country: "ind", avg: 38.06, co: 16.00, fav: 20, money: 0, tourCard: false },
        { name: "Hooper, Peter Andrew", country: "ind", avg: 37.66, co: 18.00, fav: 20, money: 0, tourCard: false },
        { name: "Sengupta, Anjan", country: "ind", avg: 37.60, co: 12.67, fav: 20, money: 0, tourCard: false },
        { name: "Rathod, Amit Kumar", country: "ind", avg: 37.56, co: 15.33, fav: 20, money: 0, tourCard: false },
        { name: "Agarwalla, Shubhra", country: "ind", avg: 37.49, co: 22.67, fav: 20, money: 0, tourCard: false },
        { name: "Rajput, Mitesh", country: "ind", avg: 37.43, co: 0, fav: 20, money: 0, tourCard: false },
        { name: "Khandelwal, Vivek", country: "ind", avg: 37.38, co: 49.00, fav: 20, money: 0, tourCard: false },
        { name: "Chokhani, Apurv", country: "ind", avg: 37.32, co: 15.33, fav: 20, money: 0, tourCard: false },
        { name: "Bansal, Alok", country: "ind", avg: 37.17, co: 25.33, fav: 20, money: 0, tourCard: false },
        { name: "Agarwal, Harshavardhan", country: "ind", avg: 37.03, co: 14.67, fav: 20, money: 0, tourCard: false },
        { name: "Agarwal, Swati", country: "ind", avg: 36.98, co: 0, fav: 20, money: 0, tourCard: false },
        { name: "Suraiya, Neha", country: "ind", avg: 36.92, co: 25.40, fav: 20, money: 0, tourCard: false },
        { name: "Garg, Vinamra", country: "ind", avg: 36.84, co: 9.00, fav: 20, money: 0, tourCard: false },
        { name: "Bose, Romita", country: "ind", avg: 36.19, co: 0, fav: 20, money: 0, tourCard: false },
        { name: "Suohu, Kezhabu", country: "ind", avg: 36.12, co: 17.29, fav: 20, money: 0, tourCard: false },
        { name: "Kushwaha, Muskan Kumari", country: "ind", avg: 35.86, co: 24.67, fav: 20, money: 0, tourCard: false },
        { name: "Gupta, Simi", country: "ind", avg: 35.68, co: 24.67, fav: 20, money: 0, tourCard: false },
        { name: "Mitra, Ranit", country: "ind", avg: 35.66, co: 18.63, fav: 20, money: 0, tourCard: false },
        { name: "Kapur, Vijay", country: "ind", avg: 35.59, co: 46.00, fav: 20, money: 0, tourCard: false },
        { name: "Thapa, Karishma", country: "ind", avg: 35.54, co: 29.33, fav: 20, money: 0, tourCard: false },
        { name: "Harlalka, Srivar", country: "ind", avg: 35.53, co: 26.00, fav: 20, money: 0, tourCard: false },
        { name: "Dugar, Priyanka", country: "ind", avg: 35.32, co: 5.50, fav: 20, money: 0, tourCard: false },
        { name: "Gandhi, Nirmal", country: "ind", avg: 35.03, co: 22.44, fav: 20, money: 0, tourCard: false },
        { name: "Kucheria, Sangeeta", country: "ind", avg: 34.96, co: 28.75, fav: 20, money: 0, tourCard: false },
        { name: "Mandapaka, Bharati", country: "ind", avg: 34.77, co: 17.00, fav: 20, money: 0, tourCard: false },
        { name: "Arora, Rohit", country: "ind", avg: 34.73, co: 23.00, fav: 20, money: 0, tourCard: false },
        { name: "Agarwal, Abnish", country: "ind", avg: 34.70, co: 48.00, fav: 20, money: 0, tourCard: false },
        { name: "Sikri, Manish", country: "ind", avg: 34.47, co: 16.00, fav: 20, money: 0, tourCard: false },
        { name: "Basu, Jayanta", country: "ind", avg: 34.28, co: 24.00, fav: 20, money: 0, tourCard: false },
        { name: "Bhatti, Firdausbanu", country: "ind", avg: 33.85, co: 16.33, fav: 20, money: 0, tourCard: false },
        { name: "Anjum, Nilofar", country: "ind", avg: 33.83, co: 16.00, fav: 20, money: 0, tourCard: false },
        { name: "Singh, Inder Raj", country: "ind", avg: 33.57, co: 18.80, fav: 20, money: 0, tourCard: false },
        { name: "Saini, Dimple", country: "ind", avg: 33.54, co: 0, fav: 20, money: 0, tourCard: false },
        { name: "Srivastava, Manisha", country: "ind", avg: 33.04, co: 21.00, fav: 20, money: 0, tourCard: false },
        { name: "Majumder, Arpan", country: "ind", avg: 33.02, co: 33.50, fav: 20, money: 0, tourCard: false },
        { name: "Bosmia, Asha", country: "ind", avg: 32.53, co: 0, fav: 20, money: 0, tourCard: false },
        { name: "Makwana, Chandrika", country: "ind", avg: 32.23, co: 11.75, fav: 20, money: 0, tourCard: false },
        { name: "Ceejo, Princy", country: "ind", avg: 32.20, co: 5.50, fav: 20, money: 0, tourCard: false },
        { name: "Zaveri, Rinju", country: "ind", avg: 31.19, co: 0, fav: 20, money: 0, tourCard: false },
        { name: "Khalkho, Ajay", country: "ind", avg: 31.15, co: 16.00, fav: 20, money: 0, tourCard: false },
        { name: "Das, Ayan", country: "ind", avg: 31.00, co: 27.56, fav: 20, money: 0, tourCard: false },
        { name: "Pathak, Siddharth", country: "ind", avg: 30.69, co: 0, fav: 20, money: 0, tourCard: false },
        { name: "Poddar, Kavita", country: "ind", avg: 30.40, co: 0, fav: 20, money: 0, tourCard: false },
        { name: "Vora, Mahin", country: "ind", avg: 30.32, co: 13.00, fav: 20, money: 0, tourCard: false },
        { name: "Aal, Jatan", country: "ind", avg: 29.89, co: 13.57, fav: 20, money: 0, tourCard: false },
        { name: "Agarwal, Amit", country: "ind", avg: 29.64, co: 10.00, fav: 20, money: 0, tourCard: false },
        { name: "Bagaria, Rajendra", country: "ind", avg: 29.27, co: 8.00, fav: 20, money: 0, tourCard: false },
        { name: "Vanol, Lakshaman", country: "ind", avg: 29.26, co: 16.50, fav: 20, money: 0, tourCard: false },
        { name: "Makwana, Nidhi", country: "ind", avg: 28.71, co: 0, fav: 20, money: 0, tourCard: false },
        { name: "Makani, Sahil", country: "ind", avg: 28.21, co: 4.00, fav: 20, money: 0, tourCard: false },
        { name: "Kundalia, Vipul", country: "ind", avg: 28.13, co: 19.00, fav: 20, money: 0, tourCard: false },
        { name: "Gohil, Jagruti", country: "ind", avg: 27.84, co: 4.00, fav: 20, money: 0, tourCard: false },
        { name: "Gooptu, Abhishek", country: "ind", avg: 27.46, co: 0, fav: 20, money: 0, tourCard: false },
        { name: "Rathod, Dhruvrajsinh", country: "ind", avg: 26.88, co: 6.00, fav: 20, money: 0, tourCard: false },
        { name: "Mansata, Ashok R", country: "ind", avg: 26.52, co: 16.00, fav: 20, money: 0, tourCard: false },
        { name: "Das, Nayanranjan", country: "ind", avg: 25.62, co: 3.00, fav: 20, money: 0, tourCard: false },
        { name: "Hooper, Bandana", country: "ind", avg: 25.58, co: 5.00, fav: 20, money: 0, tourCard: false }
        ];

        const FLAG_MAP = {
            "hun": "hu", "eng": "gb-eng", "sco": "gb-sct", "wal": "gb-wls", "nir": "gb-nir", "gbr": "gb",
            "aus": "au", "bel": "be", "ger": "de", "de": "de", "ned": "nl", "nl": "nl", "pol": "pl", "usa": "us", "esp": "es", "ind": "in", "jpn": "jp", "sgp": "sg", "swe": "se", "cro": "hr", "fra": "fr", "ita": "it", "irl": "ie", "fin": "fi", "can": "ca", "cze": "cz", "den": "dk", "phi": "ph", "hkg": "hk", "chn": "cn", "aut": "at", "lat": "lv", "nzl": "nz", "sui": "ch", "lit": "lt", "ltu": "lt", "por": "pt", "arg": "ar", "bra": "br",
            "tur": "tr", "ukr": "ua", "rsa": "za", "rou": "ro", "svk": "sk", "slo": "si", "svn": "si", "gre": "gr", "isl": "is", "isr": "il", "lux": "lu", "cyp": "cy", "ken": "ke", "uga": "ug",
            "nor": "no", "est": "ee", "mex": "mx", "kor": "kr", "tha": "th", "vie": "vn", "ken": "ke"
        };
        // Region√°lis 8
        const REGION_MAP = {
            asia: ["jpn", "chn", "hkg", "tha", "sin", "mas", "ind", "phi", "kor", "uae", "qat", "ksa"],
            nordic: ["den", "swe", "nor", "fin", "isl", "est", "lat", "ltu"],
            america: ["usa", "can", "mex"],
            oceania: ["aus", "nzl"],
            europe: ["eng", "ger", "nl", "bel", "fra", "aut", "cze", "pol", "sui", "esp", "ita", "sco", "wal", "irl", "svk"],
            africa: ["rsa", "zim", "ken", "uga", "moz", "tan", "bwa", "egi", "mar", "nig", "gha", "ivr", "cmr"],
            india: ["ind"]
        };
        REGION_MAP.east = ["hun", "cze", "svk", "pol", "rou", "bul", "srb", "cro"];
        const WORLD_SERIES_POINTS = {
            16: 1,   // R1
            8: 2,    // QF
            4: 3,    // SF
            2: 5,    // Final
            1: 8     // Winner
        };


        const FLAG_URL = "https://flagcdn.com/w80/";
        const SOUND_180 = new Audio('180.mp3');
        const SOUND_167 = new Audio('167.MP3');
        const SOUND_BIG_CHECKOUT = new Audio('bigcheckout.MP3');
        const SOUND_INTRO = new Audio('intro.MP3');
        const SOUND_OUTRO = new Audio('outromusic.MP3');
        let PLAYERS_DB = [];

        // Country to capital & full name mapping
        const COUNTRY_CAPITALS = {
            "hun": { capital: "Budapest", fullName: "Hungary", region: "east" },
            "eng": { capital: "London", fullName: "England", region: "uk" },
            "sco": { capital: "Edinburgh", fullName: "Scotland", region: "uk" },
            "wal": { capital: "Cardiff", fullName: "Wales", region: "uk" },
            "nir": { capital: "Belfast", fullName: "Northern Ireland", region: "uk" },
            "gbr": { capital: "London", fullName: "Great Britain", region: "uk" },
            "irl": { capital: "Dublin", fullName: "Ireland", region: "uk" },
            "aus": { capital: "Sydney", fullName: "Australia", region: "oceania" },
            "bel": { capital: "Brussels", fullName: "Belgium", region: "eu" },
            "ger": { capital: "Berlin", fullName: "Germany", region: "eu" },
            "de": { capital: "Berlin", fullName: "Germany", region: "eu" },
            "ned": { capital: "Amsterdam", fullName: "Netherlands", region: "eu" },
            "nl": { capital: "Amsterdam", fullName: "Netherlands", region: "eu" },
            "pol": { capital: "Warsaw", fullName: "Poland", region: "east" },
            "usa": { capital: "Washington D.C.", fullName: "United States", region: "america" },
            "esp": { capital: "Madrid", fullName: "Spain", region: "eu" },
            "ind": { capital: "New Delhi", fullName: "India", region: "india" },
            "jpn": { capital: "Tokyo", fullName: "Japan", region: "asia" },
            "sgp": { capital: "Singapore", fullName: "Singapore", region: "asia" },
            "swe": { capital: "Stockholm", fullName: "Sweden", region: "nordic" },
            "cro": { capital: "Zagreb", fullName: "Croatia", region: "east" },
            "fra": { capital: "Paris", fullName: "France", region: "eu" },
            "ita": { capital: "Rome", fullName: "Italy", region: "eu" },
            "fin": { capital: "Helsinki", fullName: "Finland", region: "nordic" },
            "can": { capital: "Ottawa", fullName: "Canada", region: "america" },
            "cze": { capital: "Prague", fullName: "Czech Republic", region: "east" },
            "den": { capital: "Copenhagen", fullName: "Denmark", region: "nordic" },
            "phi": { capital: "Manila", fullName: "Philippines", region: "asia" },
            "hkg": { capital: "Hong Kong", fullName: "Hong Kong", region: "asia" },
            "chn": { capital: "Beijing", fullName: "China", region: "asia" },
            "aut": { capital: "Vienna", fullName: "Austria", region: "eu" },
            "lat": { capital: "Riga", fullName: "Latvia", region: "nordic" },
            "nzl": { capital: "Wellington", fullName: "New Zealand", region: "oceania" },
            "sui": { capital: "Berne", fullName: "Switzerland", region: "eu" },
            "lit": { capital: "Vilnius", fullName: "Lithuania", region: "nordic" },
            "ltu": { capital: "Vilnius", fullName: "Lithuania", region: "nordic" },
            "por": { capital: "Lisbon", fullName: "Portugal", region: "eu" },
            "arg": { capital: "Buenos Aires", fullName: "Argentina", region: "america" },
            "bra": { capital: "Bras√≠lia", fullName: "Brazil", region: "america" },
            "tur": { capital: "Ankara", fullName: "Turkey", region: "eu" },
            "ukr": { capital: "Kyiv", fullName: "Ukraine", region: "east" },
            "rsa": { capital: "Pretoria", fullName: "South Africa", region: "africa" },
            "rou": { capital: "Bucharest", fullName: "Romania", region: "east" },
            "svk": { capital: "Bratislava", fullName: "Slovakia", region: "east" },
            "slo": { capital: "Ljubljana", fullName: "Slovenia", region: "east" },
            "svn": { capital: "Ljubljana", fullName: "Slovenia", region: "east" },
            "gre": { capital: "Athens", fullName: "Greece", region: "eu" },
            "isl": { capital: "Reykjavik", fullName: "Iceland", region: "nordic" },
            "isr": { capital: "Jerusalem", fullName: "Israel", region: "eu" },
            "lux": { capital: "Luxembourg City", fullName: "Luxembourg", region: "eu" },
            "cyp": { capital: "Nicosia", fullName: "Cyprus", region: "eu" },
            "ken": { capital: "Nairobi", fullName: "Kenya", region: "africa" },
            "uga": { capital: "Kampala", fullName: "Uganda", region: "africa" },
            "nor": { capital: "Oslo", fullName: "Norway", region: "nordic" },
            "est": { capital: "Tallinn", fullName: "Estonia", region: "nordic" },
            "mex": { capital: "Mexico City", fullName: "Mexico", region: "america" },
            "kor": { capital: "Seoul", fullName: "South Korea", region: "asia" },
            "tha": { capital: "Bangkok", fullName: "Thailand", region: "asia" },
            "vie": { capital: "Hanoi", fullName: "Vietnam", region: "asia" },
            "zim": { capital: "Harare", fullName: "Zimbabwe", region: "africa" },
            "moz": { capital: "Maputo", fullName: "Mozambique", region: "africa" },
            "tan": { capital: "Dar es Salaam", fullName: "Tanzania", region: "africa" },
            "bwa": { capital: "Gaborone", fullName: "Botswana", region: "africa" },
            "egi": { capital: "Cairo", fullName: "Egypt", region: "africa" },
            "mar": { capital: "Rabat", fullName: "Morocco", region: "africa" },
            "nig": { capital: "Abuja", fullName: "Nigeria", region: "africa" },
            "gha": { capital: "Accra", fullName: "Ghana", region: "africa" },
            "ivr": { capital: "Yamoussoukro", fullName: "Ivory Coast", region: "africa" },
            "cmr": { capital: "Yaound√©", fullName: "Cameroon", region: "africa" },
            "sin": { capital: "Singapore", fullName: "Singapore", region: "asia" },
            "mas": { capital: "Kuala Lumpur", fullName: "Malaysia", region: "asia" },
            "uae": { capital: "Abu Dhabi", fullName: "United Arab Emirates", region: "asia" },
            "qat": { capital: "Doha", fullName: "Qatar", region: "asia" },
            "ksa": { capital: "Riyadh", fullName: "Saudi Arabia", region: "asia" },
            "bul": { capital: "Sofia", fullName: "Bulgaria", region: "east" },
            "srb": { capital: "Belgrade", fullName: "Serbia", region: "east" }
        };
        const HOST_NATION = {
            501: "pol",  // Poland Darts Open
            502: "ger",  // European Darts Trophy
            503: "bel",  // Belgian Darts Open
            504: "ger",  // German Darts Grand Prix
            505: "ger",  // European Darts Grand Prix
            506: "aut",  // Austrian Darts Open
            37: "pol",   // Poland Darts Open
            45: "ger",   // European Darts Trophy
            55: "bel",   // Belgian Darts Open
            65: "ger",   // German Darts Grand Prix
            78: "ger",   // European Darts Grand Prix
            90: "aut",   // Austrian Darts Trophy
            106: "ger",   // International Darts Open
            109: "ger",   // Baltic Sea Darts Open
            123: "svk",   // Slovak Darts Open
            127: "ger",   // European Darts Open
            148: "hun",   // Hungarian Darts Trophy
            149: "cze",   // Czech Darts Open
            158: "bel",   // Flanders Darts Open
            172: "sui",   // Swiss Darts Trophy
            173: "ned"    // Dutch Darts Championship
        };



        const getFlagUrl = (code) => {
            if (!code) return FLAG_URL + "unknown.png";
            return FLAG_URL + (FLAG_MAP[code.toLowerCase()] || code.toLowerCase()) + ".png";
        };

        const ROUND_FORMATS = {
            'masters': {
                L16: 6, QF: 6, SF: 8, F: 8
            },
            'major': {
                QF: 10, SF: 10, F: 11
            },
            'minor': {
                L32: 6, L16: 6, QF: 6, SF: 7, F: 8
            },
            'matchplay': {
                L32: 10, L16: 11, QF: 16, SF: 17, F: 18
            },
            'masters-final': {
                L32: 6, L16: 6, QF: 10, SF: 11, F: 11
            },
            'grandprix': {
                L32: 2, L16: 3, QF: 3, SF: 5, F: 6
            },
            'europeanf': {
                L32: 6, L16: 6, QF: 10, SF: 11, F: 11
            },
            'players': {
                L128: 6, L64: 6, L32: 6, L16: 6, QF: 6, SF: 7, F: 8
            },
            'challenge': {
                L128: 5, L64: 5, L32: 5, L16: 5, QF: 5, SF: 6, F: 6
            },
            'grandslam': {
                Group: 5, L16: 10, QF: 16, SF: 16, F: 16
            },
            'playersf': {
                L64: 6, L32: 6, L16: 10, QF: 10, SF: 11, F: 11
            },
            'q-school': {
                L256: 5, L128: 5, L64: 5, L32: 5, L16: 5, QF: 5, SF: 6, F: 6
            },
            'world': {
                L128: 3, L64: 3, L32: 4, L16: 4, QF: 5, SF: 6, F: 7
            },
            'uk-open': {
                L128: 6, L64: 6, L32: 6, L16: 10, QF: 10, SF: 11, F: 11
            },
            'et-qual-tc': {
                L64: 6, L32: 6, L16: 6, QF: 6, SF: 7, F: 8
            },
            'et-host-nation': {
                QF: 6, SF: 7, F: 8
            },
            'et-east-european': {
                L16: 6, QF: 6, SF: 7, F: 8
            },
            'et-nordic-baltic': {
                L16: 6, QF: 6, SF: 7, F: 8
            },
            'ws-qual-tc': {
                L64: 6, L32: 6, L16: 6, QF: 6, SF: 7, F: 8
            },
            'gs-qual-tc': {
                L64: 6, L32: 6, L16: 6, QF: 6, SF: 7, F: 8
            },
            'wmasters-qual': {
                L64: 6, L32: 6, L16: 6, QF: 6, SF: 7, F: 8
            },
            'winmaudm': {
                // SETS mode (default 3 legs/set)
                L32_sets: 3, L16_sets: 4, QF_sets: 4, SF_sets: 5, F_sets: 6,
                // LEGS mode (used for season simulation with 2 legs/set)
                L32: 2, L16: 4, QF: 4, SF: 5, F: 6
            }
        };


        // ================= PRIZE MONEY STRUCTURE =================
        const PRIZE_STRUCTURE = {
            //MASTERS
            'masters': { 16: 1000, 8: 3000, 4: 5000, 2: 8000, 1: 12000 },
            //MASTERS-Final
            'masters-final': { 32: 5000, 16: 10000, 8: 17500, 4: 30000, 2: 60000, 1: 100000 },
            //Q-School
            'q-school': { 256: 0, 128: 0, 64: 0, 32: 0, 16: 0, 8: 0, 4: 0, 2: 0, 1: 0 },
            // European tour
            'minor': { 32: 2500, 16: 4000, 8: 6000, 4: 8500, 2: 12000, 1: 30000 },
            'major': { 128: 0, 64: 2500, 32: 5000, 16: 10000, 8: 20000, 4: 40000, 2: 80000, 1: 150000 },
            'world': { 128: 15000, 64: 25000, 32: 35000, 16: 60000, 8: 100000, 4: 200000, 2: 400000, 1: 1000000 },
            'players': { 128: 0, 64: 1000, 32: 2000, 16: 3000, 8: 5000, 4: 7500, 2: 10000, 1: 15000 },
            'challenge': { 128: 0, 64: 100, 32: 250, 16: 350, 8: 750, 4: 1000, 2: 2000, 1: 3000 },
            'uk-open': { 160: 0, 128: 1000, 96: 1500, 64: 2500, 32: 5000, 16: 10000, 8: 15000, 4: 30000, 2: 50000, 1: 110000 },
            'et-qual-tc': { 64: 0, 32: 0, 16: 0, 8: 0, 4: 0, 2: 0, 1: 0 },
            'et-host-nation': { 8: 0, 4: 0, 2: 0, 1: 0 },
            'et-east-european': { 16: 0, 8: 0, 4: 0, 2: 0, 1: 0 },
            'et-nordic-baltic': { 16: 0, 8: 0, 4: 0, 2: 0, 1: 0 },
            'ws-qual-tc': { 64: 0, 32: 0, 16: 0, 8: 0, 4: 0, 2: 0, 1: 0 },
            'gs-qual-tc': { 64: 0, 32: 0, 16: 0, 8: 0, 4: 0, 2: 0, 1: 0 },
            'wmasters-qual': { 64: 0, 32: 0, 16: 0, 8: 0, 4: 0, 2: 0, 1: 0 },
            'winmaudm': { 32: 5000, 16: 10000, 8: 17500, 4: 30000, 2: 50000, 1: 100000 },
            'matchplay': { 32: 10000, 16: 15000, 8: 30000, 4: 50000, 2: 100000, 1: 200000 },
            'europeanf': { 32: 7500, 16: 15000, 8: 25000, 4: 40000, 2: 60000, 1: 120000 },
            'grandprix': { 32: 7500, 16: 15000, 8: 25000, 4: 40000, 2: 60000, 1: 120000 },
            'playersf': { 64: 3000, 32: 6500, 16: 10000, 8: 20000, 4: 30000, 2: 60000, 1: 120000 },
            'grandslam': { 32: 5000, 16: 12250, 8: 25000, 4: 50000, 2: 70000, 1: 150000 },

        }

        function getRoundName(playersInRound) {
            return {
                256: "L256",
                128: "L128",
                64: "L64",
                32: "L32",
                16: "L16",
                8: "QF",
                4: "SF",
                2: "F"
            }[playersInRound];
        }

        // ================= PERSISTENCE =================
        window.Persistence = {
            // New prefix for V2 to prevent tangling with season saves
            prefix: 'pdcv2_',

            // Save completed tournament to history (autosave when tournament finishes)
            saveTournamentResult: (winner, runnerUp, tournamentName, bracketData) => {
                const history = JSON.parse(localStorage.getItem(Persistence.prefix + 'tournament_history') || '[]');
                const result = {
                    id: Date.now(),
                    name: tournamentName || Tournament.config.name || document.getElementById('tourn-event-name')?.value || 'CUSTOM TOURNAMENT',
                    winner: winner ? winner.name : 'Unknown',
                    runnerUp: runnerUp ? runnerUp.name : 'Unknown',
                    date: new Date().toISOString(),
                    eventType: Tournament.config.eventType || 'custom',
                    mode: Tournament.config.mode,
                    playerCount: Tournament.config.playerCount,
                    finalScore: bracketData && bracketData.length > 0 ?
                        bracketData[bracketData.length - 1][0]?.score?.join(' - ') : null
                };
                history.push(result);
                localStorage.setItem(Persistence.prefix + 'tournament_history', JSON.stringify(history));
                console.log('[Autosave] Tournament result saved:', result);
                return result;
            },

            save: () => {
                if (typeof PLAYERS_DB !== 'undefined') {
                    const states = PLAYERS_DB.map(p => ({ n: p.name, f: p.form, ft: p.fatigue }));
                    localStorage.setItem(Persistence.prefix + 'player_states', JSON.stringify(states));
                }

                if (App.players && App.players.length > 0) localStorage.setItem(Persistence.prefix + 'players', JSON.stringify(App.players));
                localStorage.setItem(Persistence.prefix + 'match_state', JSON.stringify(App.matchState));
                localStorage.setItem(Persistence.prefix + 'app_config', JSON.stringify(App.config));

                const tournName = document.getElementById('tourn-event-name')?.value || Tournament.config.name || 'CUSTOM TOURNAMENT';

                if (Tournament.state.active) {
                    const cleanBracket = Tournament.state.bracketData.map(round =>
                        round.map(m => ({
                            p1: m.p1, p2: m.p2, winner: m.winner, score: m.score, averages: m.averages
                        }))
                    );

                    let cleanGroupMatches = null;
                    if (Tournament.state.groupMatches && Tournament.state.groupMatches.length > 0) {
                        cleanGroupMatches = Tournament.state.groupMatches.map(group =>
                            group.map(m => ({
                                id: m.id, group: m.group, p1: m.p1, p2: m.p2,
                                winner: m.winner, score: m.score, averages: m.averages
                            }))
                        );
                    }

                    localStorage.setItem(Persistence.prefix + 'tourn_state', JSON.stringify({
                        active: true,
                        bracketData: cleanBracket,
                        currentActiveRound: Tournament.state.currentActiveRound,
                        viewingRound: Tournament.state.viewingRound,
                        selectedPlayerIndices: Array.from(Tournament.state.selectedPlayerIndices),
                        matchQueue: Tournament.state.matchQueue,
                        tournamentName: tournName,
                        groupMatches: cleanGroupMatches,
                        groupStandings: Tournament.state.groupStandings || null,
                        groupStageData: Tournament.state.groupStageData || null
                    }));
                    localStorage.setItem(Persistence.prefix + 'tourn_config', JSON.stringify({
                        ...Tournament.config,
                        name: tournName
                    }));
                    localStorage.setItem(Persistence.prefix + 'tournament_name', tournName);
                } else {
                    localStorage.removeItem(Persistence.prefix + 'tourn_state');
                    localStorage.removeItem(Persistence.prefix + 'tourn_config');
                }

                localStorage.setItem(Persistence.prefix + 'season_state', JSON.stringify(Season.state));

                if (Season.state && Season.state.career && Season.state.career.playerName) {
                    const player = Season.getCareerPlayer();
                    if (player) {
                        const careerPlayerStats = {
                            name: player.name, avg: player.avg, co: player.co,
                            form: player.form, fatigue: player.fatigue, consistency: player.consistency,
                            confidence: player.confidence, money: player.money
                        };
                        localStorage.setItem(Persistence.prefix + 'career_player_stats', JSON.stringify(careerPlayerStats));
                    }
                }

                if (Season.state && Season.state.career && Array.isArray(Season.state.career.customPlayers)) {
                    localStorage.setItem(Persistence.prefix + 'custom_players', JSON.stringify(Season.state.career.customPlayers));
                }

                let screen = 'setup';
                if (document.getElementById('match-screen').style.display === 'flex') screen = 'match';
                else if (document.getElementById('tournament-hub').style.display === 'flex' && Tournament.state.active) screen = 'hub';
                else if (document.getElementById('post-match-screen').style.display === 'flex') screen = 'stats';
                localStorage.setItem(Persistence.prefix + 'active_screen', screen);
            },

            load: () => {
                try {
                    const pStatesSource = localStorage.getItem(Persistence.prefix + 'player_states');
                    if (pStatesSource && typeof PLAYERS_DB !== 'undefined') {
                        const pStates = JSON.parse(pStatesSource);
                        pStates.forEach(s => {
                            const p = PLAYERS_DB.find(x => x.name === s.n);
                            if (p) {
                                if (s.f !== undefined) p.form = s.f;
                                if (s.ft !== undefined) p.fatigue = s.ft;
                            }
                        });
                    }

                    const sStateSource = localStorage.getItem(Persistence.prefix + 'season_state');
                    if (sStateSource) {
                        Season.state = JSON.parse(sStateSource);
                        console.log('Season state loaded successfully');
                    }

                    const careerPlayerStatsSource = localStorage.getItem(Persistence.prefix + 'career_player_stats');
                    if (careerPlayerStatsSource && Season.state && Season.state.career && Season.state.career.playerName) {
                        const stats = JSON.parse(careerPlayerStatsSource);
                        const player = PLAYERS_DB.find(p => p.name === stats.name);
                        if (player) {
                            player.avg = stats.avg; player.co = stats.co; player.form = stats.form;
                            player.fatigue = stats.fatigue; player.consistency = stats.consistency;
                            player.confidence = stats.confidence; player.money = stats.money;
                        }
                    }

                    // Safety inits
                    if (!Season.state.proTourOOM) Season.state.proTourOOM = {};
                    if (!Season.state.proTourHistory) Season.state.proTourHistory = [];
                    if (!Season.state.challengeTourOOM) Season.state.challengeTourOOM = {};
                    if (!Season.state.challengeTourHistory) Season.state.challengeTourHistory = [];
                    if (!Season.state.qSchool) Season.state.qSchool = { ukOOM: {}, euOOM: {}, ukParticipants: [], euParticipants: [], ukFinalStageQualified: [], euFinalStageQualified: [] };
                    if (!Season.state.wcQualified) Season.state.wcQualified = { qualifiers: [], internationalQualifiers: [] };
                    if (Season.ensureCareerState) Season.ensureCareerState();

                    const screen = localStorage.getItem(Persistence.prefix + 'active_screen') || 'setup';

                    if (screen === 'hub' || screen === 'match' || screen === 'stats') {
                        const tState = JSON.parse(localStorage.getItem(Persistence.prefix + 'tourn_state') || 'null');
                        const tConfig = JSON.parse(localStorage.getItem(Persistence.prefix + 'tourn_config') || 'null');

                        if (tState && tConfig) {
                            Tournament.config = tConfig;
                            Tournament.state = {
                                ...Tournament.state,
                                ...tState,
                                selectedPlayerIndices: new Set(tState.selectedPlayerIndices || [])
                            };
                            Tournament.state.active = true;

                            const cachedTournName = localStorage.getItem(Persistence.prefix + 'tournament_name');
                            if (cachedTournName && document.getElementById('tourn-event-name')) {
                                document.getElementById('tourn-event-name').value = cachedTournName;
                            }

                            if (screen === 'match') {
                                App.matchState = JSON.parse(localStorage.getItem(Persistence.prefix + 'match_state') || '{}');
                                App.players = JSON.parse(localStorage.getItem(Persistence.prefix + 'players') || '[]');
                                App.config = JSON.parse(localStorage.getItem(Persistence.prefix + 'app_config') || '{}');

                                document.getElementById('setup-screen').style.display = 'none';
                                document.getElementById('match-screen').style.display = 'flex';
                                document.getElementById('lbl-score-type').innerText = (App.config.mode === 'sets') ? "SETS" : "LEGS";
                                App.updateScoreboard();

                                if (App.players && App.players[0] && App.players[1]) {
                                    const p0 = App.players[0]; const p1 = App.players[1];
                                    document.getElementById('name-p0').innerText = p0.name;
                                    document.getElementById('name-p1').innerText = p1.name;
                                    document.getElementById('flag-p0').src = typeof getFlagUrl !== 'undefined' ? getFlagUrl(p0.country) : '';
                                    document.getElementById('flag-p1').src = typeof getFlagUrl !== 'undefined' ? getFlagUrl(p1.country) : '';
                                    document.getElementById('bot-name-p0').innerText = p0.name.split(' ').pop();
                                    document.getElementById('bot-name-p1').innerText = p1.name.split(' ').pop();
                                    document.getElementById('txt-event-header').innerText = (App.config.event || 'MATCH').toUpperCase();
                                    App.ensureRow();
                                    App.isPaused = false;
                                    document.getElementById('overlay-resume').style.display = 'none';
                                    if (App.applyEventColors) App.applyEventColors(App.config.event);
                                    setTimeout(() => App.startLeg(), 100);
                                }
                            } else if (screen === 'stats') {
                                App.showPostMatch();
                            } else {
                                Tournament.renderHub();
                                App.switchTab('hub');
                            }
                        } else {
                            App.switchTab('setup');
                        }
                    } else {
                        App.switchTab('setup');
                    }
                } catch (e) {
                    console.error('Persistence.load error:', e);
                    App.switchTab('setup');
                }
            },

            clear: () => {
                // Preserve auth state when clearing
                const authUser = localStorage.getItem('pdc_auth_user');
                localStorage.clear();
                if (authUser) {
                    localStorage.setItem('pdc_auth_user', authUser);
                }
                location.reload();
            },

            clearTournamentOnly: () => {
                // Only clear tournament-specific data, keep Season progress
                localStorage.removeItem('pdc_tourn_state');
                localStorage.removeItem('pdc_tourn_config');
                localStorage.removeItem('pdc_players');
                localStorage.removeItem('pdc_match_state');
                localStorage.removeItem('pdc_app_config');
                localStorage.setItem('pdc_active_screen', 'setup');
                console.log('Cleared tournament data, Season data preserved');
            }
        };

        window.Engine = {
            getScoringHit: (playerAvg, rhythmBonus, isFinishAttempt) => {
                let effAvg = playerAvg + (rhythmBonus * 2);
                if (isFinishAttempt) effAvg += 6;
                const t20Prob = 0.28 + ((effAvg - 85) * 0.011);
                const rand = Math.random();
                if (rand < t20Prob) return 60;
                const driftProb = 0.12 - ((effAvg - 90) * 0.004);
                if (rand < t20Prob + driftProb) {
                    const neighbor = (Math.random() < 0.5) ? 1 : 5;
                    return (Math.random() < 0.80) ? neighbor : neighbor * 3;
                }
                return 20;
            },
            getCheckoutHit: (target, playerCO, isPressure, isFav) => {
                let prob = (playerCO / 100) * 1.05;
                if (isFav) prob *= 1.15;
                if (isPressure) prob *= 0.95;
                if (Math.random() < prob) return { pts: target, double: true };
                if (Math.random() < 0.70) return { pts: target / 2, double: false };
                return { pts: 0, double: false };
            },
            getSetupHit: (target, playerAvg) => {
                if (target > 20 && target <= 60 && target % 3 === 0) {
                    const prob = 0.35 + ((playerAvg - 85) * 0.01);
                    if (Math.random() < prob) return target;
                    return target / 3;
                }
                if (Math.random() < 0.96) return target;
                if (target === 20) return (Math.random() < 0.5 ? 1 : 5);
                return target;
            }
        };

        const Logic = {
            isValidTarget: (t) => (t >= 1 && t <= 20) || t === 25 || t === 50 || (t > 20 && t <= 60 && t % 3 === 0),

            getCheckoutTarget: (score, darts) => {
                // Recursively find a target to finish in 'darts' number of darts
                if (darts <= 0 || score < 2 || score > 170) return null;
                const nonFinishable = [169, 168, 166, 165, 163, 162, 159];
                if (nonFinishable.includes(score)) return null;

                // 1. One dart checkout
                if (darts >= 1) {
                    if (score <= 40 && score % 2 === 0) return { target: score, type: 'double' };
                    if (score === 50) return { target: 50, type: 'double' };
                }

                if (darts === 1) return null;

                // 2. Multi-dart checkout paths
                // Priority: Triples that leave common doubles
                const triples = [20, 19, 18, 17, 16, 15];
                const leaves = [40, 32, 36, 24, 16, 8, 50];

                for (let t of triples) {
                    const val = t * 3;
                    if (score - val >= 2) {
                        const path = Logic.getCheckoutTarget(score - val, darts - 1);
                        if (path) return { target: val, type: 'triple' };
                    }
                }

                // Singles
                for (let s = 20; s >= 1; s--) {
                    if (score - s >= 2) {
                        const path = Logic.getCheckoutTarget(score - s, darts - 1);
                        if (path) return { target: s, type: 'single' };
                    }
                }

                return null;
            },

            processVisit: (player, isDecider) => {
                let score = player.score;
                let visitTotal = 0;
                let rhythm = 0;
                for (let d = 1; d <= 3; d++) {
                    if (score <= 1) return { points: 0, endLeg: false, dartsThrown: d };
                    let pts = 0;

                    const dartsRem = 4 - d;
                    const coPath = Logic.getCheckoutTarget(score, dartsRem);

                    if (coPath) {
                        // Attempt the checkout path
                        if (coPath.type === 'double') {
                            player.stats.coAtt++;
                            const isFav = (coPath.target / 2 === player.fav);
                            const res = Engine.getCheckoutHit(coPath.target, player.co, isDecider, isFav);
                            if (res.double) {
                                player.stats.coHit++;
                                return { points: visitTotal + res.pts, endLeg: true, dartsThrown: d };
                            }
                            pts = res.pts;
                            // Bust check for D1
                            if (score === 2 && pts === 1) return { points: 0, endLeg: false, dartsThrown: d };
                        } else {
                            // Triple or Single setup
                            pts = Engine.getSetupHit(coPath.target, player.avg);
                        }
                    }
                    else if (score <= 170 && ![169, 168, 166, 165, 163, 162, 159].includes(score)) {
                        // Standard setup/cleanup logic for non-checkout darts
                        if (score > 70) pts = Engine.getScoringHit(player.avg, rhythm, true);
                        else {
                            let target = 0;
                            let idealLeave = player.fav * 2;
                            let required = score - idealLeave;
                            if (Logic.isValidTarget(required)) target = required;
                            else {
                                const leaves = [40, 32, 24, 16, 8, 4, 2];
                                let found = false;
                                for (let l of leaves) {
                                    let diff = score - l;
                                    if (diff > 0 && Logic.isValidTarget(diff)) { target = diff; found = true; break; }
                                }
                                if (!found) {
                                    if (score > 2) {
                                        let tryLeave2 = score - 2;
                                        target = Logic.isValidTarget(tryLeave2) ? tryLeave2 : 1;
                                    } else target = 0;
                                }
                            }
                            if (target > 0) pts = Engine.getSetupHit(target, player.avg);
                            else pts = 0;
                        }
                    }
                    else {
                        pts = Engine.getScoringHit(player.avg, rhythm, false);
                        if (pts >= 57) rhythm = 1; else rhythm = 0;
                    }

                    if (score - pts < 2 && score - pts !== 0) return { points: 0, endLeg: false, dartsThrown: d };
                    score -= pts; visitTotal += pts;
                    if (score === 0) return { points: visitTotal, endLeg: true, dartsThrown: d };
                }
                return { points: visitTotal, endLeg: false, dartsThrown: 3 };
            }
        };

        // ================= PLAYER STATE SYSTEM =================
        window.PlayerState = {
            clamp: (val, min, max) => Math.min(Math.max(val, min), max),

            initPlayers: () => {
                if (typeof PLAYERS_DB === 'undefined') return;

                // Try to load saved states
                let savedStates = null;
                try {
                    const json = localStorage.getItem('pdc_player_states');
                    if (json) savedStates = JSON.parse(json);
                } catch (e) { console.error("Error loading player states", e); }

                // Map for faster lookup
                const stateMap = new Map();
                if (savedStates) {
                    savedStates.forEach(s => stateMap.set(s.n, s));
                }

                PLAYERS_DB.forEach(p => {
                    const saved = stateMap.get(p.name);
                    if (saved) {
                        p.form = saved.f;
                        p.fatigue = saved.ft;
                    }

                    if (typeof p.form === 'undefined') {
                        // Estimated form based on average (REDUCED BOOSTS)
                        if (p.avg >= 95) p.form = 60 + Math.random() * 10;
                        else if (p.avg >= 90) p.form = 50 + Math.random() * 10;
                        else if (p.avg >= 85) p.form = 45 + Math.random() * 10;
                        else p.form = 40 + Math.random() * 10;
                        // REMOVED: Special boost for top stars - now based on actual form
                    }
                    if (typeof p.fatigue === 'undefined') p.fatigue = 0;
                    if (typeof p.consistency === 'undefined') {
                        if (p.avg >= 95) p.consistency = 78 + Math.random() * 8;
                        else if (p.avg >= 90) p.consistency = 68 + Math.random() * 10;
                        else if (p.avg >= 85) p.consistency = 55 + Math.random() * 10;
                        else p.consistency = 45 + Math.random() * 10;
                    }
                    p.form = PlayerState.clamp(p.form, 0, 100);
                    p.fatigue = PlayerState.clamp(p.fatigue, 0, 100);
                    p.consistency = PlayerState.clamp(p.consistency, 0, 100);
                    p.confidence = 50;
                });
            },

            updateForm: (player, matchEffect) => {
                if (!player || typeof player.form === 'undefined') return;
                player.form = PlayerState.clamp(player.form + matchEffect, 0, 100);
            },

            initMatchConfidence: (player) => {
                if (!player) return;
                player.confidence = PlayerState.clamp(player.form * 0.7 + 30, 0, 100);
            },

            updateConfidence: (player, change) => {
                if (!player) return;
                player.confidence = PlayerState.clamp(player.confidence + change, 0, 100);
            },

            updateFatigue: (player, amount) => {
                if (!player) return;
                player.fatigue = PlayerState.clamp(player.fatigue + amount, 0, 100);
            },

            getPerformanceModifier: (player) => {
                if (!player) return 0;
                // REDUCED MODIFIERS: form/fatigue/confidence effects are now less extreme
                const conf = player.confidence || 50;

                // Ensure form and fatigue are numbers
                const f = (!isNaN(player.form)) ? player.form : 50;
                const ft = (!isNaN(player.fatigue)) ? player.fatigue : 0;

                const c = (!isNaN(player.consistency)) ? player.consistency : 50;
                // (form - 50) * 0.0008 + (confidence - 50) * 0.0010 - (fatigue * 0.0008) + (consistency - 50) * 0.0006
                return ((f - 50) * 0.0008) + ((conf - 50) * 0.0010) - (ft * 0.0008) + ((c - 50) * 0.0006);
            },

            shouldSkipEvent: (player, eventType) => {
                // Never skip major tournaments
                if (eventType === 'major' || eventType === 'world' || eventType === 'matchplay' || eventType === 'grandprix' || eventType === 'gs-qual-tc' || eventType === 'grandslam' || eventType === 'uk-open' || eventType === 'europeanf' || eventType === 'playersf' || eventType === 'masters' || eventType === 'masters-final' || eventType === 'winmaudm') return false;
                if (!eventType) return false;

                // Universal threshold: 90%+ fatigue = guaranteed withdrawal for ALL players
                if (player.fatigue >= 90) return true;

                const isTop16 = PLAYERS_DB.indexOf(player) < 16;

                // Probabilistic thresholds below 90%
                if (isTop16) {
                    // Top 16 players push through more often
                    if (player.fatigue >= 80) return Math.random() < 0.80;  // 80% chance
                    if (player.fatigue >= 70) return Math.random() < 0.50;  // 50% chance
                    if (player.fatigue >= 60) return Math.random() < 0.25;  // 25% chance
                    return false;
                } else {
                    // Lower ranked players withdraw more readily
                    if (player.fatigue >= 80) return Math.random() < 0.95;  // 95% chance
                    if (player.fatigue >= 70) return Math.random() < 0.85;  // 85% chance
                    if (player.fatigue >= 60) return Math.random() < 0.60;  // 60% chance
                    return false;
                }
            },

            generateRandomAfricanPlayer: () => {
                // Generate a random African player with 65 average for African Darts Group Qualifier
                const africanCountries = ["rsa", "zim", "ken", "uga", "moz", "tan", "bwa", "egi", "mar", "nig", "gha", "ivr", "cmr"];
                const firstNames = ["James", "Marcus", "Daniel", "Stephen", "Michael", "Robert", "David", "Richard", "Charles", "Samuel", "Thomas", "William", "Benjamin", "Joseph", "Christopher", "Patrick"];
                const lastNames = ["Mthembu", "Khumalo", "Ndlela", "Dlamini", "Nkosi", "Sibiya", "Mokoena", "Ngema", "Zuma", "Masondo", "Mwale", "Banda", "Kariuki", "Okonkwo", "Mensah", "Amakye"];

                // Country code mappings for flag URLs
                const countryMapping = {
                    "rsa": "za", "zim": "zw", "ken": "ke", "uga": "ug", "moz": "mz",
                    "tan": "tz", "bwa": "bw", "egi": "eg", "mar": "ma", "nig": "ng",
                    "gha": "gh", "ivr": "ci", "cmr": "cm"
                };

                // Ensure all African countries are in FLAG_MAP
                Object.entries(countryMapping).forEach(([code, flagCode]) => {
                    if (!FLAG_MAP[code]) {
                        FLAG_MAP[code] = flagCode;
                    }
                });

                const randomCountry = africanCountries[Math.floor(Math.random() * africanCountries.length)];
                const randomFirst = firstNames[Math.floor(Math.random() * firstNames.length)];
                const randomLast = lastNames[Math.floor(Math.random() * lastNames.length)];
                const playerName = `${randomFirst} ${randomLast}`;

                // Create new player with 65 average (African qualifier level) - no tour card for qualifiers
                const newPlayer = {
                    name: playerName,
                    country: randomCountry,
                    avg: 65.0,
                    co: 38.5,  // Realistic checkout for 65 average
                    fav: 16,   // Standard favorite leg
                    money: 0,  // No starting money
                    tourCard: false,  // Qualifiers don't have tour cards
                    // State properties
                    form: 45,
                    confidence: 50,
                    fatigue: 20,
                    isReplacement: true,
                    isGenerated: true  // Mark as generated player for tracking
                };

                // Add to PLAYERS_DB and return index
                PLAYERS_DB.push(newPlayer);
                return PLAYERS_DB.length - 1;
            },

            generateRandomIndianPlayer: () => {
                // Generate a random Indian player with realistic Indian names
                const firstNames = ["Arjun", "Aditya", "Raj", "Rohan", "Vikram", "Harsha", "Nitin", "Manoj", "Sandeep", "Amit", "Devendra", "Bhavesh", "Ashok", "Karan", "Mohit", "Saurav"];
                const lastNames = ["Sharma", "Patel", "Singh", "Kumar", "Reddy", "Kapoor", "Nair", "Gupta", "Pandey", "Verma", "Iyer", "Bhat", "Desai", "Tiwari", "Bhatt", "Rao"];

                const randomFirst = firstNames[Math.floor(Math.random() * firstNames.length)];
                const randomLast = lastNames[Math.floor(Math.random() * lastNames.length)];
                const playerName = `${randomFirst} ${randomLast}`;

                // Create new player with realistic skill for Indian qualifier (60-72 average)
                const avg = (Math.random() * 12 + 60).toFixed(2);
                const co = (38 + Math.random() * 3).toFixed(1);  // 38-41 checkout for this skill level

                const newPlayer = {
                    name: playerName,
                    country: "ind",  // India country code
                    avg: parseFloat(avg),
                    co: parseFloat(co),
                    fav: 16,  // Standard favorite leg
                    money: 0,
                    tourCard: false,  // Qualifiers don't have tour cards
                    // State properties
                    form: 45,
                    confidence: 50,
                    fatigue: 20,
                    isReplacement: true,
                    isGenerated: true  // Mark as generated player for tracking
                };

                // Add to PLAYERS_DB and return index
                PLAYERS_DB.push(newPlayer);
                return PLAYERS_DB.length - 1;
            },

            generateRandomJapanesePlayer: () => {
                // Generate a random Japanese player with realistic Japanese names
                const firstNames = ["Takeshi", "Hiroshi", "Masaki", "Kenji", "Toshiro", "Kazuo", "Satoshi", "Shoji", "Noboru", "Junichi", "Yoshiaki", "Tamotsu", "Isao", "Naoki", "Daisuke", "Tetsuya"];
                const lastNames = ["Yamada", "Tanaka", "Suzuki", "Sato", "Nakamura", "Kobayashi", "Watanabe", "Sasaki", "Matsumoto", "Yamamoto", "Ito", "Nakajima", "Okada", "Shimizu", "Goto", "Saito"];

                const randomFirst = firstNames[Math.floor(Math.random() * firstNames.length)];
                const randomLast = lastNames[Math.floor(Math.random() * lastNames.length)];
                const playerName = `${randomFirst} ${randomLast}`;

                // Create new player with realistic skill for Japan tour qualifier (65-75 average)
                const avg = (Math.random() * 10 + 65).toFixed(2);
                const co = (39 + Math.random() * 3).toFixed(1);  // 39-42 checkout for this skill level

                const newPlayer = {
                    name: playerName,
                    country: "jpn",  // Japan country code
                    avg: parseFloat(avg),
                    co: parseFloat(co),
                    fav: 16,  // Standard favorite leg
                    money: 0,
                    tourCard: false,  // Qualifiers don't have tour cards
                    // State properties
                    form: 45,
                    confidence: 50,
                    fatigue: 20,
                    isReplacement: true,
                    isGenerated: true  // Mark as generated player for tracking
                };

                // Add to PLAYERS_DB and return index
                PLAYERS_DB.push(newPlayer);
                return PLAYERS_DB.length - 1;
            },

            generateRandomPlayer: (eventType, region) => {
                // Generate a random player based on event type with appropriate skill level
                // Ensures the player meets the eligibility criteria for the tournament
                const firstNames = ["James", "Marcus", "Daniel", "Stephen", "Michael", "Robert", "David", "Richard", "Charles", "Samuel", "Thomas", "William", "Benjamin", "Joseph", "Christopher", "Patrick", "Alexander", "George", "Edward", "Andrew", "Peter", "Paul", "John", "Matthew", "Mark", "Anthony"];
                const lastNames = ["Smith", "Johnson", "Williams", "Brown", "Jones", "Garcia", "Miller", "Davis", "Rodriguez", "Martinez", "Hernandez", "Lopez", "Gonzalez", "Wilson", "Anderson", "Thomas", "Taylor", "Moore", "Jackson", "Martin", "Lee", "White", "Harris", "Martin", "Thompson", "Knight"];

                // Determine average and tour card eligibility based on event type
                let avgRange = { min: 75, max: 85 };
                let shouldHaveTourCard = false;

                if (eventType === "challenge" || eventType === "q-school" || eventType === "wc-qual-intl" || eventType === "wc-qual-tc" || eventType === "et-qual-tc") {
                    avgRange = { min: 60, max: 72 };  // Qualifier level - no tour card
                    shouldHaveTourCard = false;
                } else if (eventType === "minor" || eventType === "et-host-nation" || eventType === "et-east-european" || eventType === "et-nordic-baltic") {
                    avgRange = { min: 70, max: 82 };  // ET level - tour card holders
                    shouldHaveTourCard = true;
                } else if (eventType === "players" || eventType === "world" || eventType === "matchplay" || eventType === "uk-open") {
                    avgRange = { min: 85, max: 100 };  // Pro tour - high skill
                    shouldHaveTourCard = true;
                } else if (eventType === "winmaudm" || eventType === "masters" || eventType === "masters-final" || eventType === "wmasters-qual") {
                    avgRange = { min: 80, max: 95 };  // Masters/Winmau level
                    shouldHaveTourCard = true;
                } else if (eventType === "ws-qual-tc" || eventType === "gs-qual-tc") {
                    avgRange = { min: 75, max: 90 };  // World/Grand Slam qualifiers
                    shouldHaveTourCard = true;
                } else if (eventType === "premier-league") {
                    avgRange = { min: 90, max: 105 };  // Elite level
                    shouldHaveTourCard = true;
                }

                // Determine country based on region
                let countries = ["eng", "wal", "sco", "nir", "irl"];  // Default UK/Ireland

                if (region === "africa") {
                    countries = REGION_MAP.africa;
                } else if (region === "asia") {
                    countries = REGION_MAP.asia;
                } else if (region === "india") {
                    countries = REGION_MAP.india;
                } else if (region === "america") {
                    countries = REGION_MAP.america;
                } else if (region === "oceania") {
                    countries = REGION_MAP.oceania;
                } else if (region === "nordic") {
                    countries = REGION_MAP.nordic;
                } else if (region === "east") {
                    countries = REGION_MAP.east;
                } else if (region === "jpn") {
                    countries = ["jpn"];
                } else if (region === "ger") {
                    countries = ["ger"];
                } else if (region === "aut") {
                    countries = ["aut"];
                } else if (region === "bel") {
                    countries = ["bel"];
                } else if (region === "svk") {
                    countries = ["svk"];
                } else if (region === "cze") {
                    countries = ["cze"];
                } else if (region === "pol") {
                    countries = ["pol"];
                } else if (region === "hun") {
                    countries = ["hun"];
                } else if (region === "sui") {
                    countries = ["sui"];
                } else {
                    // Assume region is a single country code for host nation qualifiers
                    countries = [region];
                }

                const randomCountry = countries[Math.floor(Math.random() * countries.length)];
                const randomFirst = firstNames[Math.floor(Math.random() * firstNames.length)];
                const randomLast = lastNames[Math.floor(Math.random() * lastNames.length)];
                const playerName = `${randomFirst} ${randomLast}`;

                // Generate random average within range
                const avg = (Math.random() * (avgRange.max - avgRange.min) + avgRange.min).toFixed(2);

                // Generate realistic checkout percentage (higher for better players)
                const avgNum = parseFloat(avg);
                const baseCheckout = 35 + (avgNum - 60) * 0.25;  // Scale from ~35 to ~45
                const co = Math.max(25, Math.min(50, baseCheckout + (Math.random() - 0.5) * 3)).toFixed(1);

                // Create new player with all required DB fields
                const newPlayer = {
                    name: playerName,
                    country: randomCountry,
                    avg: parseFloat(avg),
                    co: parseFloat(co),
                    fav: Math.random() > 0.5 ? 20 : 16,  // Favorite leg: 16 or 20
                    money: 0,  // Generated players start with 0 money
                    tourCard: shouldHaveTourCard,
                    // State properties (match player state format)
                    form: 45,
                    confidence: 50,
                    fatigue: 20,
                    isReplacement: true,
                    isGenerated: true  // Mark as generated player for tracking
                };

                // Add to PLAYERS_DB and return index
                PLAYERS_DB.push(newPlayer);
                return PLAYERS_DB.length - 1;
            },

            getReplacementPlayer: (currentParticipantsIndices, eventType, eventName) => {
                const currentSet = new Set(currentParticipantsIndices);
                const isQSchool = eventType === 'q-school';
                const isETQualTC = eventType === 'et-qual-tc';
                const isWCQualIntl = eventType === 'wc-qual-intl';
                const isWCQualTC = eventType === 'wc-qual-tc';

                // For ET Tour Card Qualifiers, build exclusion list (top 16 world + top 16 pro tour)
                let excludedNames = new Set();
                if (isETQualTC) {
                    // Exclude top 16 by world ranking
                    PLAYERS_DB.slice(0, 16).forEach(p => excludedNames.add(p.name));

                    // Exclude top 16 from Pro Tour OOM
                    const proEntries = Object.entries(Season.state.proTourOOM).filter(e => e[1] > 0);
                    if (proEntries.length >= 16) {
                        proEntries.sort((a, b) => b[1] - a[1]).slice(0, 16).forEach(e => excludedNames.add(e[0]));
                    }
                }

                // For WC Qualifiers, exclude top 40 from Main OOM and Pro Tour OOM
                if (isWCQualIntl || isWCQualTC) {
                    Object.entries(Season.state.orderOfMerit)
                        .filter(([n]) => PLAYERS_DB.find(p => p.name === n)?.tourCard)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 40)
                        .forEach(e => excludedNames.add(e[0]));

                    Object.entries(Season.state.proTourOOM)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 40)
                        .forEach(e => excludedNames.add(e[0]));
                }

                // Regional filtering for WC International Qualifiers
                let regionFilter = null;
                if ((isWCQualIntl || eventType === 'et-host-nation') && eventName) {
                    const nameUpper = eventName.toUpperCase();

                    // For ET Host Nation qualifiers, enforce single host nation only
                    if (eventType === 'et-host-nation') {
                        const match = eventName.match(/ET(\d+)/);
                        if (match) {
                            const etNumber = 500 + parseInt(match[1]);
                            const hostNation = HOST_NATION[etNumber];
                            if (hostNation) regionFilter = [hostNation];
                        }
                    } else {
                        // Existing logic for WC International Qualifiers
                        if (nameUpper.includes("HUNGARIAN") || nameUpper.includes("ET13")) regionFilter = ["hun"];
                        else if (nameUpper.includes("NETHERLANDS & BELGIUM")) regionFilter = ["nl", "bel"];
                        else if (nameUpper.includes("MEDITERRANEAN")) regionFilter = ["esp", "ita", "por", "gre", "tur"];
                        else if (nameUpper.includes("SOUTH-EAST EUROPE")) regionFilter = ["rou", "bul", "srb", "cro", "slo"];
                        else if (nameUpper.includes("CZECHIA") || nameUpper.includes("ET14") || nameUpper.includes("CZECH")) regionFilter = ["cze"];
                        else if (nameUpper.includes("POLISH") || nameUpper.includes("PDO POLISH") || nameUpper.includes("ET1") || nameUpper.includes("POLAND")) regionFilter = ["pol"];
                        else if (nameUpper.includes("DACH")) regionFilter = ["ger", "aut", "sui"];
                        else if (nameUpper.includes("GERMAN") || nameUpper.includes("ET2") || nameUpper.includes("ET4") || nameUpper.includes("ET5") || nameUpper.includes("ET6") || nameUpper.includes("ET8") || nameUpper.includes("ET11")) regionFilter = ["ger"];
                        else if (nameUpper.includes("AUSTRIAN") || nameUpper.includes("ET7")) regionFilter = ["aut"];
                        else if (nameUpper.includes("BELGIAN") || nameUpper.includes("ET3") || nameUpper.includes("ET9")) regionFilter = ["bel"];
                        else if (nameUpper.includes("SLOVAK") || nameUpper.includes("ET10")) regionFilter = ["svk"];
                        else if (nameUpper.includes("SWISS") || nameUpper.includes("ET12")) regionFilter = ["sui"];
                        else if (nameUpper.includes("UK&IRE")) regionFilter = ["eng", "sco", "wal", "nir", "irl"];
                        else if (nameUpper.includes("AFRICAN")) regionFilter = REGION_MAP.africa;
                        else if (nameUpper.includes("JAPAN")) regionFilter = ["jpn"];
                        else if (nameUpper.includes("NORDIC & BALTIC")) regionFilter = REGION_MAP.nordic;
                        else if (nameUpper.includes("NORTH AMERICAN")) regionFilter = REGION_MAP.america;
                        else if (nameUpper.includes("ASIAN")) regionFilter = REGION_MAP.asia;
                        else if (nameUpper.includes("CDC") || nameUpper.includes("CDLC")) regionFilter = REGION_MAP.america;
                        else if (nameUpper.includes("ANZ") || nameUpper.includes("DPA") || nameUpper.includes("DPNZ")) regionFilter = REGION_MAP.oceania;
                    }
                }

                for (let i = 0; i < PLAYERS_DB.length; i++) {
                    if (!currentSet.has(i)) {
                        const p = PLAYERS_DB[i];

                        // If it's Q-School, do NOT allow Tour Card holders to replace
                        if (isQSchool && p.tourCard) continue;

                        // If it's ET Tour Card Qualifier, do NOT allow top 16 players or non-tour-card holders
                        if (isETQualTC && (excludedNames.has(p.name) || !p.tourCard)) continue;

                        // If it's WC Tour Card Qualifier, do NOT allow non-tour-card holders or auto-qualified players
                        if (isWCQualTC && (excludedNames.has(p.name) || !p.tourCard)) continue;

                        // If it's WC International Qualifier or ET Host Nation, do NOT allow auto-qualified players
                        if ((isWCQualIntl || eventType === 'et-host-nation') && excludedNames.has(p.name)) continue;

                        // Regional filtering for WC International Qualifiers and ET Host Nation
                        if (regionFilter && !regionFilter.includes(p.country)) continue;

                        p.form = 45;
                        p.confidence = 50;
                        p.fatigue = 20;
                        p.isReplacement = true;
                        return i;
                    }
                }

                // Fallback: If it's a regional qualifier and no eligible players found, generate one
                if ((isWCQualIntl || eventType === 'et-host-nation') && eventName) {
                    if (regionFilter && regionFilter.length > 0) {
                        // Use the first country in the filter as the primary region for generation
                        return PlayerState.generateRandomPlayer(eventType, regionFilter[0]);
                    }
                }

                return -1;
            },

            applyEventFatigueReduction: () => {
                if (typeof PLAYERS_DB === 'undefined') return;
                PLAYERS_DB.forEach(p => {
                    // Rest period between events - ensure numbers
                    p.fatigue = (!isNaN(p.fatigue)) ? p.fatigue : 0;
                    p.form = (!isNaN(p.form)) ? p.form : 50;

                    PlayerState.updateFatigue(p, -10);
                    // Form decay
                    PlayerState.updateForm(p, -1);
                });
                Persistence.save(); // Save checking points
            }
        };

        // ================= NEWS SYSTEM =================
        window.NewsSystem = {
            maxItems: 200,
            viewState: { filter: 'all' },
            items: [],

            headlineTemplates: {
                win: [
                    "{player} claims victory at {event}!",
                    "{player} crowned {event} Champion!",
                    "Unstoppable {player} takes the title at {event}.",
                    "{event} glory goes to {player}."
                ],
                rank: [
                    "NEW WORLD NUMBER ONE!",
                    "{player} climbs to World #1!",
                    "Order of Merit Shake-up: {player} on top!"
                ],
                upset: [
                    "SHOCK: {player} (Rank {rank}) knocks out {rival}!",
                    "Major upset at {event} as {player} defeats {rival}.",
                    "{rival} crashes out against {player}!",
                    "Underdog {player} stuns {rival} at {event}."
                ],
                withdrawal: [
                    "{player} withdraws from {event} due to fatigue.",
                    "Exhausted {player} pulls out of {event}.",
                    "{event} update: {player} withdraws."
                ],
                replacement: [
                    "{player} enters {event} as a late replacement.",
                    "{player} gets the call for {event}."
                ],
                milestone: [
                    "{player} reaches the Top 16 for the first time!",
                    "Career high ranking for {player}.",
                    "{player} breaks into the elite!",
                    "Historic moment for {player} at {event}."
                ],
                rivalry: [
                    "{player} takes aim at {rival} after heated match",
                    "War of words erupts between {player} and {rival}",
                    "{player} fires shots at {rival} in post-match interview",
                    "Tensions rise as {player} criticizes {rival}",
                    "{player} calls out {rival} after defeat",
                    "Public feud ignites between {player} and {rival}",
                    "{player} not impressed with {rival}'s performance",
                    "Drama explodes as {player} speaks out",
                    "Bad blood continues: {player} knocks out {rival}",
                    "{rival} gets revenge on {player} at {event}",
                    "Heated showdown as {player} faces {rival}",
                    "{player} vs {rival}: another explosive chapter",
                    "{player} dominates rival {rival} in statement win",
                    "{rival} ends {player}'s run in dramatic fashion",
                    "Old wounds reopened between {player} and {rival}",
                    "Crowd divided as rivals meet again",
                    "Personal rivalry explodes at {event}"
                ],
                tourcard: [
                    "Dream comes true as {player} secures Tour Card",
                    "{player} fights through Q-School to earn Tour Card",
                    "Emotional scenes as {player} earns Tour Card",
                    "{player} completes fairy-tale run to Tour Card",
                    "{player} joins the PDC Tour after dramatic finish",
                    "Career changes forever as {player} earns Tour Card",
                    "{player} breaks down in tears after Tour Card success"
                ],
                heartbreak: [
                    "Heartbreak as {player} misses Tour Card by one leg",
                    "One leg short: {player} denied Tour Card",
                    "Cruel end as {player} falls short at Q-School",
                    "Dream ends for {player} after brutal defeat",
                    "Q-School nightmare for {player}",
                    "{player} eliminated from Tour Card race",
                    "So close, yet so far for {player}",
                    "Another year of waiting for {player}",
                    "{player} collapses after missed match darts",
                    "Unbelievable meltdown from {player}",
                    "{player} throws away winning position",
                    "Nightmare leg haunts {player}",
                    "Disaster strikes as {player} loses control",
                    "Pressure proves too much for {player}"
                ],
                breakout: [
                    "Unknown name {player} stuns field with incredible run",
                    "Fairy-tale run ends, but {player} wins hearts",
                    "{player} announces himself on big stage",
                    "From nowhere: {player} reaches final",
                    "{player} shocks the tour with breakout performance",
                    "New star born as {player} lights up {event}",
                    "Young gun {player} sends warning to the tour",
                    "Future star {player} impresses again",
                    "Next generation arrives: {player} makes mark",
                    "Teenage sensation {player} stuns crowd",
                    "{player} shows he's the future"
                ],
                comeback: [
                    "Redemption at last for {player}",
                    "{player} silences critics with huge win",
                    "Comeback complete as {player} lifts trophy",
                    "{player} rises again after tough season",
                    "From slump to success: {player} rebounds",
                    "{player} answers doubters in style"
                ],
                veteran: [
                    "Veteran {player} rolls back the years",
                    "Experience counts as {player} shines again",
                    "Old master still has it: {player} wins big",
                    "Age no barrier for {player}",
                    "Legendary performance from {player}"
                ],
                drama: [
                    "Deciding leg thriller ends in heartbreak",
                    "One dart decides epic showdown",
                    "Last-leg drama leaves crowd stunned",
                    "Final leg madness at {event}",
                    "Everything on the line in deciding leg",
                    "Mind games pay off as {player} outlasts {rival}",
                    "Pressure overwhelms {player} in crunch moment",
                    "{player} cracks after intense battle",
                    "Mental strength carries {player} through thriller",
                    "Nerves of steel from {player} under extreme pressure"
                ],
                grudge: [
                    "Grudge match goes {player}'s way",
                    "{player} gets payback on {rival}",
                    "Sweet revenge for {player}",
                    "{player} finally beats {rival}",
                    "Years of frustration end for {player}"
                ],
                career: [
                    "Career-defining moment for {player}",
                    "A night {player} will never forget",
                    "{player} writes his name into history",
                    "Turning point in {player}'s career",
                    "Everything changes for {player}"
                ]
            },

            quotes: {
                trash_talk: [
                    '"{rival} talks a lot, but I do the talking on the board."',
                    '"I wasn\'t impressed at all, to be honest."',
                    '"He got lucky. Simple as that."',
                    '"If he plays like that again, he\'s in trouble."',
                    '"That\'s not top-level darts."',
                    '"I expected more from him."',
                    '"He knows I\'m in his head now."',
                    '"I don\'t see him as a rival."',
                    '"He cracked under pressure."'
                ],
                sarcastic: [
                    '"I guess that\'s his level."',
                    '"Everyone has good days. Even him."',
                    '"He should focus on himself."',
                    '"I\'m not worried about him at all."',
                    '"That match was easier than I expected."'
                ],
                salty: [
                    '"The crowd carried him."',
                    '"The doubles saved him."',
                    '"Im not bothered"',
                    '"I lost, but I know the truth."'
                ],
                confident: [
                    '"I sent a message tonight."',
                    '"That\'s what happens when I\'m focused."',
                    '"He\'ll think twice next time."',
                    '"I\'m just getting started."'
                ],
                dismissive: [
                    '"No hard feelings, but I was better."',
                    '"It\'s just business."',
                    '"I wish him luck. He\'ll need it."'
                ],
                emotional: [
                    '"I never stopped believing."',
                    '"This one means everything."',
                    '"I had nothing left in the tank."',
                    '"I proved a lot of people wrong."'
                ],
                champion: [
                    '"I just wanted to say... man the first time was so nice, i had to do it twice.',
                    '"This is what I work for every single day."',
                    '"The hard work has paid off. This title means the world to me."',
                    '"I believed in myself when nobody else did."',
                    '"This is just the beginning. I want more."',
                    '"To win this event is a dream come true."',
                    '"I felt unstoppable out there today."',
                    '"My family sacrificed so much for this moment."',
                    '"All the hours of practice, all the dedication - it was worth it."',
                    '"I want to thank my team. We did this together."',
                    '"This trophy is going straight in the cabinet!"',
                    '"I peaked at the right time. Everything clicked."',
                    '"I\'m lost for words. This is incredible."',
                    '"The crowd was amazing. They pushed me over the line."',
                    '"I told everyone I was going to win this - and I did."',
                    '"This is the highlight of my career so far."'
                ]
            },

            init: () => {
                const saved = localStorage.getItem('pdc_news');
                if (saved) {
                    try {
                        // Ensure we always have an array
                        const parsed = JSON.parse(saved);
                        NewsSystem.items = Array.isArray(parsed) ? parsed : [];
                        console.log('[NewsSystem.init] Loaded', NewsSystem.items.length, 'items from localStorage');
                    }
                    catch (e) { console.error("News load error", e); NewsSystem.items = []; }
                } else {
                    console.log('[NewsSystem.init] No saved news found, starting fresh');
                    NewsSystem.items = [];
                }
            },

            save: () => {
                const toSave = NewsSystem.items.slice(0, NewsSystem.maxItems);
                try {
                    localStorage.setItem('pdc_news', JSON.stringify(toSave));
                    console.log('[NewsSystem.save] Saved', toSave.length, 'items to localStorage');
                } catch (e) {
                    console.error("Failed to save news", e);
                }
            },

            add: (type, data) => {
                let headline = "";
                let text = "";

                if (data.headline) {
                    headline = data.headline;
                    text = data.subtext || "";
                } else if (data.overrideText) {
                    headline = data.overrideText;
                } else {
                    const templates = NewsSystem.headlineTemplates[type] || ["{event}: Update regarding {player}"];
                    const template = templates[Math.floor(Math.random() * templates.length)];
                    headline = template;
                    for (const [key, value] of Object.entries(data)) {
                        headline = headline.replace(`{${key}}`, value);
                    }
                }

                let importance = data.importance || 'medium';
                if (!data.importance) {
                    if (type === 'withdrawal' || type === 'replacement') importance = 'low';
                    if (type === 'upset') importance = 'high';
                    if (data.isMajorWin) importance = 'high';
                }

                const item = {
                    id: Date.now() + Math.random().toString().slice(2, 6),
                    type,
                    headline,
                    text: text, // Store subtext separately
                    date: new Date().toISOString(),
                    event: data.event || "Season Update",
                    importance
                };

                console.log('NEWS ADDED:', type, item);

                // Add to beginning
                NewsSystem.items.unshift(item);

                // Keep size manageable
                if (NewsSystem.items.length > NewsSystem.maxItems) {
                    NewsSystem.items = NewsSystem.items.slice(0, NewsSystem.maxItems);
                }

                NewsSystem.save();

                // If News tab is active, render immediately
                const newsTab = document.getElementById('tab-news');
                if (newsTab && newsTab.classList.contains('active')) NewsSystem.renderNews(NewsSystem.viewState.filter);
            },

            setFilter: (f) => {
                NewsSystem.viewState.filter = f;
                document.querySelectorAll('.news-filters .filter-btn').forEach(b => {
                    b.classList.remove('active');
                    if (b.innerText.toLowerCase() === f || (f === 'tour' && b.innerText === 'PRO TOUR') || (f === 'withdrawal' && b.innerText === 'WITHDRAWALS') || (f === 'upset' && b.innerText === 'UPSETS')) {
                        b.classList.add('active');
                    }
                });
                NewsSystem.renderNews(f);
            },

            renderNews: (filter, containerId) => {
                const targetId = containerId || 'news-feed';
                const container = document.getElementById(targetId);
                if (!container) return;

                console.log('[NewsSystem.renderNews] Total items:', NewsSystem.items.length, 'Filter:', filter);

                container.innerHTML = '';

                let filtered = NewsSystem.items;
                if (filter === 'major') filtered = filtered.filter(i => i.event && (i.event.includes('World') || i.event.includes('Matchplay') || i.event.includes('Grand') || i.event.includes('Open') || i.event.includes('Premier') || i.event.includes('Masters')));
                if (filter === 'tour') filtered = filtered.filter(i => i.event && (i.event.includes('Players Championship') || i.event.includes('European Tour')));
                if (filter === 'withdrawal') filtered = filtered.filter(i => i.type === 'withdrawal');
                if (filter === 'upset') filtered = filtered.filter(i => i.type === 'upset');

                console.log('[NewsSystem.renderNews] Filtered items:', filtered.length);

                if (filtered.length === 0) {
                    container.innerHTML = `<div style="text-align:center; padding: 20px; color:#666; font-size:12px;">No news found. Total in system: ${NewsSystem.items.length}</div>`;
                    return;
                }

                filtered.forEach(item => {
                    const div = document.createElement('div');
                    div.className = `news-card ${item.type} ${item.importance}`;

                    const dateObj = new Date(item.date);
                    const dateStr = dateObj.toLocaleDateString() + ' ' + dateObj.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

                    // Icon mapping for all news types
                    const iconMap = {
                        'win': 'üèÜ',
                        'rank': 'üëë',
                        'upset': '‚ö°',
                        'withdrawal': 'üöë',
                        'replacement': 'üîÑ',
                        'rivalry': 'üî•',
                        'tourcard': 'üé´',
                        'heartbreak': 'üíî',
                        'breakout': '‚≠ê',
                        'comeback': 'üí™',
                        'veteran': 'üßì',
                        'drama': 'üé≠',
                        'grudge': 'üí¢',
                        'career': 'üìú'
                    };
                    const icon = iconMap[item.type] || 'üì∞';

                    // Fallback for old items that used 'text' properties
                    const showHeadline = item.headline || item.text;
                    const showSubtext = item.headline ? item.text : "";

                    div.innerHTML = `
                        <div class="news-header">
                            <span>${icon} ${item.event ? item.event.toUpperCase() : 'NEWS'}</span>
                            <span>${dateStr}</span>
                        </div>
                        <div class="news-title">${showHeadline}</div>
                        ${showSubtext ? `<div style="font-size:0.9em; opacity:0.8; margin-top:4px;">${showSubtext}</div>` : ''}
                    `;
                    container.appendChild(div);
                });
            }
        };

        // ================= RIVALRY SYSTEM =================
        const RivalryTracker = {
            rivalries: {}, // Track matchups between players

            recordMatch: (winner, loser, event, isUpset = false, isFinal = false) => {
                const key = [winner, loser].sort().join('|');

                if (!RivalryTracker.rivalries[key]) {
                    RivalryTracker.rivalries[key] = {
                        players: [winner, loser],
                        meetings: 0,
                        upsets: 0,
                        finals: 0,
                        lastEvent: '',
                        beefLevel: 0
                    };
                }

                const rivalry = RivalryTracker.rivalries[key];
                rivalry.meetings++;
                rivalry.lastEvent = event;
                if (isUpset) rivalry.upsets++;
                if (isFinal) rivalry.finals++;

                // Increase beef level based on factors
                if (isUpset) rivalry.beefLevel += 3;
                if (isFinal) rivalry.beefLevel += 3;
                if (rivalry.meetings >= 2) rivalry.beefLevel += 1;
                rivalry.beefLevel += 1; // Always add 1 for any meeting

                console.log('[RivalryTracker]', winner, 'vs', loser, '| Meetings:', rivalry.meetings, '| Beef:', rivalry.beefLevel);

                // Generate rivalry news more frequently
                const beefThreshold = 2;
                const shouldGenerateBeef = rivalry.beefLevel >= beefThreshold && Math.random() < 0.7;

                if (shouldGenerateBeef && NewsSystem) {
                    console.log('[RivalryTracker] Generating beef news!');
                    const quotes = NewsSystem.quotes;
                    // Always use a trash talk quote for the headline
                    const quoteArr = quotes.trash_talk;
                    const quote = quoteArr[Math.floor(Math.random() * quoteArr.length)];
                    const quoteText = quote.replace('{rival}', loser).replace('{player}', winner);
                    const headline = `${winner} on ${loser}: ${quoteText}`;
                    NewsSystem.add('rivalry', {
                        player: winner,
                        rival: loser,
                        event: event,
                        headline: headline,
                        importance: 'medium'
                    });

                    // Reset beef level after news is generated
                    rivalry.beefLevel = Math.floor(rivalry.beefLevel / 2);
                }
            }
        };

        // ============================================================
        // VENUES DATABASE
        // ============================================================
        /*
         * COMPREHENSIVE CAREER MODE SYSTEMS
         * =================================
         * 
         * This implementation includes the following interconnected systems:
         * 
         * 1. VENUE SYSTEM (VENUES_DB)
         *    - 60+ real PDC venues across 6 regions: uk, eu, asia, america, oceania, africa
         *    - Each venue has: id, name, city, country, region, baseAccommodationCost
         *    - Venues are reusable across multiple events
         * 
         * 2. PLAYER HOME LOCATION
         *    - Player selects home city, country, and region during career creation
         *    - Home region affects travel costs to events
         *    - Player.currentRegion tracks current location (updated when traveling)
         * 
         * 3. EVENT ENRICHMENT (EventEnrichment)
         *    - Automatically assigns venueId to all events based on location keywords
         *    - Assigns entry fees based on event type:
         *      * Q-School: ¬£500, Players Championships: ¬£100, Challenge Tour: ¬£50
         *      * Euro Tour events: ¬£150-¬£200, Masters/Premier League: ¬£0 (invitational)
         *    - Called during Season.init() to enrich all events
         * 
         * 4. TRAVEL SYSTEM (TravelSystem)
         *    - calculateTravel(fromRegion, toRegion, baseAccommodation)
         *      * Returns: travelCost, fatigueIncrease, accommodationCost, totalCost
         *      * Example costs: UK‚ÜíUK ¬£50, UK‚ÜíEU ¬£150, UK‚ÜíAsia ¬£600, UK‚ÜíOceania ¬£1000
         *      * Fatigue ranges: 2-22 points depending on distance
         *    - resolveEventLocation(event): Gets venue details from event.venueId
         * 
         * 5. ENTRY FEE & MONEY SYSTEM (EntrySystem)
         *    - calculateEntryCost(event, player): Entry fee + travel + accommodation
         *    - canEnterEvent(event, player): Checks money, fatigue, and tour card
         *      * Returns: { canEnter, reason, cost, fatigueIncrease }
         *      * Hard blocks: Fatigue ‚â• 85%, Insufficient money
         *    - enterEvent(event, player): Deducts money, adds travel fatigue, updates location
         *    - Integrated into Season.canCareerPlayerEnterEvent()
         * 
         * 6. FATIGUE SYSTEM (FatigueSystem)
         *    - Scale: 0-100 (0 = fresh, 100 = exhausted)
         *    - Increases from:
         *      * Travel (2-22 points based on distance)
         *      * Playing events (3 base + 1.5 per match)
         *      * Multi-day events (√ó1.2 multiplier)
         *    - Performance modifiers:
         *      * 0-20: 100% (no penalty)
         *      * 40-60: 95% performance
         *      * 75-85: 85% performance
         *      * 85+: Cannot enter events (hard block)
         *    - Applied in Season.handleCareerEventCompletion()
         * 
         * 7. REST & RUST SYSTEM (RestSystem)
         *    - applyRest(player, weeksRested, lightTraining)
         *      * Full Rest: -25 fatigue/week, but -0.3 avg and -0.5% checkout (rust)
         *      * Light Training: -15 fatigue/week, only -0.1 avg and -0.2% checkout
         *    - Rust is LIMITED: avg never below 70, checkout never below 20%
         *    - UI Buttons:
         *      * "Light Training" button: Maintain skills while recovering
         *      * "Full Rest" button: Maximum recovery, maximum rust
         *    - Called via Season.performCareerRest(lightTraining)
         * 
         * STRATEGIC GAMEPLAY LOOP:
         * ------------------------
         * Player makes meaningful decisions every day:
         * 
         * 1. Check upcoming events ‚Üí See entry costs and travel requirements
         * 2. Decide: Can I afford this event? Is my fatigue manageable?
         * 3. Enter events ‚Üí Money deducted, travel fatigue applied, location updated
         * 4. Play tournament ‚Üí Event fatigue accumulates based on matches played
         * 5. Monitor fatigue ‚Üí If approaching 85%, must rest or skip events
         * 6. Rest strategically ‚Üí Choose between full rest (rust) or light training
         * 7. Balance schedule ‚Üí Travel costs force regional planning
         * 8. Manage finances ‚Üí Entry fees + travel can drain balance quickly
         * 
         * INTEGRATION POINTS:
         * -------------------
         * - Season.init(): Calls EventEnrichment.enrichAllEvents()
         * - Season.createCareerPlayerFromHub(): Sets player.home and player.currentRegion
         * - Season.ensureCareerState(): Initializes career.playerHome and career.currentRegion
         * - Season.canCareerPlayerEnterEvent(): Checks EntrySystem.canEnterEvent()
         * - Season.enterCareerEvent(): NEW function to process entry before Tournament.start()
         * - Season.handleCareerEventCompletion(): Applies FatigueSystem.applyEventFatigue()
         * - Season.performCareerRest(lightTraining): Calls RestSystem.applyRest()
         * - Season.performCareerTraining(): Improves skills, minimal fatigue reduction
         * 
         * PLAYER PROPERTIES ADDED:
         * ------------------------
         * - player.home: { city, country, region }
         * - player.currentRegion: 'uk' | 'eu' | 'asia' | 'america' | 'oceania' | 'africa'
         * - player.money: Starting at ¬£5,000, deducted for entry fees and travel
         * - player.fatigue: 0-100 scale, blocks entry at 85+
         * 
         * CAREER STATE ADDITIONS:
         * -----------------------
         * - career.playerHome: { city, country, region }
         * - career.currentRegion: Tracks player's current location
         * - career.balance: Separate from world money (orderOfMerit)
         * 
         * EVENT PROPERTIES ADDED:
         * -----------------------
         * - event.venueId: Reference to VENUES_DB entry
         * - event.entryFee: Cost to enter the event (0-500)
         * - Automatically enriched via EventEnrichment.enrichEvent()
         * 
         * USAGE EXAMPLES:
         * ---------------
         * // Check if player can afford an event
         * const check = EntrySystem.canEnterEvent(event, player);
         * if (!check.canEnter) alert(check.reason);
         * 
         * // Enter an event (before Tournament.start())
         * if (Season.enterCareerEvent(event)) {
         *     Tournament.start(); // Proceed only if entry succeeded
         * }
         * 
         * // Rest with light training (less rust)
         * Season.performCareerRest(true);
         * 
         * // Calculate travel cost before committing
         * const cost = EntrySystem.calculateEntryCost(event, player);
         * console.log(`Total: ¬£${cost.totalCost} (Travel: ¬£${cost.travelCost}, Entry: ¬£${cost.entryFee})`);
         */
        window.VENUES_DB = [
            // UK Venues
            { id: 'arena-mk', name: 'Arena MK', city: 'Milton Keynes', country: 'England', region: 'uk', baseAccommodationCost: 80 },
            { id: 'alexandra-palace', name: 'Alexandra Palace', city: 'London', country: 'England', region: 'uk', baseAccommodationCost: 150 },
            { id: 'butlins-minehead', name: 'Butlins', city: 'Minehead', country: 'England', region: 'uk', baseAccommodationCost: 120 },
            { id: 'winter-gardens', name: 'Winter Gardens', city: 'Blackpool', country: 'England', region: 'uk', baseAccommodationCost: 90 },
            { id: 'robin-park', name: 'Robin Park Tennis Centre', city: 'Wigan', country: 'England', region: 'uk', baseAccommodationCost: 70 },
            { id: 'mattioli-arena', name: 'Mattioli Arena', city: 'Leicester', country: 'England', region: 'uk', baseAccommodationCost: 85 },
            { id: 'utilita-newcastle', name: 'Utilita Arena', city: 'Newcastle', country: 'England', region: 'uk', baseAccommodationCost: 75 },
            { id: 'ovo-hydro', name: 'OVO Hydro', city: 'Glasgow', country: 'Scotland', region: 'uk', baseAccommodationCost: 95 },
            { id: 'sse-belfast', name: 'SSE Arena', city: 'Belfast', country: 'Northern Ireland', region: 'uk', baseAccommodationCost: 85 },
            { id: 'utilita-cardiff', name: 'Utilita Arena', city: 'Cardiff', country: 'Wales', region: 'uk', baseAccommodationCost: 80 },
            { id: 'motorpoint-nottingham', name: 'Motorpoint Arena', city: 'Nottingham', country: 'England', region: 'uk', baseAccommodationCost: 75 },
            { id: '3arena-dublin', name: '3Arena', city: 'Dublin', country: 'Ireland', region: 'uk', baseAccommodationCost: 110 },
            { id: 'ao-manchester', name: 'AO Arena', city: 'Manchester', country: 'England', region: 'uk', baseAccommodationCost: 100 },
            { id: 'brighton-centre', name: 'Brighton Centre', city: 'Brighton', country: 'England', region: 'uk', baseAccommodationCost: 95 },
            { id: 'first-direct-leeds', name: 'First Direct Arena', city: 'Leeds', country: 'England', region: 'uk', baseAccommodationCost: 80 },
            { id: 'utilita-birmingham', name: 'Utilita Arena', city: 'Birmingham', country: 'England', region: 'uk', baseAccommodationCost: 85 },
            { id: 'utilita-sheffield', name: 'Utilita Arena', city: 'Sheffield', country: 'England', region: 'uk', baseAccommodationCost: 75 },
            { id: 'o2-london', name: 'The O2', city: 'London', country: 'England', region: 'uk', baseAccommodationCost: 180 },
            { id: 'ms-bank-liverpool', name: 'M&S Bank Arena', city: 'Liverpool', country: 'England', region: 'uk', baseAccommodationCost: 90 },
            { id: 'pj-live-aberdeen', name: 'P & J Live', city: 'Aberdeen', country: 'Scotland', region: 'uk', baseAccommodationCost: 85 },
            { id: 'aldersley-wolverhampton', name: 'Aldersley Leisure Village', city: 'Wolverhampton', country: 'England', region: 'uk', baseAccommodationCost: 80 },

            // European Venues
            { id: 'wunderland-kalkar', name: 'Wunderland', city: 'Kalkar', country: 'Germany', region: 'eu', baseAccommodationCost: 90 },
            { id: 'halle39-hildesheim', name: 'Halle 39', city: 'Hildesheim', country: 'Germany', region: 'eu', baseAccommodationCost: 85 },
            { id: 'afas-dome', name: 'AFAS Dome', city: 'Amsterdam', country: 'Netherlands', region: 'eu', baseAccommodationCost: 120 },
            { id: 'expo-krakow', name: 'EXPO', city: 'Krakow', country: 'Poland', region: 'eu', baseAccommodationCost: 60 },
            { id: 'hala-centralna', name: 'Hala Centralna', city: 'Krakow', country: 'Poland', region: 'eu', baseAccommodationCost: 60 },
            { id: 'lokhalle-gottingen', name: 'Lokhalle', city: 'Gottingen', country: 'Germany', region: 'eu', baseAccommodationCost: 85 },
            { id: 'oktoberhallen-wieze', name: 'Oktoberhallen', city: 'Wieze', country: 'Belgium', region: 'eu', baseAccommodationCost: 95 },
            { id: 'uber-arena-berlin', name: 'Uber Arena', city: 'Berlin', country: 'Germany', region: 'eu', baseAccommodationCost: 110 },
            { id: 'zenith-munich', name: 'Zenith', city: 'Munich', country: 'Germany', region: 'eu', baseAccommodationCost: 120 },
            { id: 'ahoy-rotterdam', name: 'Ahoy Arena', city: 'Rotterdam', country: 'Netherlands', region: 'eu', baseAccommodationCost: 105 },
            { id: 'glaspalast-sindelfingen', name: 'Glaspalast', city: 'Sindelfingen', country: 'Germany', region: 'eu', baseAccommodationCost: 100 },
            { id: 'stadthalle-graz', name: 'Stadthalle', city: 'Graz', country: 'Austria', region: 'eu', baseAccommodationCost: 90 },
            { id: 'wt-arena-riesa', name: 'WT Energiesysteme Arena', city: 'Riesa', country: 'Germany', region: 'eu', baseAccommodationCost: 80 },
            { id: 'wunderino-kiel', name: 'Wunderino Arena Europaplatz', city: 'Kiel', country: 'Germany', region: 'eu', baseAccommodationCost: 95 },
            { id: 'eissporthalle-frankfurt', name: 'Eissporthalle Frankfurt', city: 'Frankfurt', country: 'Germany', region: 'eu', baseAccommodationCost: 110 },
            { id: 'amsterdam-club-novezamky', name: 'Amsterdam Club', city: 'Nove Zamky', country: 'Slovakia', region: 'eu', baseAccommodationCost: 55 },
            { id: 'incheba-bratislava', name: 'Incheba Expo', city: 'Bratislava', country: 'Slovakia', region: 'eu', baseAccommodationCost: 70 },
            { id: 'ostermann-leverkusen', name: 'Ostermann-Arena', city: 'Leverkusen', country: 'Germany', region: 'eu', baseAccommodationCost: 95 },
            { id: 'smile-budapest', name: 'Smile Darts Club', city: 'Budapest', country: 'Hungary', region: 'eu', baseAccommodationCost: 65 },
            { id: 'mvm-dome-budapest', name: 'MVM Dome', city: 'Budapest', country: 'Hungary', region: 'eu', baseAccommodationCost: 75 },
            { id: 'pva-prague', name: 'PVA Expo', city: 'Prague', country: 'Czech Republic', region: 'eu', baseAccommodationCost: 80 },
            { id: 'antwerp-xpo', name: 'Antwerp Xpo', city: 'Antwerp', country: 'Belgium', region: 'eu', baseAccommodationCost: 100 },
            { id: 'afas-live-amsterdam', name: 'AFAS Live', city: 'Amsterdam', country: 'Netherlands', region: 'eu', baseAccommodationCost: 130 },
            { id: 'maasport', name: 'Maasport', city: 'Maastricht', country: 'Netherlands', region: 'eu', baseAccommodationCost: 90 },
            { id: 'mecc-maastricht', name: 'MECC', city: 'Maastricht', country: 'Netherlands', region: 'eu', baseAccommodationCost: 95 },
            { id: 'westfalenhalle-dortmund', name: 'Westfalenhalle', city: 'Dortmund', country: 'Germany', region: 'eu', baseAccommodationCost: 100 },
            { id: 'forum-copenhagen', name: 'Forum', city: 'Copenhagen', country: 'Denmark', region: 'eu', baseAccommodationCost: 140 },
            { id: 'st-jakobshalle-basel', name: 'St. Jakobshalle', city: 'Basel', country: 'Switzerland', region: 'eu', baseAccommodationCost: 150 },

            // Asian Venues
            { id: 'dome-manama', name: 'The Dome', city: 'Manama', country: 'Bahrain', region: 'asia', baseAccommodationCost: 180 },
            { id: 'global-theater-riyadh', name: 'Global Theater', city: 'Riyadh', country: 'Saudi Arabia', region: 'asia', baseAccommodationCost: 200 },

            // American Venues
            { id: 'msg-nyc', name: 'Madison Square Garden', city: 'New York', country: 'USA', region: 'america', baseAccommodationCost: 250 },

            // Oceania Venues
            { id: 'spark-arena-auckland', name: 'Spark Arena', city: 'Auckland', country: 'New Zealand', region: 'oceania', baseAccommodationCost: 180 },
            { id: 'win-wollongong', name: 'WIN Entertainment Centre', city: 'Wollongong', country: 'Australia', region: 'oceania', baseAccommodationCost: 170 }
        ];

        // ============================================================
        // EVENT ENRICHMENT - Add venues and entry fees to events
        // ============================================================
        window.EventEnrichment = {
            /**
             * Map venue names from events to venue IDs
             * This creates a dynamic mapping based on location keywords
             */
            venueMapping: {
                // UK
                'arena mk': 'arena-mk',
                'milton keynes': 'arena-mk',
                'alexandra palace': 'alexandra-palace',
                'ally pally': 'alexandra-palace',
                'butlins': 'butlins-minehead',
                'minehead': 'butlins-minehead',
                'winter gardens': 'winter-gardens',
                'blackpool': 'winter-gardens',
                'robin park': 'robin-park',
                'wigan': 'robin-park',
                'mattioli arena': 'mattioli-arena',
                'leicester': 'mattioli-arena',
                'newcastle': 'utilita-newcastle',
                'glasgow': 'ovo-hydro',
                'belfast': 'sse-belfast',
                'cardiff': 'utilita-cardiff',
                'nottingham': 'motorpoint-nottingham',
                'dublin': '3arena-dublin',
                'manchester': 'ao-manchester',
                'brighton': 'brighton-centre',
                'leeds': 'first-direct-leeds',
                'birmingham': 'utilita-birmingham',
                'sheffield': 'utilita-sheffield',
                'london': 'o2-london',
                'liverpool': 'ms-bank-liverpool',
                'aberdeen': 'pj-live-aberdeen',
                'wolverhampton': 'aldersley-wolverhampton',
                // EU
                'kalkar': 'wunderland-kalkar',
                'hildesheim': 'halle39-hildesheim',
                'amsterdam': 'afas-dome',
                'krakow': 'expo-krakow',
                'poland': 'expo-krakow',
                'gottingen': 'lokhalle-gottingen',
                'goettingen': 'lokhalle-gottingen',
                'wieze': 'oktoberhallen-wieze',
                'belgium': 'oktoberhallen-wieze',
                'berlin': 'uber-arena-berlin',
                'munich': 'zenith-munich',
                'rotterdam': 'ahoy-rotterdam',
                'sindelfingen': 'glaspalast-sindelfingen',
                'graz': 'stadthalle-graz',
                'austria': 'stadthalle-graz',
                'riesa': 'wt-arena-riesa',
                'kiel': 'wunderino-kiel',
                'frankfurt': 'eissporthalle-frankfurt',
                'nove zamky': 'amsterdam-club-novezamky',
                'bratislava': 'incheba-bratislava',
                'slovakia': 'incheba-bratislava',
                'leverkusen': 'ostermann-leverkusen',
                'budapest': 'mvm-dome-budapest',
                'hungary': 'mvm-dome-budapest',
                'prague': 'pva-prague',
                'czech': 'pva-prague',
                'antwerp': 'antwerp-xpo',
                'maastricht': 'mecc-maastricht',
                'dortmund': 'westfalenhalle-dortmund',
                'copenhagen': 'forum-copenhagen',
                'denmark': 'forum-copenhagen',
                'basel': 'st-jakobshalle-basel',
                'switzerland': 'st-jakobshalle-basel',
                // Asia
                'manama': 'dome-manama',
                'bahrain': 'dome-manama',
                'riyadh': 'global-theater-riyadh',
                'saudi': 'global-theater-riyadh',
                // America
                'new york': 'msg-nyc',
                'madison square': 'msg-nyc',
                // Oceania
                'auckland': 'spark-arena-auckland',
                'new zealand': 'spark-arena-auckland',
                'wollongong': 'win-wollongong',
                'australia': 'win-wollongong'
            },

            /**
             * Entry fees by event type
             */
            entryFees: {
                'q-school': 500,
                'challenge': 50,
                'players': 100,
                'development': 30,
                'euro-tour': 150,
                'minor': 200,
                'masters': 0,  // Invitational
                'premier-league': 0,  // Invitational
                'matchplay': 0,  // Qualified
                'uk-open': 75,
                'grand-slam': 0,  // Qualified
                'worlds': 0,  // Qualified
                'et-qual-tc': 0,  // Qualifier
                'et-host-nation': 75,
                'et-east-european': 75,
                'et-nordic-baltic': 75,
                'premier-league-playoff': 0,
                'winmaudm': 0,
                'wmasters-qual': 50
            },

            /**
             * Enrich an event with venue and entry fee
             */
            enrichEvent: (event) => {
                // Try to find venue from event name or existing location
                let venueId = null;

                const searchText = (event.name + ' ' + (event.location || '')).toLowerCase();
                for (const [keyword, vId] of Object.entries(EventEnrichment.venueMapping)) {
                    if (searchText.includes(keyword)) {
                        venueId = vId;
                        break;
                    }
                }

                // Fallback to default venues based on region/location
                if (!venueId) {
                    if (event.location === 'uk' || event.region === 'uk') venueId = 'arena-mk';
                    else if (event.location === 'eu' || event.region === 'eu') venueId = 'halle39-hildesheim';
                    else if (event.region === 'asia') venueId = 'dome-manama';
                    else if (event.region === 'america') venueId = 'msg-nyc';
                    else if (event.region === 'oceania') venueId = 'spark-arena-auckland';
                    else venueId = 'arena-mk'; // Final fallback
                }

                event.venueId = venueId;

                // Add entry fee based on event type
                const entryFee = EventEnrichment.entryFees[event.type] ?? 50;
                event.entryFee = entryFee;

                return event;
            },

            /**
             * Enrich all events in an array
             */
            enrichAllEvents: (events) => {
                return events.map(e => EventEnrichment.enrichEvent({ ...e }));
            }
        };

        // ============================================================
        // TRAVEL & LOCATION SYSTEM
        // ============================================================
        window.TravelSystem = {
            /**
             * Calculate travel cost and fatigue between two regions
             * @param {string} fromRegion - Starting region (uk, eu, asia, america, oceania, africa)
             * @param {string} toRegion - Destination region
             * @param {number} baseAccommodation - Base accommodation cost at destination
             * @returns {object} { travelCost, fatigueIncrease, accommodationCost, totalCost }
             */
            calculateTravel: (fromRegion, toRegion, baseAccommodation = 100) => {
                // Distance matrix: travel cost multipliers and fatigue points
                const travelMatrix = {
                    'uk': { 'uk': { cost: 50, fatigue: 2 }, 'eu': { cost: 150, fatigue: 5 }, 'asia': { cost: 600, fatigue: 15 }, 'america': { cost: 500, fatigue: 12 }, 'oceania': { cost: 1000, fatigue: 20 }, 'africa': { cost: 450, fatigue: 12 } },
                    'eu': { 'uk': { cost: 150, fatigue: 5 }, 'eu': { cost: 80, fatigue: 3 }, 'asia': { cost: 550, fatigue: 14 }, 'america': { cost: 550, fatigue: 13 }, 'oceania': { cost: 1050, fatigue: 22 }, 'africa': { cost: 400, fatigue: 11 } },
                    'asia': { 'uk': { cost: 600, fatigue: 15 }, 'eu': { cost: 550, fatigue: 14 }, 'asia': { cost: 300, fatigue: 8 }, 'america': { cost: 700, fatigue: 16 }, 'oceania': { cost: 600, fatigue: 14 }, 'africa': { cost: 500, fatigue: 12 } },
                    'america': { 'uk': { cost: 500, fatigue: 12 }, 'eu': { cost: 550, fatigue: 13 }, 'asia': { cost: 700, fatigue: 16 }, 'america': { cost: 200, fatigue: 6 }, 'oceania': { cost: 800, fatigue: 18 }, 'africa': { cost: 600, fatigue: 14 } },
                    'oceania': { 'uk': { cost: 1000, fatigue: 20 }, 'eu': { cost: 1050, fatigue: 22 }, 'asia': { cost: 600, fatigue: 14 }, 'america': { cost: 800, fatigue: 18 }, 'oceania': { cost: 250, fatigue: 7 }, 'africa': { cost: 700, fatigue: 16 } },
                    'africa': { 'uk': { cost: 450, fatigue: 12 }, 'eu': { cost: 400, fatigue: 11 }, 'asia': { cost: 500, fatigue: 12 }, 'america': { cost: 600, fatigue: 14 }, 'oceania': { cost: 700, fatigue: 16 }, 'africa': { cost: 150, fatigue: 5 } }
                };

                const travel = travelMatrix[fromRegion]?.[toRegion] || { cost: 300, fatigue: 10 };
                const travelCost = travel.cost;
                const fatigueIncrease = travel.fatigue;
                const accommodationCost = baseAccommodation * 3; // 3 nights average
                const totalCost = travelCost + accommodationCost;

                console.log(`[TravelSystem] ${fromRegion} ‚Üí ${toRegion}: Travel ¬£${travelCost} + Accommodation ¬£${accommodationCost} = ¬£${totalCost} (Fatigue: +${fatigueIncrease})`);

                return {
                    travelCost,
                    fatigueIncrease,
                    accommodationCost,
                    totalCost,
                    breakdown: `Travel: ¬£${travelCost} + Accommodation: ¬£${accommodationCost} = ¬£${totalCost}`
                };
            },

            /**
             * Get venue by ID
             * @param {string} venueId - Venue ID
             * @returns {object|null} Venue object or null
             */
            getVenue: (venueId) => {
                return VENUES_DB.find(v => v.id === venueId) || null;
            },

            /**
             * Resolve event location from venue ID
             * @param {object} event - Event object with venueId
             * @returns {object} { city, country, region, venueName }
             */
            resolveEventLocation: (event) => {
                if (!event.venueId) {
                    console.warn('[TravelSystem] Event missing venueId:', event.name);
                    return { city: 'Unknown', country: 'Unknown', region: 'uk', venueName: 'Unknown Venue' };
                }

                const venue = TravelSystem.getVenue(event.venueId);
                if (!venue) {
                    console.warn('[TravelSystem] Venue not found:', event.venueId);
                    return { city: 'Unknown', country: 'Unknown', region: 'uk', venueName: 'Unknown Venue' };
                }

                return {
                    city: venue.city,
                    country: venue.country,
                    region: venue.region,
                    venueName: venue.name,
                    baseAccommodation: venue.baseAccommodationCost
                };
            }
        };

        // ============================================================
        // ENTRY FEE & MONEY SYSTEM
        // ============================================================
        window.EntrySystem = {
            /**
             * Calculate total cost to enter an event
             * @param {object} event - Event object
             * @param {object} player - Player object with currentRegion
             * @returns {object} { entryFee, travelCost, totalCost, canAfford, reason }
             */
            calculateEntryCost: (event, player) => {
                const entryFee = event.entryFee || 0;
                const location = TravelSystem.resolveEventLocation(event);

                // Calculate travel if player is in different region
                const playerRegion = player.currentRegion || player.home?.region || 'uk';
                const eventRegion = location.region;

                console.log(`[EntrySystem] Calculating cost for ${event.name}. Player region: ${playerRegion}, Event region: ${eventRegion}`);

                let travelCost = 0;
                let fatigueFromTravel = 0;

                if (playerRegion !== eventRegion) {
                    const travelData = TravelSystem.calculateTravel(playerRegion, eventRegion, location.baseAccommodation || 100);
                    travelCost = travelData.totalCost;
                    fatigueFromTravel = travelData.fatigueIncrease;
                } else {
                    console.log(`[EntrySystem] Same region, no travel cost`);
                }

                const totalCost = entryFee + travelCost;
                const playerMoney = player.money || 0;
                const canAfford = playerMoney >= totalCost;

                console.log(`[EntrySystem] Total cost: ¬£${totalCost} (Entry: ¬£${entryFee}, Travel: ¬£${travelCost}), Player money: ¬£${playerMoney}, Can afford: ${canAfford}`);

                return {
                    entryFee,
                    travelCost,
                    totalCost,
                    canAfford,
                    fatigueFromTravel,
                    reason: !canAfford ? `Insufficient funds. Need ¬£${totalCost}, have ¬£${playerMoney}` : 'OK',
                    breakdown: `Entry: ¬£${entryFee} + Travel: ¬£${travelCost} = ¬£${totalCost}`
                };
            },

            /**
             * Check if player can enter an event
             * @param {object} event - Event object
             * @param {object} player - Player object
             * @returns {object} { canEnter, canAfford, reason, cost }
             */
            canEnterEvent: (event, player) => {
                // Check fatigue threshold (hard block at 85+)
                if (player.fatigue >= 85) {
                    return {
                        canEnter: false,
                        canAfford: true, // Fatigue issue, not money
                        reason: 'Fatigue too high (85+). Must rest.',
                        cost: 0
                    };
                }

                // Calculate entry cost
                const costData = EntrySystem.calculateEntryCost(event, player);

                if (!costData.canAfford) {
                    return {
                        canEnter: false,
                        canAfford: false, // Money issue
                        reason: costData.reason,
                        cost: costData.totalCost
                    };
                }

                // Check if event requires tour card
                if (event.cardRequired && !(player.hasTourCard || player.tourCard)) {
                    return {
                        canEnter: false,
                        canAfford: true, // Tour card issue, not money
                        reason: 'Tour card required',
                        cost: costData.totalCost
                    };
                }

                return {
                    canEnter: true,
                    canAfford: true,
                    reason: 'OK',
                    cost: costData.totalCost,
                    fatigueIncrease: costData.fatigueFromTravel
                };
            },

            /**
             * Process event entry (deduct money, add fatigue, update location)
             * @param {object} event - Event object
             * @param {object} player - Player object
             * @returns {object} { success, message }
             */
            enterEvent: (event, player) => {
                const check = EntrySystem.canEnterEvent(event, player);

                if (!check.canEnter) {
                    return {
                        success: false,
                        message: check.reason
                    };
                }

                // Deduct money
                player.money -= check.cost;

                // Add travel fatigue
                if (check.fatigueIncrease) {
                    player.fatigue = Math.min(100, (player.fatigue || 0) + check.fatigueIncrease);
                }

                // Update player location
                const location = TravelSystem.resolveEventLocation(event);
                player.currentRegion = location.region;

                return {
                    success: true,
                    message: `Entry confirmed. Paid ¬£${check.cost}. Fatigue: ${player.fatigue}`
                };
            }
        };

        // ============================================================
        // FATIGUE SYSTEM
        // ============================================================
        window.FatigueSystem = {
            /**
             * Apply fatigue from playing an event
             * @param {object} player - Player object
             * @param {object} event - Event object
             * @param {number} matchesPlayed - Number of matches played
             */
            applyEventFatigue: (player, event, matchesPlayed = 1) => {
                // Base fatigue per event day
                const baseFatigue = 2;

                // Additional fatigue based on matches played
                const matchFatigue = matchesPlayed * 1;

                // Multi-day event fatigue multiplier
                const eventDays = event.days || 1;
                const dayMultiplier = eventDays > 1 ? 1.2 : 1;

                const totalFatigue = (baseFatigue + matchFatigue) * dayMultiplier;

                player.fatigue = Math.min(100, (player.fatigue || 0) + totalFatigue);

                console.log(`[FatigueSystem] Player ${player.name} gained ${totalFatigue.toFixed(1)} fatigue. Total: ${player.fatigue.toFixed(1)}`);
            },

            /**
             * Get performance modifier based on fatigue
             * @param {number} fatigue - Fatigue level (0-100)
             * @returns {number} Performance modifier (0.5 to 1.0)
             */
            getPerformanceModifier: (fatigue) => {
                if (fatigue < 20) return 1.0; // No penalty
                if (fatigue < 40) return 0.98;
                if (fatigue < 60) return 0.95;
                if (fatigue < 75) return 0.90;
                if (fatigue < 85) return 0.85;
                return 0.70; // Heavy penalty (but can still play if forced)
            }
        };

        // ============================================================
        // REST & RUST SYSTEM
        // ============================================================
        window.RestSystem = {
            /**
             * Apply rest effects (reduce fatigue, but introduce rust)
             * @param {object} player - Player object
             * @param {number} weeksRested - Number of weeks resting
             * @param {boolean} lightTraining - Whether player did light training
             * @returns {object} { fatigueReduced, avgLoss, coLoss }
             */
            applyRest: (player, weeksRested = 1, lightTraining = false) => {
                // Fatigue reduction
                const fatigueReduction = lightTraining ? 30 * weeksRested : 50 * weeksRested;
                const oldFatigue = player.fatigue || 0;
                player.fatigue = Math.max(0, oldFatigue - fatigueReduction);

                // Rust (skill degradation)
                let avgLoss = 0;
                let coLoss = 0;

                if (!lightTraining) {
                    // Full rest causes rust
                    avgLoss = 0.15 * weeksRested; // Lose 0.15 avg per week
                    coLoss = 0.25 * weeksRested;  // Lose 0.25 checkout % per week
                } else {
                    // Light training reduces rust
                    avgLoss = 0.05 * weeksRested;
                    coLoss = 0.1 * weeksRested;
                }

                // Apply rust (never below certain thresholds)
                const minAvg = 70; // Never go below 70 avg
                const minCo = 20;  // Never go below 20% checkout

                player.avg = Math.max(minAvg, (player.avg || 85) - avgLoss);
                player.co = Math.max(minCo, (player.co || 35) - coLoss);

                console.log(`[RestSystem] ${player.name} rested ${weeksRested} week(s). Fatigue: ${oldFatigue.toFixed(1)} ‚Üí ${player.fatigue.toFixed(1)}. Rust: -${avgLoss.toFixed(1)} avg, -${coLoss.toFixed(1)}% co`);

                return {
                    fatigueReduced: fatigueReduction,
                    avgLoss: avgLoss.toFixed(1),
                    coLoss: coLoss.toFixed(1),
                    newFatigue: player.fatigue.toFixed(1),
                    newAvg: player.avg.toFixed(1),
                    newCo: player.co.toFixed(1)
                };
            },

            /**
             * Recover from rust through playing
             * @param {object} player - Player object
             * @param {object} performance - Match performance data
             */
            recoverFromRust: (player, performance) => {
                // Playing well recovers rust gradually
                if (performance.avg > player.avg) {
                    player.avg = Math.min(player.avg + 0.2, performance.avg);
                }

                if (performance.checkoutPercent > player.co) {
                    player.co = Math.min(player.co + 0.3, performance.checkoutPercent);
                }
            }
        };

        window.Season = {
            addNews: (text) => {
                console.log('[Season.addNews] Called with:', text);
                let type = 'general';
                let data = { event: 'Season', player: '', isMajorWin: false };

                if (text.includes('withdraws from')) {
                    type = 'withdrawal';
                    const parts = text.split(' withdraws from ');
                    data.player = parts[0];
                    data.event = parts[1] ? parts[1].replace(' due to fatigue.', '') : 'Event';

                    console.log('[Season.addNews] Adding withdrawal news:', data);
                    NewsSystem.add(type, { ...data, player: data.player, event: data.event });
                    return;
                }

                if (text.includes('enters') && text.includes('as a replacement')) {
                    type = 'replacement';
                    const parts = text.split(' enters ');
                    data.player = parts[0];
                    const eventPart = parts[1] ? parts[1].split(' as a')[0] : 'Event';
                    data.event = eventPart;

                    console.log('[Season.addNews] Adding replacement news:', data);
                    NewsSystem.add(type, { ...data, player: data.player, event: data.event });
                    return;
                }

                // Generic fallback
                console.log('[Season.addNews] Adding generic news');
                NewsSystem.add(type, { player: "", event: "Season", overrideText: text });
            },

            // Default events (fallback if database is empty or unavailable)
            defaultEvents: [
                { id: 1, name: "Q-SCHOOL UK - First Stage Day 1", date: "Jan 05", format: "legs", players: 128, type: 'q-school', cardRequired: false, location: 'uk', eligibleRegions: ['eng', 'wal', 'sco', 'nir', 'irl'] },
                { id: 2, name: "Q-SCHOOL UK - First Stage Day 2", date: "Jan 06", format: "legs", players: 128, type: 'q-school', cardRequired: false, location: 'uk', eligibleRegions: ['eng', 'wal', 'sco', 'nir', 'irl'] },
                { id: 3, name: "Q-SCHOOL UK - First Stage Day 3", date: "Jan 07", format: "legs", players: 128, type: 'q-school', cardRequired: false, location: 'uk', eligibleRegions: ['eng', 'wal', 'sco', 'nir', 'irl'] },
                { id: 10, name: "Q-SCHOOL EU - First Stage Day 1", date: "Jan 05", format: "legs", players: 128, type: 'q-school', cardRequired: false, location: 'eu', eligibleRegions: ['ger', 'nl', 'bel', 'fra', 'aut', 'cze', 'pol', 'sui', 'esp', 'ita', 'svk', 'rou', 'hun'] },
                { id: 11, name: "Q-SCHOOL EU - First Stage Day 2", date: "Jan 06", format: "legs", players: 128, type: 'q-school', cardRequired: false, location: 'eu', eligibleRegions: ['ger', 'nl', 'bel', 'fra', 'aut', 'cze', 'pol', 'sui', 'esp', 'ita', 'svk', 'rou', 'hun'] },
                { id: 12, name: "Q-SCHOOL EU - Final Stage Day 3", date: "Jan 07", format: "legs", players: 128, type: 'q-school', cardRequired: false, location: 'eu', eligibleRegions: ['ger', 'nl', 'bel', 'fra', 'aut', 'cze', 'pol', 'sui', 'esp', 'ita', 'svk', 'rou', 'hun'] },
                { id: 4, name: "Q-SCHOOL UK - Final Stage Day 1", date: "Jan 08", format: "legs", players: 128, type: 'q-school', cardRequired: false, location: 'uk', eligibleRegions: ['eng', 'wal', 'sco', 'nir', 'irl'] },
                { id: 5, name: "Q-SCHOOL UK - Final Stage Day 2", date: "Jan 09", format: "legs", players: 128, type: 'q-school', cardRequired: false, location: 'uk', eligibleRegions: ['eng', 'wal', 'sco', 'nir', 'irl'] },
                { id: 6, name: "Q-SCHOOL UK - Final Stage Day 3", date: "Jan 10", format: "legs", players: 128, type: 'q-school', cardRequired: false, location: 'uk', eligibleRegions: ['eng', 'wal', 'sco', 'nir', 'irl'] },
                { id: 7, name: "Q-SCHOOL UK - Final Stage Day 4", date: "Jan 11", format: "legs", players: 128, type: 'q-school', cardRequired: false, location: 'uk', eligibleRegions: ['eng', 'wal', 'sco', 'nir', 'irl'] },
                { id: 13, name: "Q-SCHOOL EU - Final Stage Day 1", date: "Jan 08", format: "legs", players: 128, type: 'q-school', cardRequired: false, location: 'eu', eligibleRegions: ['ger', 'nl', 'bel', 'fra', 'aut', 'cze', 'pol', 'sui', 'esp', 'ita', 'svk', 'rou', 'hun'] },
                { id: 14, name: "Q-SCHOOL EU - Final Stage Day 2", date: "Jan 09", format: "legs", players: 128, type: 'q-school', cardRequired: false, location: 'eu', eligibleRegions: ['ger', 'nl', 'bel', 'fra', 'aut', 'cze', 'pol', 'sui', 'esp', 'ita', 'svk', 'rou', 'hun'] },
                { id: 15, name: "Q-SCHOOL EU - Final Stage Day 3", date: "Jan 10", format: "legs", players: 128, type: 'q-school', cardRequired: false, location: 'eu', eligibleRegions: ['ger', 'nl', 'bel', 'fra', 'aut', 'cze', 'pol', 'sui', 'esp', 'ita', 'svk', 'rou', 'hun'] },
                { id: 16, name: "Q-SCHOOL EU - Final Stage Day 4", date: "Jan 11", format: "legs", players: 128, type: 'q-school', cardRequired: false, location: 'eu', eligibleRegions: ['ger', 'nl', 'bel', 'fra', 'aut', 'cze', 'pol', 'sui', 'esp', 'ita', 'svk', 'rou', 'hun'] },
                { id: 17, name: "BAHRAIN MASTERS", date: "Jan 16", format: "legs", players: 16, region: "asia", type: 'masters', cardRequired: false },
                { id: 101, name: "CHALLENGE TOUR 01", date: "Jan 16", format: "legs", players: 128, type: "challenge", cardRequired: false },
                { id: 102, name: "CHALLENGE TOUR 02", date: "Jan 16", format: "legs", players: 128, type: "challenge", cardRequired: false },
                { id: 103, name: "CHALLENGE TOUR 03", date: "Jan 17", format: "legs", players: 128, type: "challenge", cardRequired: false },
                { id: 104, name: "CHALLENGE TOUR 04", date: "Jan 17", format: "legs", players: 128, type: "challenge", cardRequired: false },
                { id: 105, name: "CHALLENGE TOUR 05", date: "Jan 18", format: "legs", players: 128, type: "challenge", cardRequired: false },
                { id: 9, name: "RIYADH DARTS MASTERS", date: "Jan 19", format: "legs", players: 16, region: "asia", type: 'masters', cardRequired: false },
                { id: 800, name: "WINMAU WORLD MASTERS PRELIMINARY ROUNDS", date: "Jan 28", format: "legs", players: 64, type: 'wmasters-qual', targetEvent: 206, slots: 8, cardRequired: false },
                { id: 206, name: "WINMAU WORLD MASTERS", date: "Feb 02", format: "sets", players: 32, type: 'winmaudm', cardRequired: true },
                { id: 18, name: "PREMIER LEAGUE - Night 1", date: "Feb 05", format: "legs", players: 8, type: 'premier-league', cardRequired: true, night: 1 },
                { id: 201, name: "PLAYERS CHAMPIONSHIP 1", date: "Feb 09", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 19, name: "PREMIER LEAGUE - Night 2", date: "Feb 12", format: "legs", players: 8, type: 'premier-league', cardRequired: true, night: 2 },
                { id: 202, name: "PLAYERS CHAMPIONSHIP 2", date: "Feb 10", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 203, name: "PLAYERS CHAMPIONSHIP 3", date: "Feb 16", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 601, name: "ET1 TOUR CARD QUALIFIER", date: "Feb 11", format: "legs", players: 64, type: "et-qual-tc", targetEvent: 501, slots: 10, cardRequired: true },
                { id: 621, name: "ET1 HOST NATION QUALIFIER", date: "Feb 11", format: "legs", players: 8, type: "et-host-nation", targetEvent: 501, slots: 4, cardRequired: false },
                { id: 622, name: "ET1 EAST EUROPEAN QUALIFIER", date: "Feb 11", format: "legs", players: 16, type: "et-east-european", targetEvent: 501, slots: 1, cardRequired: false },
                { id: 623, name: "ET1 NORDIC & BALTIC QUALIFIER", date: "Feb 11", format: "legs", players: 16, type: "et-nordic-baltic", targetEvent: 501, slots: 1, cardRequired: false },
                { id: 602, name: "ET2 TOUR CARD QUALIFIER", date: "Feb 11", format: "legs", players: 64, type: "et-qual-tc", targetEvent: 502, slots: 10, cardRequired: true },
                { id: 624, name: "ET2 HOST NATION QUALIFIER", date: "Feb 11", format: "legs", players: 8, type: "et-host-nation", targetEvent: 502, slots: 4, cardRequired: false },
                { id: 625, name: "ET2 EAST EUROPEAN QUALIFIER", date: "Feb 11", format: "legs", players: 16, type: "et-east-european", targetEvent: 502, slots: 1, cardRequired: false },
                { id: 626, name: "ET2 NORDIC & BALTIC QUALIFIER", date: "Feb 11", format: "legs", players: 16, type: "et-nordic-baltic", targetEvent: 502, slots: 1, cardRequired: false },
                { id: 501, name: "POLAND DARTS OPEN", date: "Feb 22", format: "legs", players: 48, type: 'minor', cardRequired: true },
                { id: 204, name: "PLAYERS CHAMPIONSHIP 4", date: "Feb 17", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 205, name: "PLAYERS CHAMPIONSHIP 5", date: "Feb 24", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 206, name: "PLAYERS CHAMPIONSHIP 6", date: "Feb 25", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 21, name: "PREMIER LEAGUE - Night 3", date: "Feb 19", format: "legs", players: 8, type: 'premier-league', cardRequired: true, night: 3 },
                { id: 22, name: "PREMIER LEAGUE - Night 4", date: "Feb 26", format: "legs", players: 8, type: 'premier-league', cardRequired: true, night: 4 },
                { id: 23, name: "UK OPEN", date: "Mar 03", format: "legs", players: 128, type: 'uk-open', cardRequired: false },
                { id: 24, name: "PREMIER LEAGUE - Night 5", date: "Mar 05", format: "legs", players: 8, type: 'premier-league', cardRequired: true, night: 5 },
                { id: 502, name: "EUROPEAN DARTS TROPHY", date: "Mar 15", format: "legs", players: 48, type: 'minor', cardRequired: true },
                { id: 603, name: "ET3 TOUR CARD QUALIFIER", date: "Feb 18", format: "legs", players: 64, type: "et-qual-tc", targetEvent: 503, slots: 10, cardRequired: true },
                { id: 627, name: "ET3 HOST NATION QUALIFIER", date: "Feb 18", format: "legs", players: 8, type: "et-host-nation", targetEvent: 503, slots: 4, cardRequired: false },
                { id: 628, name: "ET3 EAST EUROPEAN QUALIFIER", date: "Feb 18", format: "legs", players: 16, type: "et-east-european", targetEvent: 503, slots: 1, cardRequired: false },
                { id: 629, name: "ET3 NORDIC & BALTIC QUALIFIER", date: "Feb 18", format: "legs", players: 16, type: "et-nordic-baltic", targetEvent: 503, slots: 1, cardRequired: false },
                { id: 604, name: "ET4 TOUR CARD QUALIFIER", date: "Feb 18", format: "legs", players: 64, type: "et-qual-tc", targetEvent: 504, slots: 10, cardRequired: true },
                { id: 630, name: "ET4 HOST NATION QUALIFIER", date: "Feb 18", format: "legs", players: 8, type: "et-host-nation", targetEvent: 504, slots: 4, cardRequired: false },
                { id: 631, name: "ET4 EAST EUROPEAN QUALIFIER", date: "Feb 18", format: "legs", players: 16, type: "et-east-european", targetEvent: 504, slots: 1, cardRequired: false },
                { id: 632, name: "ET4 NORDIC & BALTIC QUALIFIER", date: "Feb 18", format: "legs", players: 16, type: "et-nordic-baltic", targetEvent: 504, slots: 1, cardRequired: false },
                { id: 134, name: "PREMIER LEAGUE - Night 6", date: "Mar 12", format: "legs", players: 8, type: 'premier-league', cardRequired: true, night: 6 },
                { id: 503, name: "BELGIAN DARTS OPEN", date: "Mar 22", format: "legs", players: 48, type: 'minor', cardRequired: true },
                { id: 135, name: "PREMIER LEAGUE - Night 7", date: "Mar 19", format: "legs", players: 8, type: 'premier-league', cardRequired: true, night: 7 },
                { id: 206, name: "CHALLENGE TOUR 06", date: "Mar 27", format: "legs", players: 128, type: "challenge", cardRequired: false },
                { id: 207, name: "CHALLENGE TOUR 07", date: "Mar 27", format: "legs", players: 128, type: "challenge", cardRequired: false },
                { id: 208, name: "CHALLENGE TOUR 08", date: "Mar 28", format: "legs", players: 128, type: "challenge", cardRequired: false },
                { id: 209, name: "CHALLENGE TOUR 09", date: "Mar 28", format: "legs", players: 128, type: "challenge", cardRequired: false },
                { id: 210, name: "CHALLENGE TOUR 10", date: "Mar 29", format: "legs", players: 128, type: "challenge", cardRequired: false },
                { id: 107, name: "PLAYERS CHAMPIONSHIP 7", date: "Mar 30", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 136, name: "PREMIER LEAGUE - Night 8", date: "Mar 26", format: "legs", players: 8, type: 'premier-league', cardRequired: true, night: 8 },
                { id: 108, name: "PLAYERS CHAMPIONSHIP 8", date: "Mar 31", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 504, name: "GERMAN DARTS GRAND PRIX", date: "Apr 04", format: "legs", players: 48, type: 'minor', cardRequired: true },
                { id: 137, name: "PREMIER LEAGUE - Night 9", date: "Apr 02", format: "legs", players: 8, type: 'premier-league', cardRequired: true, night: 9 },
                { id: 109, name: "PLAYERS CHAMPIONSHIP 9", date: "Apr 13", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 138, name: "PREMIER LEAGUE - Night 10", date: "Apr 09", format: "legs", players: 8, type: 'premier-league', cardRequired: true, night: 10 },
                { id: 110, name: "PLAYERS CHAMPIONSHIP 10", date: "Apr 14", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 605, name: "ET5 TOUR CARD QUALIFIER", date: "Apr 01", format: "legs", players: 64, type: "et-qual-tc", targetEvent: 505, slots: 10, cardRequired: true },
                { id: 633, name: "ET5 HOST NATION QUALIFIER", date: "Apr 01", format: "legs", players: 8, type: "et-host-nation", targetEvent: 505, slots: 4, cardRequired: false },
                { id: 634, name: "ET5 EAST EUROPEAN QUALIFIER", date: "Apr 01", format: "legs", players: 16, type: "et-east-european", targetEvent: 505, slots: 1, cardRequired: false },
                { id: 635, name: "ET5 NORDIC & BALTIC QUALIFIER", date: "Apr 01", format: "legs", players: 16, type: "et-nordic-baltic", targetEvent: 505, slots: 1, cardRequired: false },
                { id: 606, name: "ET6 TOUR CARD QUALIFIER", date: "Apr 01", format: "legs", players: 64, type: "et-qual-tc", targetEvent: 506, slots: 10, cardRequired: true },
                { id: 636, name: "ET6 HOST NATION QUALIFIER", date: "Apr 01", format: "legs", players: 8, type: "et-host-nation", targetEvent: 506, slots: 4, cardRequired: false },
                { id: 637, name: "ET6 EAST EUROPEAN QUALIFIER", date: "Apr 01", format: "legs", players: 16, type: "et-east-european", targetEvent: 506, slots: 1, cardRequired: false },
                { id: 638, name: "ET6 NORDIC & BALTIC QUALIFIER", date: "Apr 01", format: "legs", players: 16, type: "et-nordic-baltic", targetEvent: 506, slots: 1, cardRequired: false },
                { id: 505, name: "EUROPEAN DARTS GRAND PRIX", date: "Apr 19", format: "legs", players: 48, type: 'minor', cardRequired: true },
                { id: 139, name: "PREMIER LEAGUE - Night 11", date: "Apr 16", format: "legs", players: 8, type: 'premier-league', cardRequired: true, night: 11 },
                { id: 111, name: "PLAYERS CHAMPIONSHIP 11", date: "Apr 27", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 140, name: "PREMIER LEAGUE - Night 12", date: "Apr 23", format: "legs", players: 8, type: 'premier-league', cardRequired: true, night: 12 },
                { id: 112, name: "PLAYERS CHAMPIONSHIP 12", date: "Apr 28", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 211, name: "CHALLENGE TOUR 11", date: "May 01", format: "legs", players: 128, type: "challenge", cardRequired: false },
                { id: 212, name: "CHALLENGE TOUR 12", date: "May 01", format: "legs", players: 128, type: "challenge", cardRequired: false },
                { id: 213, name: "CHALLENGE TOUR 13", date: "May 02", format: "legs", players: 128, type: "challenge", cardRequired: false },
                { id: 214, name: "CHALLENGE TOUR 14", date: "May 02", format: "legs", players: 128, type: "challenge", cardRequired: false },
                { id: 215, name: "CHALLENGE TOUR 15", date: "May 03", format: "legs", players: 128, type: "challenge", cardRequired: false },
                { id: 113, name: "PLAYERS CHAMPIONSHIP 13", date: "May 04", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 114, name: "PLAYERS CHAMPIONSHIP 14", date: "May 05", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 506, name: "AUSTRIAN DARTS OPEN", date: "May 10", format: "legs", players: 48, type: 'minor', cardRequired: true },
                { id: 141, name: "PREMIER LEAGUE - Night 13", date: "Apr 30", format: "legs", players: 8, type: 'premier-league', cardRequired: true, night: 13 },
                { id: 115, name: "PLAYERS CHAMPIONSHIP 15", date: "May 12", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 142, name: "PREMIER LEAGUE - Night 14", date: "May 07", format: "legs", players: 8, type: 'premier-league', cardRequired: true, night: 14 },
                { id: 116, name: "PLAYERS CHAMPIONSHIP 16", date: "May 13", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 143, name: "PREMIER LEAGUE - Night 15", date: "May 14", format: "legs", players: 8, type: 'premier-league', cardRequired: true, night: 15 },
                { id: 117, name: "PLAYERS CHAMPIONSHIP 17", date: "May 18", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 118, name: "PLAYERS CHAMPIONSHIP 18", date: "May 19", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 607, name: "ET7 TOUR CARD QUALIFIER", date: "Apr 15", format: "legs", players: 64, type: "et-qual-tc", targetEvent: 507, slots: 10, cardRequired: true },
                { id: 639, name: "ET7 HOST NATION QUALIFIER", date: "Apr 15", format: "legs", players: 8, type: "et-host-nation", targetEvent: 507, slots: 4, cardRequired: false },
                { id: 640, name: "ET7 EAST EUROPEAN QUALIFIER", date: "Apr 15", format: "legs", players: 16, type: "et-east-european", targetEvent: 507, slots: 1, cardRequired: false },
                { id: 641, name: "ET7 NORDIC & BALTIC QUALIFIER", date: "Apr 15", format: "legs", players: 16, type: "et-nordic-baltic", targetEvent: 507, slots: 1, cardRequired: false },
                { id: 608, name: "ET8 TOUR CARD QUALIFIER", date: "Apr 15", format: "legs", players: 64, type: "et-qual-tc", targetEvent: 508, slots: 10, cardRequired: true },
                { id: 642, name: "ET8 HOST NATION QUALIFIER", date: "Apr 15", format: "legs", players: 8, type: "et-host-nation", targetEvent: 508, slots: 4, cardRequired: false },
                { id: 643, name: "ET8 EAST EUROPEAN QUALIFIER", date: "Apr 15", format: "legs", players: 16, type: "et-east-european", targetEvent: 508, slots: 1, cardRequired: false },
                { id: 644, name: "ET8 NORDIC & BALTIC QUALIFIER", date: "Apr 15", format: "legs", players: 16, type: "et-nordic-baltic", targetEvent: 508, slots: 1, cardRequired: false },
                { id: 507, name: "INTERNATIONAL DARTS OPEN", date: "May 24", format: "legs", players: 48, type: 'minor', cardRequired: true },
                { id: 144, name: "PREMIER LEAGUE - Night 16", date: "May 21", format: "legs", players: 8, type: 'premier-league', cardRequired: true, night: 16 },
                { id: 145, name: "PREMIER LEAGUE - Playoffs", date: "May 28", format: "legs", players: 4, type: 'premier-league-playoff', cardRequired: true },
                { id: 508, name: "BALTIC SEA DARTS OPEN", date: "May 31", format: "legs", players: 48, type: 'minor', cardRequired: true },
                { id: 119, name: "PLAYERS CHAMPIONSHIP 19", date: "Jun 02", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 120, name: "PLAYERS CHAMPIONSHIP 20", date: "Jun 03", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 15, name: "NORDIC DARTS MASTERS", date: "Jun 06", format: "legs", players: 16, region: "nordic", type: 'masters', cardRequired: false },
                { id: 121, name: "PLAYERS CHAMPIONSHIP 21", date: "Jun 16", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 122, name: "PLAYERS CHAMPIONSHIP 22", date: "Jun 17", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 609, name: "ET9 TOUR CARD QUALIFIER", date: "May 20", format: "legs", players: 64, type: "et-qual-tc", targetEvent: 509, slots: 10, cardRequired: true },
                { id: 645, name: "ET9 HOST NATION QUALIFIER", date: "May 20", format: "legs", players: 8, type: "et-host-nation", targetEvent: 509, slots: 4, cardRequired: false },
                { id: 646, name: "ET9 EAST EUROPEAN QUALIFIER", date: "May 20", format: "legs", players: 16, type: "et-east-european", targetEvent: 509, slots: 1, cardRequired: false },
                { id: 647, name: "ET9 NORDIC & BALTIC QUALIFIER", date: "May 20", format: "legs", players: 16, type: "et-nordic-baltic", targetEvent: 509, slots: 1, cardRequired: false },
                { id: 610, name: "ET10 TOUR CARD QUALIFIER", date: "May 20", format: "legs", players: 64, type: "et-qual-tc", targetEvent: 510, slots: 10, cardRequired: true },
                { id: 648, name: "ET10 HOST NATION QUALIFIER", date: "May 20", format: "legs", players: 8, type: "et-host-nation", targetEvent: 510, slots: 4, cardRequired: false },
                { id: 649, name: "ET10 EAST EUROPEAN QUALIFIER", date: "May 20", format: "legs", players: 16, type: "et-east-european", targetEvent: 510, slots: 1, cardRequired: false },
                { id: 650, name: "ET10 NORDIC & BALTIC QUALIFIER", date: "May 20", format: "legs", players: 16, type: "et-nordic-baltic", targetEvent: 510, slots: 1, cardRequired: false },
                { id: 509, name: "SLOVAK DARTS OPEN", date: "Jun 19", format: "legs", players: 48, type: 'minor', cardRequired: true },
                { id: 17, name: "US MASTERS", date: "Jun 26", format: "legs", players: 16, region: "america", type: 'masters', cardRequired: false },
                { id: 123, name: "PLAYERS CHAMPIONSHIP 23", date: "Jul 06", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 124, name: "PLAYERS CHAMPIONSHIP 24", date: "Jul 07", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 510, name: "EUROPEAN DARTS OPEN", date: "Jul 12", format: "legs", players: 48, type: 'minor', cardRequired: true },
                { id: 19, name: "MATCHPLAY", date: "Jul 26", format: "legs", players: 32, type: 'matchplay', cardRequired: true },
                { id: 125, name: "PLAYERS CHAMPIONSHIP 25", date: "Jul 28", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 126, name: "PLAYERS CHAMPIONSHIP 26", date: "Jul 29", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 216, name: "CHALLENGE TOUR 16", date: "Aug 14", format: "legs", players: 128, type: "challenge", cardRequired: false },
                { id: 217, name: "CHALLENGE TOUR 17", date: "Aug 14", format: "legs", players: 128, type: "challenge", cardRequired: false },
                { id: 20, name: "NEW ZEALAND MASTERS", date: "Aug 15", format: "legs", players: 16, region: "oceania", type: 'masters', cardRequired: false },
                { id: 218, name: "CHALLENGE TOUR 18", date: "Aug 15", format: "legs", players: 128, type: "challenge", cardRequired: false },
                { id: 219, name: "CHALLENGE TOUR 19", date: "Aug 15", format: "legs", players: 128, type: "challenge", cardRequired: false },
                { id: 220, name: "CHALLENGE TOUR 20", date: "Aug 16", format: "legs", players: 128, type: "challenge", cardRequired: false },
                { id: 21, name: "AUSTRALIAN DARTS MASTERS", date: "Aug 22", format: "legs", players: 16, region: "oceania", type: 'masters', cardRequired: false },
                { id: 127, name: "PLAYERS CHAMPIONSHIP 27", date: "Aug 25", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 128, name: "PLAYERS CHAMPIONSHIP 28", date: "Aug 26", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 611, name: "ET11 TOUR CARD QUALIFIER", date: "Jul 08", format: "legs", players: 64, type: "et-qual-tc", targetEvent: 511, slots: 10, cardRequired: true },
                { id: 651, name: "ET11 HOST NATION QUALIFIER", date: "Jul 08", format: "legs", players: 8, type: "et-host-nation", targetEvent: 511, slots: 4, cardRequired: false },
                { id: 652, name: "ET11 EAST EUROPEAN QUALIFIER", date: "Jul 08", format: "legs", players: 16, type: "et-east-european", targetEvent: 511, slots: 1, cardRequired: false },
                { id: 653, name: "ET11 NORDIC & BALTIC QUALIFIER", date: "Jul 08", format: "legs", players: 16, type: "et-nordic-baltic", targetEvent: 511, slots: 1, cardRequired: false },
                { id: 612, name: "ET12 TOUR CARD QUALIFIER", date: "Jul 08", format: "legs", players: 64, type: "et-qual-tc", targetEvent: 512, slots: 10, cardRequired: true },
                { id: 654, name: "ET12 HOST NATION QUALIFIER", date: "Jul 08", format: "legs", players: 8, type: "et-host-nation", targetEvent: 512, slots: 4, cardRequired: false },
                { id: 655, name: "ET12 EAST EUROPEAN QUALIFIER", date: "Jul 08", format: "legs", players: 16, type: "et-east-european", targetEvent: 512, slots: 1, cardRequired: false },
                { id: 656, name: "ET12 NORDIC & BALTIC QUALIFIER", date: "Jul 08", format: "legs", players: 16, type: "et-nordic-baltic", targetEvent: 512, slots: 1, cardRequired: false },
                { id: 511, name: "HUNGARIAN DARTS TROPHY", date: "Aug 30", format: "legs", players: 48, type: 'minor', cardRequired: true },
                { id: 512, name: "CZECH DARTS OPEN", date: "Sep 04", format: "legs", players: 48, type: 'minor', cardRequired: true },
                { id: 613, name: "ET13 TOUR CARD QUALIFIER", date: "Jul 30", format: "legs", players: 64, type: "et-qual-tc", targetEvent: 513, slots: 10, cardRequired: true },
                { id: 657, name: "ET13 HOST NATION QUALIFIER", date: "Jul 30", format: "legs", players: 8, type: "et-host-nation", targetEvent: 513, slots: 4, cardRequired: false },
                { id: 658, name: "ET13 EAST EUROPEAN QUALIFIER", date: "Jul 30", format: "legs", players: 16, type: "et-east-european", targetEvent: 513, slots: 1, cardRequired: false },
                { id: 659, name: "ET13 NORDIC & BALTIC QUALIFIER", date: "Jul 30", format: "legs", players: 16, type: "et-nordic-baltic", targetEvent: 513, slots: 1, cardRequired: false },
                { id: 614, name: "ET14 TOUR CARD QUALIFIER", date: "Jul 30", format: "legs", players: 64, type: "et-qual-tc", targetEvent: 514, slots: 10, cardRequired: true },
                { id: 660, name: "ET14 HOST NATION QUALIFIER", date: "Jul 30", format: "legs", players: 8, type: "et-host-nation", targetEvent: 514, slots: 4, cardRequired: false },
                { id: 661, name: "ET14 EAST EUROPEAN QUALIFIER", date: "Jul 30", format: "legs", players: 16, type: "et-east-european", targetEvent: 514, slots: 1, cardRequired: false },
                { id: 662, name: "ET14 NORDIC & BALTIC QUALIFIER", date: "Jul 30", format: "legs", players: 16, type: "et-nordic-baltic", targetEvent: 514, slots: 1, cardRequired: false },
                { id: 513, name: "FLANDERS DARTS TROPHY", date: "Sep 13", format: "legs", players: 48, type: 'minor', cardRequired: true },
                { id: 701, name: "WORLD SERIES OF DARTS FINALS TOUR QUALIFIER", date: "Aug 24", format: "legs", players: 64, type: "ws-qual-tc", targetEvent: 25, slots: 8, cardRequired: true },
                { id: 25, name: "WORLD SERIES OF DARTS FINALS", date: "Sep 17", format: "legs", players: 32, type: 'masters-final', cardRequired: true },
                { id: 129, name: "PLAYERS CHAMPIONSHIP 29", date: "Sep 22", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 130, name: "PLAYERS CHAMPIONSHIP 30", date: "Sep 23", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 615, name: "ET15 TOUR CARD QUALIFIER", date: "Sep 24", format: "legs", players: 64, type: "et-qual-tc", targetEvent: 515, slots: 10, cardRequired: true },
                { id: 663, name: "ET15 HOST NATION QUALIFIER", date: "Sep 24", format: "legs", players: 8, type: "et-host-nation", targetEvent: 515, slots: 4, cardRequired: false },
                { id: 664, name: "ET15 EAST EUROPEAN QUALIFIER", date: "Sep 24", format: "legs", players: 16, type: "et-east-european", targetEvent: 515, slots: 1, cardRequired: false },
                { id: 665, name: "ET15 NORDIC & BALTIC QUALIFIER", date: "Sep 24", format: "legs", players: 16, type: "et-nordic-baltic", targetEvent: 515, slots: 1, cardRequired: false },
                { id: 221, name: "CHALLENGE TOUR 21", date: "Sep 26", format: "legs", players: 128, type: "challenge", cardRequired: false },
                { id: 222, name: "CHALLENGE TOUR 22", date: "Sep 26", format: "legs", players: 128, type: "challenge", cardRequired: false },
                { id: 223, name: "CHALLENGE TOUR 23", date: "Sep 27", format: "legs", players: 128, type: "challenge", cardRequired: false },
                { id: 224, name: "CHALLENGE TOUR 24", date: "Sep 27", format: "legs", players: 128, type: "challenge", cardRequired: false },
                { id: 26, name: "WORLD GRAND PRIX", date: "Oct 06", format: "sets", players: 32, type: 'grandprix', cardRequired: true },
                { id: 514, name: "SWISS DARTS TROPHY", date: "Oct 11", format: "legs", players: 48, type: 'minor', cardRequired: true },
                { id: 515, name: "DUTCH DARTS CHAMPIONSHIP", date: "Oct 18", format: "legs", players: 48, type: 'minor', cardRequired: true },
                { id: 29, name: "MACHINESEEKER EUROPEAN CHAMPIONSHIP", date: "Oct 22", format: "legs", players: 32, type: 'europeanf', cardRequired: true },
                { id: 131, name: "PLAYERS CHAMPIONSHIP 31", date: "Oct 28", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 132, name: "PLAYERS CHAMPIONSHIP 32", date: "Oct 29", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 702, name: "GRAND SLAM OF DARTS TOUR QUALIFIER", date: "Oct 20", format: "legs", players: 64, type: "gs-qual-tc", targetEvent: 88, slots: 8, cardRequired: true },
                { id: 88, name: "GRAND SLAM OF DARTS", date: "Nov 01", format: "legs", players: 32, type: "grandslam", cardRequired: true },
                { id: 133, name: "PLAYERS CHAMPIONSHIP 33", date: "Nov 04", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 135, name: "PLAYERS CHAMPIONSHIP 34", date: "Nov 05", format: "legs", players: 128, type: "players", cardRequired: true },
                { id: 30, name: "PLAYERS CHAMPIONSHIP FINALS", date: "Nov 24", format: "legs", players: 64, type: 'playersf', cardRequired: true },
                // International WC Qualifiers - auto-simulate to generate WC spots
                // Europe & Africa√©
                { id: 801, name: "HUNGARIAN SUPER LEAGUE", date: "Nov 10", format: "legs", players: 32, type: "wc-qual-intl", targetEvent: 31, slots: 1, cardRequired: false },
                { id: 802, name: "PDCE NETHERLANDS & BELGIUM QUALIFIER", date: "Nov 15", format: "legs", players: 16, type: "wc-qual-intl", targetEvent: 31, slots: 1, cardRequired: false },
                { id: 803, name: "PDCE MEDITERRANEAN QUALIFIER", date: "Nov 16", format: "legs", players: 16, type: "wc-qual-intl", targetEvent: 31, slots: 1, cardRequired: false },
                { id: 804, name: "PDCE SOUTH-EAST EUROPE QUALIFIER", date: "Nov 15", format: "legs", players: 16, type: "wc-qual-intl", targetEvent: 31, slots: 1, cardRequired: false },
                { id: 805, name: "PDCE CZECHIA QUALIFIER", date: "Nov 16", format: "legs", players: 16, type: "wc-qual-intl", targetEvent: 31, slots: 1, cardRequired: false },
                { id: 806, name: "PDO POLISH QUALIFIER", date: "Nov 14", format: "legs", players: 16, type: "wc-qual-intl", targetEvent: 31, slots: 1, cardRequired: false },
                { id: 807, name: "PDCE DACH SUPER LEAGUE", date: "Nov 04", format: "legs", players: 16, type: "wc-qual-intl", targetEvent: 31, slots: 1, cardRequired: false },
                { id: 808, name: "PDC UK&IRE TOUR CARD QUALIFIER", date: "Nov 01", format: "legs", players: 16, type: "wc-qual-intl", targetEvent: 31, slots: 1, cardRequired: false },
                { id: 820, name: "AFRICAN DARTS GROUP QUALIFIER", date: "Sep 28", format: "legs", players: 8, type: "wc-qual-intl", targetEvent: 31, slots: 1, cardRequired: false },
                // Nordic & Baltic
                { id: 821, name: "PDC NORDIC & BALTIC CHAMPIONSHIP", date: "Oct 03", format: "legs", players: 16, type: "wc-qual-intl", targetEvent: 31, slots: 1, cardRequired: false },
                { id: 822, name: "PDCNB PRO TOUR WINNER", date: "Aug 03", format: "legs", players: 8, type: "wc-qual-intl", targetEvent: 31, slots: 1, cardRequired: false },
                { id: 823, name: "PDCNB PRO TOUR 3RD", date: "Aug 03", format: "legs", players: 8, type: "wc-qual-intl", targetEvent: 31, slots: 1, cardRequired: false },
                // North America
                { id: 809, name: "PDC NORTH AMERICAN CHAMPIONSHIP", date: "Jun 28", format: "legs", players: 16, type: "wc-qual-intl", targetEvent: 31, slots: 1, cardRequired: false },
                { id: 810, name: "CDC CONTINENTAL CUP", date: "Oct 17", format: "legs", players: 16, type: "wc-qual-intl", targetEvent: 31, slots: 1, cardRequired: false },
                { id: 811, name: "CDC CROSS-BORDER CHALLENGE", date: "Apr 11", format: "legs", players: 16, type: "wc-qual-intl", targetEvent: 31, slots: 1, cardRequired: false },
                { id: 812, name: "CDC PRO TOUR - TOP AMERICAN", date: "Sep 21", format: "legs", players: 8, type: "wc-qual-intl", targetEvent: 31, slots: 1, cardRequired: false },
                { id: 813, name: "CDC PRO TOUR - TOP CANADIAN", date: "Sep 21", format: "legs", players: 8, type: "wc-qual-intl", targetEvent: 31, slots: 1, cardRequired: false },
                { id: 814, name: "CDC PRO TOUR - TOP NON-QUALIFIED", date: "Sep 21", format: "legs", players: 8, type: "wc-qual-intl", targetEvent: 31, slots: 1, cardRequired: false },
                { id: 815, name: "CDLC TOUR", date: "Oct 05", format: "legs", players: 8, type: "wc-qual-intl", targetEvent: 31, slots: 1, cardRequired: false },
                // Asia-Pacific
                { id: 816, name: "PDC ASIAN CHAMPIONSHIP", date: "Sep 13", format: "legs", players: 16, type: "wc-qual-intl", targetEvent: 31, slots: 1, cardRequired: false },
                { id: 817, name: "PDC ASIAN TOUR - RUNNER-UP", date: "Sep 12", format: "legs", players: 8, type: "wc-qual-intl", targetEvent: 31, slots: 1, cardRequired: false },
                { id: 818, name: "PDC ASIAN TOUR - 4TH/5TH/6TH/7TH", date: "Sep 12", format: "legs", players: 8, type: "wc-qual-intl", targetEvent: 31, slots: 1, cardRequired: false },
                { id: 824, name: "PDJ JAPAN TOUR", date: "Nov 16", format: "legs", players: 8, type: "wc-qual-intl", targetEvent: 31, slots: 1, cardRequired: false },
                { id: 825, name: "PDC CHINA CHAMPIONSHIP", date: "Aug 24", format: "legs", players: 8, type: "wc-qual-intl", targetEvent: 31, slots: 1, cardRequired: false },
                { id: 826, name: "IDC INDIA QUALIFIER", date: "Oct 05", format: "legs", players: 8, type: "wc-qual-intl", targetEvent: 31, slots: 1, cardRequired: false },
                { id: 827, name: "ANZ PREMIER LEAGUE", date: "Nov 22", format: "legs", players: 8, type: "wc-qual-intl", targetEvent: 31, slots: 1, cardRequired: false },
                { id: 828, name: "ADA TOUR", date: "Sep 07", format: "legs", players: 8, type: "wc-qual-intl", targetEvent: 31, slots: 1, cardRequired: false },
                { id: 829, name: "DPA PRO TOUR", date: "Aug 31", format: "legs", players: 8, type: "wc-qual-intl", targetEvent: 31, slots: 1, cardRequired: false },
                { id: 830, name: "DPNZ PRO TOUR", date: "Sep 28", format: "legs", players: 8, type: "wc-qual-intl", targetEvent: 31, slots: 1, cardRequired: false },
                { id: 835, name: "PDC CHALLENGE TOUR - PLACES", date: "Oct 26", format: "legs", players: 16, type: "wc-qual-intl", targetEvent: 31, slots: 1, cardRequired: false },
                // Tour Card Holder Qualifier - 5 places for WC
                { id: 836, name: "PDC TOUR CARD HOLDER QUALIFIER", date: "Nov 24", format: "legs", players: 32, type: "wc-qual-tc", targetEvent: 31, slots: 5, cardRequired: true },
                { id: 31, name: "WORLD CHAMPIONSHIP", date: "Dec 12", format: "sets", players: 128, type: 'world', cardRequired: true }

            ],

            // Active events array - will be loaded from DB or use defaults
            events: [],

            state: {
                activeEventIndex: 0,
                year: 2026,
                inProgress: false,
                orderOfMerit: {},
                proTourOOM: {},
                challengeTourOOM: {},
                proTourHistory: [],
                challengeTourHistory: [],
                activeOOMView: "main",
                completedEvents: [],
                worldSeriesOOM: {},
                worldSeriesHistory: [],
                premierLeague: {
                    year: 2026,
                    players: ["Luke Littler", "Luke Humphries", "Gian van Veen", "Michael van Gerwen", "Jonny Clayton", "Stephen Bunting", "Josh Rock", "Gerwyn Price"],
                    standings: {},
                    matchResults: [],
                    currentNight: 0,
                    playoffQualifiers: []
                },
                career: {
                    currentDate: null,
                    playerName: "",
                    playerType: "",
                    playerMeta: {},
                    trainingStreak: 0,
                    missedCompetitiveDays: 0,
                    lastActionDate: "",
                    lastAction: "",
                    dayChoices: {},
                    customPlayers: [],
                    activeEventId: null,
                    activeEventParticipating: false,
                    intelTab: "news",
                    standingsTab: "oom",
                    qschoolTab: "uk"
                },
                qSchool: {
                    ukOOM: {},  // Order of Merit for UK Q-School (accumulated points from matches)
                    euOOM: {},  // Order of Merit for EU Q-School (accumulated points from matches)
                    ukFinalStageWinners: [],  // Daily finalists from UK Q-School Final Stage
                    euFinalStageWinners: [],  // Daily finalists from EU Q-School Final Stage
                    ukFinalStageQualified: [],  // Players qualified for UK Final Stage (top 16 from First Stage)
                    euFinalStageQualified: [],  // Players qualified for EU Final Stage (top 16 from First Stage)
                    ukParticipants: [],  // Players who have participated in UK Q-School (any day)
                    euParticipants: [],  // Players who have participated in EU Q-School (any day)
                    ukTourCards: 0,  // Tour cards awarded in UK Q-School (max 13)
                    euTourCards: 0,   // Tour cards awarded in EU Q-School (max 16)
                    ukTourCardWinners: [], // Names who earned tour cards via UK Q-School
                    euTourCardWinners: []  // Names who earned tour cards via EU Q-School
                },

                wcQualified: {
                    qualifiers: new Set(),
                    internationalQualifiers: []
                },
                ukOpenQualifiers: [],

                etQualifiers: {},
                wsQualifiers: {},
                gsQualifiers: {},
                wmQualifiers: {},
                winmauQualifiers: []
            },

            simulateRemainingSeason: async () => {
                if (!confirm("‚ö†Ô∏è SIMULATE ENTIRE SEASON?\n\nThis will auto-play all remaining tournaments using the simulation engine.\n\nThis cannot be undone.")) return;
                await Season.simulateToEvent(Season.events.length);
            },

            simulateToEvent: async (targetIdx) => {
                const isFullSeason = targetIdx === Season.events.length;
                const targetEvent = isFullSeason ? null : Season.events[targetIdx];
                const confirmMsg = isFullSeason
                    ? "‚ö†Ô∏è SIMULATE ENTIRE SEASON?\n\nThis will auto-play all remaining tournaments using the simulation engine."
                    : `‚ö†Ô∏è SIMULATE UP TO ${targetEvent.name}?\n\nThis will auto-play all tournaments before this event.`;

                if (!isFullSeason && !confirm(confirmMsg)) return;

                const overlay = document.createElement('div');
                overlay.id = 'season-sim-overlay';
                overlay.style.cssText = "position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.95); z-index:99999; display:flex; flex-direction:column; justify-content:center; align-items:center; color:white; font-family:Arial, sans-serif;";
                overlay.innerHTML = `
                    <div style="text-align:center; max-width:600px;">
                        <div style="font-size:32px; font-weight:bold; margin-bottom:20px; color:var(--pdc-gold);">‚ö° SIMULATING SEASON...</div>
                        <div id="sim-progress" style="font-size:18px; color:#fff; margin-bottom:10px; min-height:40px; line-height:1.5;">Initializing...</div>
                        <div id="sim-speed" style="font-size:14px; color:#aaa; margin-bottom:30px;"></div>
                        <button id="sim-stop-btn" style="padding:12px 30px; font-size:16px; font-weight:bold; background:#e74c3c; color:white; border:none; border-radius:6px; cursor:pointer; transition:all 0.3s;">STOP SIMULATION</button>
                    </div>
                `;
                document.body.appendChild(overlay);

                const progressDiv = document.getElementById('sim-progress');
                const speedDiv = document.getElementById('sim-speed');
                const stopBtn = document.getElementById('sim-stop-btn');
                let shouldStop = false;

                stopBtn.addEventListener('click', () => {
                    shouldStop = true;
                    stopBtn.disabled = true;
                    stopBtn.style.opacity = '0.5';
                    progressDiv.innerText = 'Stopping simulation...';
                });

                const sleep = (ms) => new Promise(r => setTimeout(r, ms));

                Season.isBulkSim = true;
                Season.silentSimulation = true;

                try {
                    const startTime = performance.now();
                    let eventsSimulated = 0;
                    const initialIdx = Season.state.activeEventIndex;
                    const totalToSimulate = targetIdx - initialIdx;
                    const BATCH_SIZE = 10;

                    while (Season.state.activeEventIndex < targetIdx && !shouldStop) {
                        const batchStart = Season.state.activeEventIndex;
                        const batchEnd = Math.min(batchStart + BATCH_SIZE, targetIdx);

                        for (let i = batchStart; i < batchEnd && !shouldStop; i++) {
                            Season.startEvent(i, true);
                            eventsSimulated++;
                        }

                        const ev = Season.events[Math.min(Season.state.activeEventIndex, Season.events.length - 1)];
                        const elapsed = (performance.now() - startTime) / 1000;
                        const eventsPerSec = (eventsSimulated / elapsed).toFixed(1);
                        const remaining = totalToSimulate - eventsSimulated;
                        const eta = remaining > 0 ? Math.ceil(remaining / (eventsSimulated / elapsed)) : 0;

                        progressDiv.innerText = `Simulating: ${ev.name} (${Season.state.activeEventIndex}/${targetIdx})`;
                        speedDiv.innerText = `Speed: ${eventsPerSec} events/sec | ETA: ${eta}s`;

                        await sleep(0);
                    }

                    if (shouldStop) {
                        progressDiv.innerText = "SIMULATION STOPPED";
                    } else {
                        progressDiv.innerText = isFullSeason ? "SEASON COMPLETE!" : "SIMULATION COMPLETE!";
                        const totalTime = ((performance.now() - startTime) / 1000).toFixed(1);
                        speedDiv.innerText = `Completed ${eventsSimulated} events in ${totalTime}s`;
                    }

                    if (!shouldStop) {
                        progressDiv.innerText = "Finalizing rankings...";
                        Season.recalculateProTourOOM();
                        Season.recalculateChallengeTourOOM();
                    }

                    Persistence.save();
                    await sleep(1500);
                    document.body.removeChild(overlay);
                    Season.renderUI();

                    if (!shouldStop) {
                        alert(isFullSeason ? "Season Simulation Finished!" : `Simulation up to ${targetEvent.name} Finished!`);
                    }

                } catch (e) {
                    console.error(e);
                    if (document.body.contains(overlay)) document.body.removeChild(overlay);
                    alert("Simulation interrupted due to error.");
                } finally {
                    Season.isBulkSim = false;
                    Season.silentSimulation = false;
                }
            },

            ensureCareerState: () => {
                if (!Season.state.career) {
                    Season.state.career = {
                        currentDate: null,
                        playerName: "",
                        playerType: "",
                        playerMeta: {},
                        trainingStreak: 0,
                        missedCompetitiveDays: 0,
                        lastActionDate: "",
                        lastAction: "",
                        dayChoices: {},
                        customPlayers: [],
                        activeEventId: null,
                        activeEventParticipating: false,
                        autoSimDay: null,
                        autoSimExcludeId: null,
                        balance: 0,
                        playerHome: { city: 'London', country: 'England', region: 'uk' },
                        currentRegion: 'uk',
                        lastWorkDate: null,
                        lastTrainDate: null
                    };
                }
                if (typeof Season.state.career.balance === 'undefined') {
                    Season.state.career.balance = 0;
                }
                if (!Season.state.career.playerHome) {
                    Season.state.career.playerHome = { city: 'London', country: 'England', region: 'uk' };
                }
                if (!Season.state.career.currentRegion) {
                    Season.state.career.currentRegion = Season.state.career.playerHome?.region || 'uk';
                }
                if (typeof Season.state.career.lastWorkDate === 'undefined') {
                    Season.state.career.lastWorkDate = null;
                }
                if (typeof Season.state.career.lastTrainDate === 'undefined') {
                    Season.state.career.lastTrainDate = null;
                }
                const career = Season.state.career;
                if (!career.playerMeta) career.playerMeta = {};
                if (!career.dayChoices) career.dayChoices = {};
                if (!career.autoSimDay) career.autoSimDay = null;
                if (!career.autoSimExcludeId) career.autoSimExcludeId = null;
                if (!Array.isArray(career.customPlayers)) career.customPlayers = [];
                if (!career.intelTab) career.intelTab = "news";
                if (!career.standingsTab) career.standingsTab = "oom";
                if (!career.qschoolTab) career.qschoolTab = "uk";
                if (!career.oomTab) career.oomTab = "main";
                if (!career.rankingsTab) career.rankingsTab = "main";
                if (!career.rankingsQSchool) career.rankingsQSchool = "uk";
                if (career.customPlayers.length === 0) {
                    try {
                        const stored = JSON.parse(localStorage.getItem('pdc_custom_players') || '[]');
                        if (Array.isArray(stored) && stored.length > 0) {
                            career.customPlayers = stored;
                        }
                    } catch (e) {
                        console.warn('Failed to load stored custom players:', e);
                    }
                }
                if (!career.currentDate) {
                    const year = Season.state.year || 2026;
                    career.currentDate = Season.toISODate(new Date(year, 0, 1));
                }

                // Initialize global season state if needed
                if (!Season.state.orderOfMerit) Season.state.orderOfMerit = {};
                if (!Season.state.completedEvents) Season.state.completedEvents = [];
                if (!Season.state.premierLeague) Season.state.premierLeague = { players: [] };
            },

            toISODate: (dateObj) => {
                const y = dateObj.getFullYear();
                const m = String(dateObj.getMonth() + 1).padStart(2, '0');
                const d = String(dateObj.getDate()).padStart(2, '0');
                return `${y}-${m}-${d}`;
            },

            fromISODate: (iso) => {
                if (!iso) return null;
                const [y, m, d] = iso.split('-').map(Number);
                return new Date(y, (m || 1) - 1, d || 1);
            },

            formatCareerDate: (dateObj) => {
                if (!dateObj) return '';
                return dateObj.toLocaleDateString('en-US', { month: 'short', day: '2-digit', year: 'numeric' });
            },

            getCareerDateObj: () => {
                Season.ensureCareerState();
                return Season.fromISODate(Season.state.career.currentDate);
            },

            getEventsForDate: (dateObj) => {
                if (!dateObj) return [];
                const year = Season.state.year || dateObj.getFullYear();
                return Season.events.filter(ev => {
                    const evDate = new Date(`${ev.date}, ${year}`);
                    return evDate.getMonth() === dateObj.getMonth() && evDate.getDate() === dateObj.getDate();
                });
            },

            getEventIndicesForDate: (dateObj) => {
                if (!dateObj) return [];
                const year = Season.state.year || dateObj.getFullYear();
                const indices = [];
                Season.events.forEach((ev, idx) => {
                    const evDate = new Date(`${ev.date}, ${year}`);
                    if (evDate.getMonth() === dateObj.getMonth() && evDate.getDate() === dateObj.getDate()) {
                        indices.push(idx);
                    }
                });
                return indices;
            },

            getCareerPlayer: () => {
                Season.ensureCareerState();
                const name = Season.state.career.playerName;
                if (!name) return null;
                return PLAYERS_DB.find(p => p.name === name) || null;
            },

            openCareerPlayerModal: () => {
                Season.ensureCareerState();
                if (Season.state.career.playerName) {
                    alert('Career player is locked. Reset Career to change.');
                    return;
                }
                Season.populateCareerCountrySelect();
                Season.populateCareerRegionSelect();
                Season.renderCareerPlayerList();
                Season.switchCareerPlayerTab('existing');
                const modal = document.getElementById('career-player-modal');
                if (modal) {
                    modal.style.display = 'flex';
                    setTimeout(() => modal.classList.add('active'), 10);
                    modal.onclick = (e) => {
                        if (e.target === modal) Season.closeCareerPlayerModal();
                    };
                }
            },

            closeCareerPlayerModal: () => {
                const modal = document.getElementById('career-player-modal');
                if (!modal) return;
                modal.classList.remove('active');
                setTimeout(() => { modal.style.display = 'none'; }, 300);
            },

            switchCareerPlayerTab: (tab) => {
                const existingBtn = document.getElementById('career-tab-existing');
                const customBtn = document.getElementById('career-tab-custom');
                const existing = document.getElementById('career-player-existing');
                const custom = document.getElementById('career-player-custom');
                if (!existing || !custom || !existingBtn || !customBtn) return;

                if (tab === 'custom') {
                    existing.style.display = 'none';
                    custom.style.display = 'flex';
                    existingBtn.classList.remove('selected');
                    customBtn.classList.add('selected');

                    // Initialize sliders
                    setTimeout(() => {
                        const avgSlider = document.getElementById('career-custom-avg');
                        const coSlider = document.getElementById('career-custom-co');
                        if (avgSlider) {
                            avgSlider.addEventListener('input', () => {
                                const display = document.getElementById('career-custom-avg-display');
                                if (display) display.textContent = parseFloat(avgSlider.value).toFixed(1);
                            });
                        }
                        if (coSlider) {
                            coSlider.addEventListener('input', () => {
                                const display = document.getElementById('career-custom-co-display');
                                if (display) display.textContent = parseFloat(coSlider.value).toFixed(1) + '%';
                            });
                        }
                    }, 0);
                } else {
                    existing.style.display = 'flex';
                    custom.style.display = 'none';
                    customBtn.classList.remove('selected');
                    existingBtn.classList.add('selected');
                }
            },

            populateCareerCountrySelect: (selectId) => {
                const targetId = selectId || 'career-custom-country';
                const select = document.getElementById(targetId);
                if (!select || select.options.length > 0) return;
                const countries = Array.from(new Set(PLAYERS_DB.map(p => p.country))).sort();
                countries.forEach(code => {
                    const opt = document.createElement('option');
                    opt.value = code;
                    opt.textContent = code.toUpperCase();
                    select.appendChild(opt);
                });
            },

            populateCareerRegionSelect: (selectId) => {
                const targetId = selectId || 'career-custom-region';
                const select = document.getElementById(targetId);
                if (!select || select.options.length > 0) return;
                const regions = [
                    { value: 'uk', label: 'UK & Ireland' },
                    { value: 'eu', label: 'Europe' },
                    { value: 'asia', label: 'Asia' },
                    { value: 'america', label: 'Americas' },
                    { value: 'oceania', label: 'Oceania' },
                    { value: 'africa', label: 'Africa' }
                ];
                regions.forEach(region => {
                    const opt = document.createElement('option');
                    opt.value = region.value;
                    opt.textContent = region.label;
                    select.appendChild(opt);
                });
            },

            renderCareerPlayerListTo: (listId) => {
                const targetId = listId || 'career-player-list';
                const list = document.getElementById(targetId);
                if (!list) return;
                list.innerHTML = '';
                PLAYERS_DB.forEach(p => {
                    const item = document.createElement('div');
                    item.className = 'career-player-item';
                    const tc = p.tourCard ? '<span style="color:var(--pdc-gold); font-weight:bold;">TC</span>' : '<span style="color:#666;">-</span>';
                    item.innerHTML = `
                        <img src="${getFlagUrl(p.country)}" style="width:20px; height:14px; border-radius:2px;">
                        <span style="flex:1; font-size:12px; color:#ddd;">${p.name}</span>
                        <span style="font-size:10px;">${tc}</span>
                    `;
                    item.onclick = () => Season.selectCareerPlayer(p.name, 'pro');
                    list.appendChild(item);
                });
            },

            renderCareerPlayerList: () => {
                Season.renderCareerPlayerListTo('career-player-list');
            },

            filterCareerPlayerListTo: (listId, inputId) => {
                const list = document.getElementById(listId);
                const input = document.getElementById(inputId);
                if (!input || !list) return;
                const term = input.value.toLowerCase();
                Array.from(list.children).forEach(item => {
                    const name = item.innerText.toLowerCase();
                    item.style.display = name.includes(term) ? 'flex' : 'none';
                });
            },

            filterCareerPlayerList: () => {
                Season.filterCareerPlayerListTo('career-player-list', 'career-player-search');
            },

            switchCareerStartTab: (tab) => {
                const customBtn = document.getElementById('career-start-tab-custom');
                const existingBtn = document.getElementById('career-start-tab-existing');
                const custom = document.getElementById('career-start-custom');
                const existing = document.getElementById('career-start-existing');
                if (!customBtn || !existingBtn || !custom || !existing) return;

                const isCustom = tab === 'custom';
                customBtn.classList.toggle('active', isCustom);
                existingBtn.classList.toggle('active', !isCustom);
                custom.style.display = isCustom ? 'flex' : 'none';
                existing.style.display = isCustom ? 'none' : 'flex';
            },

            updateCareerStartRanges: () => {
                const avgInput = document.getElementById('career-start-avg');
                const coInput = document.getElementById('career-start-co');
                const avgVal = document.getElementById('career-start-avg-val');
                const coVal = document.getElementById('career-start-co-val');
                if (avgInput && avgVal) avgVal.innerText = parseFloat(avgInput.value).toFixed(1);
                if (coInput && coVal) coVal.innerText = `${parseFloat(coInput.value).toFixed(1)}%`;
            },

            createCareerPlayerFromHub: () => {
                Season.ensureCareerState();
                const name = document.getElementById('career-start-name')?.value?.trim();
                const country = document.getElementById('career-start-country')?.value || 'eng';
                const age = parseInt(document.getElementById('career-start-age')?.value || '24', 10);
                const avg = parseFloat(document.getElementById('career-start-avg')?.value || '');
                const co = parseFloat(document.getElementById('career-start-co')?.value || '');
                const hasTourCard = !!document.getElementById('career-start-tourcard')?.checked;

                if (!name) {
                    alert('Please enter a player name.');
                    return;
                }
                if (PLAYERS_DB.find(p => p.name.toLowerCase() === name.toLowerCase())) {
                    alert('That player name already exists.');
                    return;
                }
                if ([avg, co].some(v => Number.isNaN(v))) {
                    alert('Please enter starting stats for your player.');
                    return;
                }

                // Get home location from UI (will add UI in next step)
                const homeCity = document.getElementById('career-start-city')?.value?.trim() || 'London';
                const homeCountry = document.getElementById('career-start-home-country')?.value?.trim() || 'England';
                const homeRegion = document.getElementById('career-start-region')?.value || 'uk';

                const player = {
                    name: name,
                    country: country,
                    age: age,
                    appearance: '',
                    avg: Math.max(20, Math.min(100, avg)),
                    co: Math.max(10, Math.min(60, co)),
                    fav: 20,
                    money: 10000,  // Starting money for travel/entry fees
                    tourCard: hasTourCard,
                    form: 50,
                    confidence: 50,
                    fatigue: 0,  // Start fresh
                    consistency: 50,
                    isCustom: true,
                    home: { city: homeCity, country: homeCountry, region: homeRegion },
                    currentRegion: homeRegion
                };

                // Set career home location
                Season.state.career.playerHome = player.home;
                Season.state.career.currentRegion = player.currentRegion;

                PLAYERS_DB.push(player);
                Season.state.career.customPlayers.push(player);
                localStorage.setItem('pdc_custom_players', JSON.stringify(Season.state.career.customPlayers));
                if (hasTourCard) {
                    if (!Season.state.orderOfMerit[player.name]) Season.state.orderOfMerit[player.name] = player.money || 0;
                }

                App.renderDropdown('p1');
                App.renderDropdown('p2');
                const container = document.getElementById('player-list-container');
                if (container) container.innerHTML = '';
                if (Tournament.updatePlayerSelectUI) Tournament.updatePlayerSelectUI();

                Season.selectCareerPlayer(player.name, 'custom');
            },

            switchCareerOomTab: (tab, limit) => {
                Season.ensureCareerState();
                const career = Season.state.career;
                career.oomTab = tab;

                const tabs = {
                    main: 'career-oom-main-btn',
                    pro: 'career-oom-pro-btn',
                    challenge: 'career-oom-challenge-btn',
                    ws: 'career-oom-ws-btn'
                };
                Object.entries(tabs).forEach(([key, id]) => {
                    const el = document.getElementById(id);
                    if (el) el.classList.toggle('active', key === tab);
                });

                const views = {
                    main: 'career-oom-main',
                    pro: 'career-oom-pro',
                    challenge: 'career-oom-challenge',
                    ws: 'career-oom-ws'
                };
                Object.entries(views).forEach(([key, id]) => {
                    const el = document.getElementById(id);
                    if (el) el.style.display = key === tab ? 'block' : 'none';
                });

                if (tab === 'main') Season.renderOOMTable('career-oom-table-main', Season.state.orderOfMerit, limit);
                if (tab === 'pro') Season.renderOOMTable('career-oom-table-pro', Season.state.proTourOOM, limit);
                if (tab === 'challenge') Season.renderOOMTable('career-oom-table-challenge', Season.state.challengeTourOOM, limit);
                if (tab === 'ws') Season.renderOOMTable('career-oom-table-ws', Season.state.worldSeriesOOM, limit);
            },

            switchCareerView: (view) => {
                Season.ensureCareerState();
                Season.state.career.activeView = view;
                const btns = {
                    dashboard: 'career-nav-dashboard',
                    calendar: 'career-nav-calendar',
                    rankings: 'career-nav-rankings',
                    training: 'career-nav-training',
                    news: 'career-nav-news',
                    form: 'career-nav-form'
                };
                Object.entries(btns).forEach(([key, id]) => {
                    const el = document.getElementById(id);
                    if (el) el.classList.toggle('active', key === view);
                });

                if (view === 'calendar') {
                    Season.openCareerCalendarOverlay();
                    return;
                }
                if (view === 'rankings') {
                    Season.openCareerRankingsOverlay();
                    return;
                }
                if (view === 'news') {
                    Season.openCareerNewsOverlay();
                    return;
                }
                if (view === 'form') {
                    Season.openCareerFormOverlay();
                    return;
                }

                const targets = {
                    dashboard: 'career-section-recent',
                    calendar: 'career-section-calendar',
                    rankings: 'career-section-rankings',
                    training: 'career-section-training'
                };
                const target = document.getElementById(targets[view] || targets.dashboard);
                if (target) target.scrollIntoView({ behavior: 'smooth', block: 'start' });
            },

            openCareerCalendarOverlay: () => {
                const overlay = document.getElementById('career-calendar-overlay');
                const list = document.getElementById('career-calendar-overlay-list');
                if (!overlay || !list) return;

                list.innerHTML = '';
                const completedMap = new Map(Season.state.completedEvents.map(c => [c.id, c]));

                Season.events.forEach((ev, idx) => {
                    const completed = completedMap.get(ev.id);
                    const statusClass = completed ? 'completed' : '';
                    const winnerText = completed ? `<div class="s-winner">üèÜ ${completed.winner}</div>` : '';
                    list.innerHTML += `
                        <div class="season-event ${statusClass}" onclick="Season.showEventInfo(${idx})" style="cursor:pointer;">
                            <div>
                                <div class="s-date">${ev.date}</div>
                                <div class="s-name">${ev.name}</div>
                                ${winnerText}
                            </div>
                        </div>
                    `;
                });

                overlay.classList.add('active');
            },

            openCareerRankingsOverlay: () => {
                const overlay = document.getElementById('career-rankings-overlay');
                if (!overlay) return;
                Season.switchCareerRankingsTab(Season.state.career.rankingsTab || 'main');
                overlay.classList.add('active');
            },

            openCareerNewsOverlay: () => {
                const overlay = document.getElementById('career-news-overlay');
                if (!overlay) return;

                // Render news feed
                const newsFeed = document.getElementById('career-news-feed');
                if (newsFeed && typeof NewsSystem !== 'undefined') {
                    let newsHtml = '';
                    const allNews = NewsSystem.news || [];

                    if (allNews.length === 0) {
                        newsHtml = '<div style="text-align:center; padding:40px; color:#666; font-size:13px;">No news yet...</div>';
                    } else {
                        allNews.slice(0, 50).forEach(news => {
                            const borderColor = news.importance === 'high' ? 'var(--pdc-gold)' :
                                news.importance === 'medium' ? '#3498db' : '#666';
                            newsHtml += `
                                <div class="career-news-item" style="background: linear-gradient(145deg, #1f2430, #141822); 
                                     padding: 12px; border-radius: 6px; border-left: 3px solid ${borderColor}; 
                                     box-shadow: 0 2px 5px rgba(0,0,0,0.3); margin-bottom: 10px;">
                                    <div style="font-size: 10px; color: #888; margin-bottom: 4px;">${news.date || 'Recent'}</div>
                                    <div style="font-size: 13px; font-weight: bold; color: #fff; margin-bottom: 4px;">${news.headline || 'News Update'}</div>
                                    <div style="font-size: 11px; color: #aaa;">${news.body || 'No details available.'}</div>
                                </div>
                            `;
                        });
                    }

                    newsFeed.innerHTML = newsHtml;
                }

                overlay.classList.add('active');
            },

            openCareerFormOverlay: () => {
                const overlay = document.getElementById('career-form-overlay');
                const tbody = document.getElementById('career-form-tbody');
                if (!overlay || !tbody) return;

                tbody.innerHTML = '';

                // Get all players sorted by OOM/AVG and show their form and fatigue
                const playerList = [...PLAYERS_DB]
                    .sort((a, b) => {
                        const oomA = Season.state.orderOfMerit[a.name] || 0;
                        const oomB = Season.state.orderOfMerit[b.name] || 0;
                        if (oomA !== oomB) return oomB - oomA;
                        return b.avg - a.avg;
                    })
                    .slice(0, 50); // Show top 50 players

                playerList.forEach((p, idx) => {
                    const form = Math.round(p.form || 50);
                    const fatigue = Math.round(p.fatigue || 0);
                    const formColor = form >= 70 ? '#2ecc71' : form >= 50 ? '#f39c12' : '#e74c3c';
                    const fatigueColor = fatigue >= 70 ? '#e74c3c' : fatigue >= 50 ? '#f39c12' : '#2ecc71';

                    tbody.innerHTML += `
                        <tr style="border-bottom:1px solid rgba(255,255,255,0.1); background: ${idx % 2 === 0 ? 'rgba(255,255,255,0.01)' : 'transparent'};">
                            <td style="padding:6px 8px; color:#888; font-size:12px;">${idx + 1}</td>
                            <td style="padding:6px 8px; color:#fff; font-weight:bold;">${p.name}</td>
                            <td style="padding:6px 8px; text-align:center; color:${formColor}; font-weight:bold;">${form}</td>
                            <td style="padding:6px 8px; text-align:center; color:${fatigueColor}; font-weight:bold;">${fatigue}%</td>
                            <td style="padding:6px 8px; text-align:center; color:#ccc;">${(p.avg || 0).toFixed(1)}</td>
                        </tr>
                    `;
                });

                overlay.classList.add('active');
            },

            closeCareerOverlay: (id) => {
                const overlay = document.getElementById(id);
                if (overlay) overlay.classList.remove('active');
            },



            switchCareerRankingsTab: (tab) => {
                Season.ensureCareerState();
                Season.state.career.rankingsTab = tab;
                const tabs = {
                    main: 'career-rank-main-btn',
                    pro: 'career-rank-pro-btn',
                    challenge: 'career-rank-challenge-btn',
                    ws: 'career-rank-ws-btn',
                    premier: 'career-rank-premier-btn',
                    qschool: 'career-rank-qschool-btn'
                };
                Object.entries(tabs).forEach(([key, id]) => {
                    const el = document.getElementById(id);
                    if (el) el.classList.toggle('active', key === tab);
                });

                const views = {
                    main: 'career-rank-main',
                    pro: 'career-rank-pro',
                    challenge: 'career-rank-challenge',
                    ws: 'career-rank-ws',
                    premier: 'career-rank-premier',
                    qschool: 'career-rank-qschool'
                };
                Object.entries(views).forEach(([key, id]) => {
                    const el = document.getElementById(id);
                    if (el) el.style.display = key === tab ? 'block' : 'none';
                });

                if (tab === 'main') Season.renderOOMTable('career-rank-table-main', Season.state.orderOfMerit);
                if (tab === 'pro') Season.renderOOMTable('career-rank-table-pro', Season.state.proTourOOM);
                if (tab === 'challenge') Season.renderOOMTable('career-rank-table-challenge', Season.state.challengeTourOOM);
                if (tab === 'ws') Season.renderOOMTable('career-rank-table-ws', Season.state.worldSeriesOOM);
                if (tab === 'premier') Season.renderPremierLeagueStandingsTo('career-rank-premier');
                if (tab === 'qschool') Season.switchCareerRankingsQSchool(Season.state.career.rankingsQSchool || 'uk');
            },

            switchCareerRankingsQSchool: (location) => {
                Season.ensureCareerState();
                Season.state.career.rankingsQSchool = location;
                const ukBtn = document.getElementById('career-rank-qschool-uk');
                const euBtn = document.getElementById('career-rank-qschool-eu');
                const ukView = document.getElementById('career-rank-qschool-uk-view');
                const euView = document.getElementById('career-rank-qschool-eu-view');
                if (ukBtn) ukBtn.classList.toggle('active', location === 'uk');
                if (euBtn) euBtn.classList.toggle('active', location === 'eu');
                if (ukView) ukView.style.display = location === 'uk' ? 'block' : 'none';
                if (euView) euView.style.display = location === 'eu' ? 'block' : 'none';

                Season.renderQSchoolStandingsForLocationTo('uk', 'career-rank-qschool-uk-view');
                Season.renderQSchoolStandingsForLocationTo('eu', 'career-rank-qschool-eu-view');
            },

            showCareerEventSummary: (ev) => {
                const career = Season.state.career;
                const player = Season.getCareerPlayer();
                if (!player || !ev) return;

                const overlayId = 'career-event-overlay';
                let overlay = document.getElementById(overlayId);
                if (!overlay) {
                    overlay = document.createElement('div');
                    overlay.id = overlayId;
                    overlay.className = 'career-event-overlay';
                    document.body.appendChild(overlay);
                }

                const completed = Season.state.completedEvents.find(c => c.id === ev.id);
                const participation = completed?.participations?.[player.name];
                const position = participation?.position || null;
                const moneyWon = participation?.money || 0;

                const positionText = position ? `Finished: ${position === 1 ? 'Winner' : `Top ${position}`}` : 'Did not play';
                const moneyText = position ? `Money Won: ¬£${moneyWon.toLocaleString()}` : 'Money Won: ¬£0';

                overlay.innerHTML = `
                    <div class="career-event-card">
                        <div class="career-event-title">${ev.name}</div>
                        <div class="career-event-sub">Event Summary</div>
                        <div class="career-event-stats">
                            <div>${positionText}</div>
                            <div><strong>${moneyText}</strong></div>
                        </div>
                    </div>
                `;

                overlay.classList.add('active');
                setTimeout(() => {
                    overlay.classList.remove('active');
                }, 2200);

                career.pendingEventSummary = null;
            },

            selectCareerPlayer: (name, type) => {
                Season.ensureCareerState();
                const player = PLAYERS_DB.find(p => p.name === name);
                if (!player) return;

                // Get capital & region for existing pros
                const countryInfo = COUNTRY_CAPITALS[player.country.toLowerCase()] ||
                    { capital: 'London', fullName: 'England', region: 'uk' };

                // Set home location based on country capital
                Season.state.career.playerHome = {
                    city: countryInfo.capital,
                    country: countryInfo.fullName,
                    region: countryInfo.region
                };
                Season.state.career.currentRegion = countryInfo.region;

                Season.state.career.playerName = player.name;
                Season.state.career.playerType = type || 'pro';
                Season.state.career.playerMeta = {
                    country: player.country,
                    age: player.age || null,
                    appearance: player.appearance || ''
                };

                // Set starting money for existing pros (10000) and custom pros (from their home properties)
                if (type === 'pro') {
                    // Existing pro from database
                    Season.state.career.balance = 10000;
                } else if (type === 'custom') {
                    // Custom player - preserve their balance or set to 10000 if not set
                    if (!Season.state.career.balance) {
                        Season.state.career.balance = 10000;
                    }
                }

                Persistence.save();
                Season.renderCareerHub();
                Season.closeCareerPlayerModal();
            },

            createCustomCareerPlayer: () => {
                Season.ensureCareerState();
                const name = document.getElementById('career-custom-name')?.value?.trim();
                const country = document.getElementById('career-custom-country')?.value || 'eng';
                const age = parseInt(document.getElementById('career-custom-age')?.value || '25', 10);
                const startMoney = parseInt(document.getElementById('career-custom-money')?.value || '0', 10);
                const city = document.getElementById('career-custom-city')?.value?.trim() || '';
                const homeCountry = document.getElementById('career-custom-home-country')?.value?.trim() || '';
                const region = document.getElementById('career-custom-region')?.value || '';
                const avg = parseFloat(document.getElementById('career-custom-avg')?.value || '60');
                const co = parseFloat(document.getElementById('career-custom-co')?.value || '35');
                const hasTourCard = !!document.getElementById('career-custom-tourcard')?.checked;

                if (!name) {
                    alert('Please enter a player name.');
                    return;
                }
                if (PLAYERS_DB.find(p => p.name.toLowerCase() === name.toLowerCase())) {
                    alert('That player name already exists.');
                    return;
                }

                if ([avg, co].some(v => Number.isNaN(v))) {
                    alert('Please enter starting stats for your player.');
                    return;
                }

                const player = {
                    name: name,
                    country: country,
                    age: age,
                    city: city,
                    homeCountry: homeCountry,
                    region: region,
                    avg: Math.max(60, Math.min(110, avg)),
                    co: Math.max(20, Math.min(60, co)),
                    fav: 20,
                    money: 0,
                    tourCard: hasTourCard,
                    form: 50,
                    confidence: 50,
                    fatigue: 10,
                    consistency: 50,
                    isCustom: true,
                    startMoney: startMoney
                };

                PLAYERS_DB.push(player);
                Season.state.career.customPlayers.push(player);
                localStorage.setItem('pdc_custom_players', JSON.stringify(Season.state.career.customPlayers));
                if (hasTourCard) {
                    if (!Season.state.orderOfMerit[player.name]) Season.state.orderOfMerit[player.name] = player.money || 0;
                }

                // Set the balance based on starting money
                Season.state.career.balance = startMoney;

                // Refresh dropdowns/selectors
                App.renderDropdown('p1');
                App.renderDropdown('p2');
                const container = document.getElementById('player-list-container');
                if (container) container.innerHTML = '';
                if (Tournament.updatePlayerSelectUI) Tournament.updatePlayerSelectUI();

                Season.selectCareerPlayer(player.name, 'custom');
            },

            showCareerStart: () => {
                const mainMenu = document.getElementById('career-main-menu');
                const startHub = document.getElementById('career-start');
                if (mainMenu) mainMenu.style.display = 'none';
                if (startHub) {
                    startHub.style.display = 'flex';
                    Season.populateCareerCountrySelect('career-start-country');
                    Season.renderCareerPlayerListTo('career-start-list');
                    Season.updateCareerStartRanges();
                }
            },

            renderCareerHub: () => {
                Season.ensureCareerState();
                const career = Season.state.career;
                const player = Season.getCareerPlayer();
                const dateObj = Season.getCareerDateObj();

                const setupScreen = document.getElementById('setup-screen');
                if (setupScreen) setupScreen.style.display = 'flex';

                const mainMenu = document.getElementById('career-main-menu');
                const startHub = document.getElementById('career-start');
                const careerShell = document.querySelector('.career-shell');

                if (mainMenu && startHub && careerShell) {
                    const hasPlayer = !!player;

                    if (hasPlayer) {
                        mainMenu.style.display = 'none';
                        startHub.style.display = 'none';
                        careerShell.style.display = 'flex';
                    } else {
                        // If no player, show main menu first (unless we are already in start hub)
                        if (startHub.style.display === 'flex') {
                            mainMenu.style.display = 'none';
                        } else {
                            mainMenu.style.display = 'flex';
                            startHub.style.display = 'none';
                        }
                        careerShell.style.display = 'none';
                        return;
                    }
                }

                if (!career.activeView) {
                    Season.switchCareerView('dashboard');
                }

                // Update Sidebar
                const nameEl = document.getElementById('career-player-name');
                const metaEl = document.getElementById('career-player-meta');
                if (nameEl) nameEl.innerText = player ? player.name : 'No player selected';
                if (metaEl) {
                    if (player) {
                        const tc = player.tourCard ? 'Tour Card' : 'No Tour Card';
                        const wRank = Season.state.orderOfMerit[player.name] ? `#${Object.keys(Season.state.orderOfMerit).sort((a, b) => Season.state.orderOfMerit[b] - Season.state.orderOfMerit[a]).indexOf(player.name) + 1}` : '-';
                        metaEl.innerHTML = `<span style="color:#888;">${player.country.toUpperCase()}</span> ‚Ä¢ <span style="color:var(--pdc-gold);">${wRank}</span> ‚Ä¢ ${tc}`;
                    } else {
                        metaEl.innerText = '';
                    }
                }

                // Stats Section Update
                if (player) {
                    const setBar = (id, val, max) => {
                        const el = document.getElementById(id);
                        if (el) el.style.width = `${Math.min(100, Math.max(0, (val / max) * 100))}%`;
                    };
                    const setText = (id, txt) => {
                        const el = document.getElementById(id);
                        if (el) el.innerText = txt;
                    };

                    // Calculate OOM rank
                    const oomSorted = Object.keys(Season.state.orderOfMerit || {}).sort((a, b) =>
                        (Season.state.orderOfMerit[b] || 0) - (Season.state.orderOfMerit[a] || 0)
                    );
                    const playerRank = oomSorted.indexOf(player.name) + 1;
                    const playerOOMMoney = Season.state.orderOfMerit[player.name] || 0;

                    // Sidebar pills
                    setText('career-stat-rank', playerRank > 0 ? `#${playerRank}` : '--');
                    setText('career-pill-world', `¬£${playerOOMMoney.toLocaleString()}`);
                    setText('career-pill-balance', `¬£${(career.balance || 0).toLocaleString()}`);
                    setText('career-pill-age', player.age || '--');
                    setText('career-pill-avg', (player.avg || 0).toFixed(1));
                    setText('career-pill-form', Math.round(player.form || 50));
                    setText('career-pill-co', (player.co || 0).toFixed(1) + '%');
                    setText('career-pill-rs', '--'); // Ranking score - can add later

                    // Topbar stats (duplicates)
                    setText('career-stat-avg', (player.avg || 0).toFixed(2));
                    setBar('career-bar-avg', (player.avg - 60), 50);

                    setText('career-stat-co', (player.co || 0).toFixed(1) + '%');
                    setBar('career-bar-co', (player.co - 10), 60);

                    setText('career-stat-form', Math.round(player.form || 50));
                    setBar('career-bar-form', player.form, 100);

                    setText('career-stat-fatigue', Math.round(player.fatigue || 0) + '%');
                    setBar('career-bar-fatigue', player.fatigue, 100);

                    // Player Development Section (separate IDs for the second panel)
                    setText('career-stat-avg-2', (player.avg || 0).toFixed(2));
                    setText('career-stat-co-2', (player.co || 0).toFixed(1) + '%');
                    setText('career-stat-fatigue-2', Math.round(player.fatigue || 0) + '%');
                    setText('career-stat-consistency', player.consistency ? player.consistency.toFixed(1) : '--');
                    setBar('career-bar-consistency', player.consistency || 0, 100);

                    // Update top-left date display
                    const dateObj = Season.getCareerDateObj();
                    const currentDateFull = new Intl.DateTimeFormat('en-US', { month: 'long', day: 'numeric', year: 'numeric' }).format(dateObj);
                    setText('career-date-display', currentDateFull);
                }

                // === MANAGER DASHBOARD ===
                const dashboardContainer = document.getElementById('career-section-recent');
                if (dashboardContainer) {
                    const year = Season.state.year || dateObj.getFullYear();
                    const getEventDateObj = (ev) => new Date(`${ev.date}, ${year}`);
                    const isSameDay = (a, b) => a && b && a.getFullYear() === b.getFullYear() && a.getMonth() === b.getMonth() && a.getDate() === b.getDate();

                    // Find next playable/simmable event
                    const allEvents = Season.events;
                    const completedIds = new Set(Season.state.completedEvents.map(c => c.id));

                    // Filter pending events
                    let nextEvent = null;
                    let daysUntil = 0;

                    // Find today's events first
                    const eventsToday = Season.getEventsForDate(dateObj).filter(e => !completedIds.has(e.id));

                    if (eventsToday.length > 0) {
                        nextEvent = eventsToday[0];
                        daysUntil = 0;
                    } else {
                        // Find next future event by date
                        for (const ev of allEvents) {
                            if (completedIds.has(ev.id)) continue;
                            const evDate = getEventDateObj(ev);
                            if (evDate > dateObj && !isSameDay(evDate, dateObj)) {
                                nextEvent = ev;
                                daysUntil = Math.max(1, Math.round((evDate - dateObj) / (1000 * 60 * 60 * 24)));
                                break;
                            }
                        }
                    }

                    // Format current date for top header (e.g., "January 1, 2026")
                    const currentDateFull = new Intl.DateTimeFormat('en-US', { month: 'long', day: 'numeric', year: 'numeric' }).format(dateObj);

                    // Format event date for purple card (e.g., "JAN 06, 2026")
                    const eventDateStr = nextEvent && daysUntil === 0
                        ? Season.formatCareerDate(dateObj).toUpperCase()
                        : (nextEvent ? Season.formatCareerDate(getEventDateObj(nextEvent)).toUpperCase() : Season.formatCareerDate(dateObj).toUpperCase());

                    let contentHTML = '';

                    contentHTML += `
                        <div class="mgr-header">
                            <div class="mgr-date">${eventDateStr}</div>
                            <div class="mgr-status">
                                ${nextEvent ? (daysUntil === 0 ? '<span style="color:#2ecc71">MATCHDAY</span>' : 'NEXT FIXTURE UPCOMING') : 'SEASON COMPLETE'}
                            </div>
                        </div>
                    `;

                    if (nextEvent) {
                        const isToday = eventsToday.some(e => e.id === nextEvent.id);

                        // Enrich player for eligibility check
                        const enrichedPlayer = {
                            ...player,
                            money: career.balance || player.money || 0,
                            currentRegion: career.currentRegion || player.home?.region || 'uk',
                            fatigue: player.fatigue || 0
                        };

                        // Check eligibility with detailed feedback
                        let canEnter = Season.canCareerPlayerEnterEvent(nextEvent);
                        let ineligibleReason = '';

                        if (!canEnter) {
                            ineligibleReason = 'Not eligible for this event';
                        }

                        // Enrich event with venue information if not already done (BEFORE affordability check)
                        if (typeof EventEnrichment !== 'undefined' && EventEnrichment.enrichEvent && !nextEvent.venueId) {
                            EventEnrichment.enrichEvent(nextEvent);
                        }

                        // Also check money, travel costs, and fatigue using EntrySystem
                        if (canEnter && typeof EntrySystem !== 'undefined' && EntrySystem.canEnterEvent) {
                            const entryCheck = EntrySystem.canEnterEvent(nextEvent, enrichedPlayer);
                            canEnter = entryCheck.canEnter;
                            if (!canEnter) {
                                ineligibleReason = entryCheck.reason || 'Not eligible';
                            }
                        }

                        // Calculate costs

                        // Get entry fee from EventEnrichment or fallback to 0
                        let entryFee = 0;
                        if (typeof EventEnrichment !== 'undefined' && EventEnrichment.entryFees) {
                            entryFee = EventEnrichment.entryFees[nextEvent.type] || 0;
                        }

                        // Calculate travel cost
                        let travelCost = 0;
                        if (typeof TravelSystem !== 'undefined' && TravelSystem.calculateTravel) {
                            const eventLocation = TravelSystem.resolveEventLocation(nextEvent);
                            const currentRegion = career.currentRegion || 'uk';
                            const travelData = TravelSystem.calculateTravel(currentRegion, eventLocation.region || 'uk');
                            travelCost = travelData ? travelData.totalCost : 0;
                        }

                        const totalCost = entryFee + travelCost;

                        // Get winner prize from PRIZE_STRUCTURE
                        let winnerPrize = 0;
                        if (typeof PRIZE_STRUCTURE !== 'undefined' && PRIZE_STRUCTURE[nextEvent.type]) {
                            winnerPrize = PRIZE_STRUCTURE[nextEvent.type][1] || 0;
                        }

                        // Get event logo image (same as calendar view)
                        let logoHTML = '';
                        if (nextEvent.name === 'MATCHPLAY') {
                            logoHTML = '<img src="worldmatchplay.png" alt="" style="width:60px; height:60px; border-radius:8px; object-fit:cover;">';
                        } else if (nextEvent.name === 'UK OPEN') {
                            logoHTML = '<img src="ukopen.png" alt="" style="width:60px; height:60px; border-radius:8px; object-fit:cover;">';
                        } else if (nextEvent.name === 'PLAYERS CHAMPIONSHIP FINALS') {
                            logoHTML = '<img src="playersc.png" alt="" style="width:60px; height:60px; border-radius:8px; object-fit:cover;">';
                        } else if (nextEvent.name === 'GRAND SLAM OF DARTS') {
                            logoHTML = '<img src="mrvegas.png" alt="" style="width:60px; height:60px; border-radius:8px; object-fit:cover;">';
                        } else if (nextEvent.name === 'WORLD SERIES OF DARTS FINALS') {
                            logoHTML = '<img src="worldseries.png" alt="" style="width:60px; height:60px; border-radius:8px; object-fit:cover;">';
                        } else if (nextEvent.name === 'WORLD CHAMPIONSHIP') {
                            logoHTML = '<img src="worldchampionship.png" alt="" style="width:60px; height:60px; border-radius:8px; object-fit:cover;">';
                        } else if (nextEvent.name === 'WINMAU WORLD MASTERS') {
                            logoHTML = '<img src="worldmasters.png" alt="" style="width:60px; height:60px; border-radius:8px; object-fit:cover;">';
                        } else if (nextEvent.name.includes('WORLD GRAND PRIX')) {
                            logoHTML = '<img src="grandprix.png" alt="" style="width:60px; height:60px; border-radius:8px; object-fit:cover;">';
                        } else if (nextEvent.name.includes('MACHINESEEKER EUROPEAN CHAMPIONSHIP')) {
                            logoHTML = '<img src="europeanchampionship.png" alt="" style="width:60px; height:60px; border-radius:8px; object-fit:cover;">';
                        } else if (nextEvent.type === 'players') {
                            logoHTML = '<img src="playersc.png" alt="" style="width:60px; height:60px; border-radius:8px; object-fit:cover;">';
                        } else if (nextEvent.type === 'premier-league' || nextEvent.type === 'premier-league-playoff') {
                            logoHTML = '<img src="premierleague.png" alt="" style="width:60px; height:60px; border-radius:8px; object-fit:cover;">';
                        } else if (nextEvent.type === 'masters') {
                            logoHTML = '<img src="worldseries.png" alt="" style="width:60px; height:60px; border-radius:8px; object-fit:cover;">';
                        } else if (nextEvent.type === 'pc' || nextEvent.name.includes('PLAYERS CHAMPIONSHIP')) {
                            logoHTML = '<img src="playersc.png" alt="" style="width:60px; height:60px; border-radius:8px; object-fit:cover;">';
                        } else {
                            logoHTML = '<img src="pdc-logo.png" alt="" style="width:60px; height:60px; border-radius:8px; object-fit:cover;">';
                        }

                        const locationInfo = (typeof TravelSystem !== 'undefined' && TravelSystem.resolveEventLocation)
                            ? TravelSystem.resolveEventLocation(nextEvent)
                            : null;
                        const venueName = locationInfo?.venueName || nextEvent.venue || nextEvent.city || nextEvent.location || 'Unknown Venue';

                        let subText = "";
                        if (isToday) {
                            subText = `${venueName} ‚Ä¢ ${nextEvent.format || 'SETS'}`.toUpperCase();
                        } else {
                            subText = `Starts ${nextEvent.date}`;
                        }

                        contentHTML += `
                            <div class="mgr-card-container">
                                <div class="mgr-card-main">
                                    <div class="mgr-card-left">
                                        ${logoHTML}
                                        <div class="mgr-comp-name">${nextEvent.name}</div>
                                        <div class="mgr-comp-meta">${subText}</div>
                                    </div>
                                    <div class="mgr-card-right">
                                        ${isToday ? `
                                            <div class="mgr-event-details">
                                                ${!canEnter ? `
                                                    <div class="mgr-ineligible">
                                                        <div class="mgr-ineligible-icon">‚ö†Ô∏è</div>
                                                        <div class="mgr-ineligible-text">${ineligibleReason}</div>
                                                    </div>
                                                ` : ''}
                                                <div class="mgr-detail-row">
                                                    <span class="mgr-detail-label">Venue:</span>
                                                    <span class="mgr-detail-value">${venueName}</span>
                                                </div>
                                                <div class="mgr-detail-row">
                                                    <span class="mgr-detail-label">Entry Fee:</span>
                                                    <span class="mgr-detail-value ${entryFee > 0 ? 'mgr-cost' : ''}">¬£${entryFee.toLocaleString()}</span>
                                                </div>
                                                <div class="mgr-detail-row">
                                                    <span class="mgr-detail-label">Travel Cost:</span>
                                                    <span class="mgr-detail-value ${travelCost > 0 ? 'mgr-cost' : ''}">¬£${travelCost.toLocaleString()}</span>
                                                </div>
                                                <div class="mgr-detail-row mgr-detail-total">
                                                    <span class="mgr-detail-label">Total Cost:</span>
                                                    <span class="mgr-detail-value mgr-cost-total">¬£${totalCost.toLocaleString()}</span>
                                                </div>
                                                <div class="mgr-detail-row">
                                                    <span class="mgr-detail-label">Balance:</span>
                                                    <span class="mgr-detail-value" style="color: ${career.balance >= totalCost ? 'var(--pdc-green)' : '#e74c3c'}">¬£${(career.balance || 0).toLocaleString()}</span>
                                                </div>
                                                <div class="mgr-detail-row">
                                                    <span class="mgr-detail-label">Winner Prize:</span>
                                                    <span class="mgr-detail-value" style="color:var(--pdc-gold)">¬£${winnerPrize.toLocaleString()}</span>
                                                </div>
                                            </div>
                                        ` : `
                                            <div class="mgr-fixture-future">
                                                ${logoHTML}
                                                <div style="font-size:14px; color:#aaa; margin-bottom:5px; margin-top:15px;">PREPARING FOR</div>
                                                <div style="font-size:20px; font-weight:bold; color:#fff;">${nextEvent.name}</div>
                                            </div>
                                        `}
                                    </div>
                                </div>
                            </div>
                        `;

                        let buttonsHTML = '';
                        if (isToday) {
                            if (canEnter) {
                                buttonsHTML += `<button class="mgr-btn mgr-btn-primary" onclick="Season.startCareerEvent(${nextEvent.id}, 'play')">PLAY</button>`;
                                buttonsHTML += `<button class="mgr-btn mgr-btn-secondary" onclick="Season.advanceCareerDayManual()">SKIP</button>`;
                                buttonsHTML += `<button class="mgr-btn mgr-btn-info" onclick="Season.startCareerEvent(${nextEvent.id}, 'sim')">SIM</button>`;
                            } else {
                                buttonsHTML += `<button class="mgr-btn mgr-btn-info" onclick="Season.startCareerEvent(${nextEvent.id}, 'watch')">WATCH</button>`;
                                buttonsHTML += `<button class="mgr-btn mgr-btn-secondary" onclick="Season.startCareerEvent(${nextEvent.id}, 'sim')">SIM</button>`;
                            }
                        } else {
                            buttonsHTML += `<button class="mgr-btn mgr-btn-primary" onclick="Season.advanceCareerDayManual()">CONTINUE</button>`;
                            buttonsHTML += `<button class="mgr-btn mgr-btn-secondary" onclick="Season.trainCareerDay()">TRAINING</button>`;
                            buttonsHTML += `<button class="mgr-btn mgr-btn-secondary" onclick="Season.restCareerDay()">REST</button>`;
                            buttonsHTML += `<button class="mgr-btn mgr-btn-success" onclick="Season.workCareerDay()">WORK</button>`;
                        }


                        contentHTML += `<div class="mgr-actions">${buttonsHTML}</div>`;

                    } else {
                        contentHTML += `<div style="padding:40px; text-align:center; color:#666;">No upcoming events found. Season complete?</div>`;
                    }

                    dashboardContainer.innerHTML = `
                        <style>
                            .mgr-header { background: linear-gradient(90deg, #2c0e37 0%, #4a192c 100%); padding: 25px 30px; border-radius: 12px 12px 0 0; border-bottom: 2px solid rgba(255,215,0,0.3); display: flex; justify-content: space-between; align-items: center; }
                            .mgr-date { font-family: 'Bebas Neue', sans-serif; font-size: 42px; letter-spacing: 2px; color: white; text-shadow: 0 2px 10px rgba(0,0,0,0.5); }
                            .mgr-status { font-family: 'Roboto Condensed', sans-serif; font-weight: bold; font-size: 14px; color: #ccc; background: rgba(0,0,0,0.4); padding: 5px 12px; border-radius: 20px; }
                            .mgr-card-container { background: linear-gradient(180deg, #1e1e2d 0%, #151520 100%); padding: 30px; border-radius: 0 0 12px 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.3); margin-bottom: 20px; }
                            .mgr-card-main { display: flex; gap: 20px; align-items: flex-start; }
                            .mgr-card-left { flex: 2; border-right: 1px solid rgba(255,255,255,0.05); padding-right: 20px; }
                            .mgr-card-right { flex: 3; }
                            .mgr-comp-logo { width: 60px; height: 60px; background: var(--pdc-blue); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 18px; color: white; border: 3px solid rgba(255,255,255,0.2); margin-bottom: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); }
                            .mgr-comp-name { font-size: 24px; font-weight: bold; color: white; margin-bottom: 5px; line-height: 1.2; }
                            .mgr-comp-meta { font-size: 12px; color: #888; text-transform: uppercase; letter-spacing: 1px; }
                            .mgr-event-details { background: rgba(0,0,0,0.2); padding: 20px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.05); }
                            .mgr-ineligible { background: rgba(231,76,60,0.15); border: 1px solid rgba(231,76,60,0.3); border-radius: 8px; padding: 12px; margin-bottom: 15px; display: flex; align-items: center; gap: 10px; }
                            .mgr-ineligible-icon { font-size: 24px; }
                            .mgr-ineligible-text { color: #e74c3c; font-weight: bold; font-size: 13px; }
                            .mgr-detail-row { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.03); }
                            .mgr-detail-row:last-child { border-bottom: none; }
                            .mgr-detail-total { border-top: 2px solid rgba(255,215,0,0.2); margin-top: 8px; padding-top: 12px; font-weight: bold; }
                            .mgr-detail-label { color: #888; font-size: 13px; text-transform: uppercase; letter-spacing: 0.5px; }
                            .mgr-detail-value { color: white; font-weight: 600; font-size: 14px; }
                            .mgr-cost { color: #e74c3c !important; }
                            .mgr-cost-total { color: var(--pdc-gold) !important; font-size: 16px; }
                            .mgr-fixture-future { text-align: center; padding: 30px; }
                            .mgr-actions { display: flex; gap: 10px; padding: 10px 0; flex-wrap: wrap; }
                            .mgr-btn { padding: 15px 30px; border: none; border-radius: 6px; font-family: 'Roboto Condensed'; font-weight: bold; font-size: 14px; cursor: pointer; text-transform: uppercase; transition: all 0.2s; flex: 1; min-width: 120px; }
                            .mgr-btn:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
                            .mgr-btn-primary { background: var(--pdc-red); color: white; }
                            .mgr-btn-primary:hover { background: #ff1a1a; }
                            .mgr-btn-secondary { background: #2c3e50; color: white; }
                            .mgr-btn-secondary:hover { background: #34495e; }
                            .mgr-btn-info { background: #2980b9; color: white; }
                            .mgr-btn-info:hover { background: #3498db; }
                            .mgr-btn-success { background: #27ae60; color: white; }
                            .mgr-btn-success:hover { background: #2ecc71; }
                        </style>
                        ${contentHTML}
                    `;
                }

                // Update TODAY section with all events for today
                const todayContainer = document.getElementById('career-day-events');
                if (todayContainer) {
                    const eventsToday = Season.getEventsForDate(dateObj);
                    const completedIds = new Set(Season.state.completedEvents.map(c => c.id));

                    if (eventsToday.length > 0) {
                        let todayHTML = '';
                        eventsToday.forEach((ev, idx) => {
                            const isCompleted = completedIds.has(ev.id);
                            const isActive = idx === 0 && !isCompleted; // First non-completed event is active
                            const isLocked = !isActive && !isCompleted; // Future events today are locked

                            const locationInfo = (typeof TravelSystem !== 'undefined' && TravelSystem.resolveEventLocation)
                                ? TravelSystem.resolveEventLocation(ev)
                                : null;
                            const venueName = locationInfo?.venueName || ev.venue || ev.city || ev.location || 'Unknown Venue';

                            const statusBadge = isCompleted ? '<span style="color:#2ecc71;">‚úì COMPLETED</span>' :
                                isActive ? '<span style="color:#ffd700;">‚óè ACTIVE</span>' :
                                    '<span style="color:#888;">üîí LOCKED</span>';

                            todayHTML += `
                                <div style="padding: 10px; margin: 5px 0; background: ${isActive ? 'rgba(255,215,0,0.1)' : 'rgba(0,0,0,0.2)'}; border-left: 3px solid ${isActive ? 'var(--pdc-gold)' : isCompleted ? '#2ecc71' : '#444'}; border-radius: 4px;">
                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                        <div>
                                            <div style="font-weight: bold; color: white; margin-bottom: 3px;">${ev.name}</div>
                                            <div style="font-size: 11px; color: #888;">${venueName} ‚Ä¢ ${ev.format || 'SETS'}</div>
                                        </div>
                                        <div style="text-align: right; font-size: 12px;">
                                            ${statusBadge}
                                        </div>
                                    </div>
                                </div>
                            `;
                        });
                        todayContainer.innerHTML = todayHTML;

                        const summaryEl = document.getElementById('career-day-summary');
                        if (summaryEl) {
                            summaryEl.innerHTML = `<strong>${eventsToday.length}</strong> event${eventsToday.length > 1 ? 's' : ''} scheduled today`;
                        }
                    } else {
                        todayContainer.innerHTML = '<div class="career-muted">No events scheduled</div>';
                        const summaryEl = document.getElementById('career-day-summary');
                        if (summaryEl) summaryEl.innerHTML = 'No events today';
                    }
                }

                // Update OOM Preview on dashboard
                const oomContainer = document.getElementById('career-oom-container');
                if (oomContainer) {
                    oomContainer.innerHTML = '<table class="oom-table" id="career-dashboard-oom-table"></table>';
                    Season.renderOOMTable('career-dashboard-oom-table', Season.state.orderOfMerit, 10); // Show top 10
                }
            },



            toggleTrainingPanel: () => {
                const panel = document.getElementById('career-training-panel');
                if (!panel) return;
                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            },

            advanceCareerDayManual: () => {
                Season.ensureCareerState();
                if (Tournament.state.active) {
                    alert('Finish the current event before advancing the day.');
                    return;
                }

                const player = Season.getCareerPlayer();
                const career = Season.state.career;
                if (player) {
                    // Apply stat degradation for skipping training
                    const avgDecrease = parseFloat((Math.random() * 0.1 + 0.1).toFixed(2)); // -0.1 to -0.2
                    const coDecrease = parseFloat((Math.random() * 0.1 + 0.1).toFixed(2)); // -0.1 to -0.2
                    const formDecrease = Math.floor(Math.random() * 2 + 1); // -1 to -2

                    player.avg = Math.max(50, (player.avg || 60) - avgDecrease);
                    player.co = Math.max(20, (player.co || 30) - coDecrease);
                    player.form = Math.max(0, (player.form || 50) - formDecrease);
                }

                Season.advanceCareerDate(1);
                Season.state.career.lastAction = 'next';
                Season.state.career.lastActionDate = Season.state.career.currentDate;
                Season.renderCareerHub();
                Persistence.save();
            },

            workCareerDay: () => {
                Season.ensureCareerState();
                if (Tournament.state.active) {
                    alert('Finish the current event before working.');
                    return;
                }
                const career = Season.state.career;
                const player = Season.getCareerPlayer();
                if (!player) return;

                // Earn money from work (random ¬£500-¬£1500)
                const earnings = 500 + Math.floor(Math.random() * 1000);
                career.balance = (career.balance || 0) + earnings;

                // Increase fatigue slightly
                player.fatigue = Math.min(100, (player.fatigue || 0) + 2);

                // Advance day
                Season.advanceCareerDate(1);
                career.lastAction = 'work';
                career.lastActionDate = career.currentDate;

                alert(`‚úÖ Work Complete!\n\nYou earned ¬£${earnings.toLocaleString()} from work.\nFatigue increased slightly to ${player.fatigue.toFixed(1)}%`);

                Season.renderCareerHub();
                Persistence.save();
            },

            trainCareerDay: () => {
                Season.ensureCareerState();
                if (Tournament.state.active) {
                    alert('Finish the current event before training.');
                    return;
                }
                const player = Season.getCareerPlayer();
                const career = Season.state.career;
                const todayDate = Season.state.career.currentDate;
                const lastWorkDate = Season.state.career.lastWorkDate;
                if (!player) return;

                // Check if worked today
                if (lastWorkDate === todayDate) {
                    alert('You cannot train on a day you worked! You must choose one or the other.');
                    return;
                }

                // Ensure stats exist before training
                if (!player.avg) player.avg = 60;
                if (!player.co) player.co = 30;
                if (!player.form) player.form = 50;
                if (!player.fatigue) player.fatigue = 0;

                // Training improves stats but increases fatigue (IMPROVED GAINS)
                const avgIncrease = parseFloat((Math.random() * 1.2 + 0.3).toFixed(2));
                const coIncrease = parseFloat((Math.random() * 2.0 + 0.5).toFixed(2));
                const fatigueIncrease = 5 + Math.random() * 5;

                player.avg = Math.min(100, player.avg + avgIncrease);
                player.co = Math.min(60, player.co + coIncrease);
                player.form = Math.min(100, player.form + 2);
                player.fatigue = Math.min(100, player.fatigue + fatigueIncrease);

                Season.advanceCareerDate(1);
                career.lastAction = 'train';
                career.lastActionDate = career.currentDate;
                career.lastTrainDate = career.currentDate;

                alert(`üéØ Training Complete!\n\nAVG: +${avgIncrease.toFixed(2)}\nCO: +${coIncrease.toFixed(2)}%\nForm: +2\nFatigue: +${fatigueIncrease.toFixed(1)}%\n\nNew Stats:\nAVG: ${player.avg.toFixed(2)}\nCO: ${player.co.toFixed(1)}%\nFatigue: ${player.fatigue.toFixed(1)}%`);

                Season.renderCareerHub();
                Persistence.save();
            },

            restCareerDay: () => {
                Season.ensureCareerState();
                if (Tournament.state.active) {
                    alert('Finish the current event before resting.');
                    return;
                }
                const player = Season.getCareerPlayer();
                const career = Season.state.career;
                if (!player) return;

                // Rest reduces fatigue significantly
                const fatigueReduction = 10 + Math.random() * 10;
                player.fatigue = Math.max(0, (player.fatigue || 0) - fatigueReduction);

                Season.advanceCareerDate(1);
                career.lastAction = 'rest';
                career.lastActionDate = career.currentDate;

                alert(`üò¥ Rest Day Complete!\n\nFatigue reduced by ${fatigueReduction.toFixed(1)}%\nNew Fatigue: ${player.fatigue.toFixed(1)}%`);

                Season.renderCareerHub();
                Persistence.save();
            },

            switchCareerIntel: (tab) => {
                Season.ensureCareerState();
                Season.state.career.intelTab = tab;
                const newsTab = document.getElementById('career-intel-tab-news');
                const standingsTab = document.getElementById('career-intel-tab-standings');
                const newsView = document.getElementById('career-intel-news');
                const standingsView = document.getElementById('career-intel-standings');
                if (newsTab) newsTab.classList.toggle('active', tab === 'news');
                if (standingsTab) standingsTab.classList.toggle('active', tab === 'standings');
                if (newsView) newsView.style.display = tab === 'news' ? 'block' : 'none';
                if (standingsView) standingsView.style.display = tab === 'standings' ? 'block' : 'none';
                Season.renderCareerNews();
                Season.renderCareerStandings();
            },

            switchCareerStandings: (tab) => {
                Season.ensureCareerState();
                Season.state.career.standingsTab = tab;
                const tabs = {
                    oom: 'career-standings-oom-tab',
                    premier: 'career-standings-premier-tab',
                    qschool: 'career-standings-qschool-tab'
                };
                Object.entries(tabs).forEach(([key, id]) => {
                    const el = document.getElementById(id);
                    if (el) el.classList.toggle('active', key === tab);
                });
                const views = {
                    oom: 'career-standings-oom',
                    premier: 'career-standings-premier',
                    qschool: 'career-standings-qschool'
                };
                Object.entries(views).forEach(([key, id]) => {
                    const el = document.getElementById(id);
                    if (el) el.style.display = key === tab ? 'block' : 'none';
                });
                Season.renderCareerStandings();
            },

            switchCareerQSchool: (location) => {
                Season.ensureCareerState();
                Season.state.career.qschoolTab = location;
                const ukBtn = document.getElementById('career-qschool-uk');
                const euBtn = document.getElementById('career-qschool-eu');
                const ukView = document.getElementById('career-qschool-uk-view');
                const euView = document.getElementById('career-qschool-eu-view');
                if (ukBtn) ukBtn.classList.toggle('active', location === 'uk');
                if (euBtn) euBtn.classList.toggle('active', location === 'eu');
                if (ukView) ukView.style.display = location === 'uk' ? 'block' : 'none';
                if (euView) euView.style.display = location === 'eu' ? 'block' : 'none';
                Season.renderCareerStandings();
            },



            renderCareerNews: () => {
                if (Season.state.career.intelTab !== 'news') return;
                if (typeof NewsSystem !== 'undefined' && NewsSystem.renderNews) {
                    NewsSystem.renderNews(NewsSystem.viewState.filter, 'career-news-feed');
                }
            },

            renderCareerStandings: () => {
                if (Season.state.career.intelTab !== 'standings') return;
                const tab = Season.state.career.standingsTab;
                const tabs = {
                    oom: 'career-standings-oom-tab',
                    premier: 'career-standings-premier-tab',
                    qschool: 'career-standings-qschool-tab'
                };
                Object.entries(tabs).forEach(([key, id]) => {
                    const el = document.getElementById(id);
                    if (el) el.classList.toggle('active', key === tab);
                });
                const views = {
                    oom: 'career-standings-oom',
                    premier: 'career-standings-premier',
                    qschool: 'career-standings-qschool'
                };
                Object.entries(views).forEach(([key, id]) => {
                    const el = document.getElementById(id);
                    if (el) el.style.display = key === tab ? 'block' : 'none';
                });
                const qsTab = Season.state.career.qschoolTab || 'uk';
                const ukBtn = document.getElementById('career-qschool-uk');
                const euBtn = document.getElementById('career-qschool-eu');
                const ukView = document.getElementById('career-qschool-uk-view');
                const euView = document.getElementById('career-qschool-eu-view');
                if (ukBtn) ukBtn.classList.toggle('active', qsTab === 'uk');
                if (euBtn) euBtn.classList.toggle('active', qsTab === 'eu');
                if (ukView) ukView.style.display = qsTab === 'uk' ? 'block' : 'none';
                if (euView) euView.style.display = qsTab === 'eu' ? 'block' : 'none';

                if (tab === 'oom') {
                    const container = document.getElementById('career-standings-oom');
                    if (container) {
                        container.innerHTML = '<table class="oom-table" id="career-oom-table"></table>';
                        Season.renderOOMTable('career-oom-table', Season.state.orderOfMerit);
                    }
                } else if (tab === 'premier') {
                    Season.renderPremierLeagueStandingsTo('career-standings-premier');
                } else if (tab === 'qschool') {
                    Season.renderQSchoolStandingsForLocationTo('uk', 'career-qschool-uk-view');
                    Season.renderQSchoolStandingsForLocationTo('eu', 'career-qschool-eu-view');
                }
            },

            canCareerPlayerEnterEvent: (ev, options = {}) => {
                const player = Season.getCareerPlayer();
                if (!player || !ev) return false;
                const skipEntryCheck = options.skipEntryCheck === true;

                // Premier League is invitational: ignore entry/fatigue/tour-card checks
                if (ev.type === 'premier-league') {
                    return (Season.state.premierLeague?.players || []).includes(player.name);
                }
                if (ev.type === 'premier-league-playoff') {
                    const qualifiers = Season.state.premierLeague?.playoffQualifiers || [];
                    return qualifiers.includes(player.name);
                }

                // Enrich player with career balance for EntrySystem checks
                const career = Season.state.career;
                const enrichedPlayer = {
                    ...player,
                    money: career.balance || player.money || 0,
                    currentRegion: career.currentRegion || player.home?.region || 'uk',
                    fatigue: player.fatigue || 0
                };

                // NEW: Check money, travel costs, and fatigue using EntrySystem
                if (!skipEntryCheck && typeof EntrySystem !== 'undefined' && EntrySystem.canEnterEvent) {
                    const entryCheck = EntrySystem.canEnterEvent(ev, enrichedPlayer);
                    if (!entryCheck.canEnter) {
                        console.log(`[Career] Cannot enter ${ev.name}: ${entryCheck.reason}`);
                        return false;
                    }
                }

                // Existing eligibility checks
                if (ev.type === 'q-school') {
                    // Q-School: Always allow eligible players who don't have a tour card yet
                    if (player.tourCard) return false;
                    if (ev.eligibleRegions && ev.eligibleRegions.length > 0) {
                        return ev.eligibleRegions.includes(player.country);
                    }
                    return true;
                }

                if (ev.type === 'challenge') {
                    if (player.tourCard) return false;
                    if (ev.eligibleRegions && ev.eligibleRegions.length > 0) {
                        return ev.eligibleRegions.includes(player.country);
                    }
                    return true;
                }
                // Helper: Check if already qualified for target event
                const isAllocated = (targetId) => {
                    if (!targetId) return false;
                    const tEv = Season.events.find(e => e.id === targetId);
                    return tEv && Season.canCareerPlayerEnterEvent(tEv, { skipEntryCheck: true });
                };

                if (ev.type === 'et-host-nation') {
                    if (isAllocated(ev.targetEvent)) return false;
                    const host = HOST_NATION[ev.targetEvent];
                    return host ? player.country === host : false;
                }
                if (ev.type === 'et-east-european') {
                    if (isAllocated(ev.targetEvent)) return false;
                    return REGION_MAP.east.includes(player.country);
                }
                if (ev.type === 'et-nordic-baltic') {
                    if (isAllocated(ev.targetEvent)) return false;
                    return REGION_MAP.nordic.includes(player.country);
                }

                // QUALIFIERS: Check if already qualified for target event
                if (ev.type === 'et-qual-tc' || ev.type === 'ws-qual-tc' || ev.type === 'gs-qual-tc') {
                    if (!player.tourCard) return false;
                    if (isAllocated(ev.targetEvent)) return false;
                    return true;
                }

                if (ev.type === 'wmasters-qual') {
                    if (isAllocated(ev.targetEvent)) return false;
                    return true;
                }

                if (ev.type === 'wc-qual-tc') {
                    if (!player.tourCard) return false;
                    const worldEv = Season.events.find(e => e.type === 'world');
                    if (worldEv && Season.canCareerPlayerEnterEvent(worldEv)) return false;
                    return true;
                }

                if (ev.type === 'wc-qual-intl') {
                    // Check if already qualified for worlds
                    const worldEv = Season.events.find(e => e.type === 'world');
                    if (worldEv && Season.canCareerPlayerEnterEvent(worldEv)) return false;
                    return !player.tourCard || (ev.eligibleRegions ? ev.eligibleRegions.includes(player.country) : true);
                }

                if (ev.type === 'players') {
                    return !!player.tourCard;
                }

                if (ev.type === 'minor') {
                    // European Tour: Top 16 Main (Seeds) + Top 16 ProTour (Non-Seeds) + Qualifiers
                    const oomSorted = Object.entries(Season.state.orderOfMerit).sort((a, b) => b[1] - a[1]);
                    const seeds = oomSorted.slice(0, 16).map(e => e[0]);

                    if (seeds.includes(player.name)) return true;

                    const proQual = Object.entries(Season.state.proTourOOM)
                        .sort((a, b) => b[1] - a[1])
                        .map(e => e[0])
                        .filter(name => !seeds.includes(name))
                        .slice(0, 16);

                    if (proQual.includes(player.name)) return true;

                    const qData = Season.state.etQualifiers?.[ev.id] || {};
                    const qNames = [].concat(qData.tc || [], qData.host || [], qData.nb || [], qData.east || []);
                    return qNames.includes(player.name);
                }

                if (ev.type === 'matchplay' || ev.type === 'grandprix') {
                    const oomSorted = Object.entries(Season.state.orderOfMerit).sort((a, b) => b[1] - a[1]);
                    const topMain = oomSorted.slice(0, 16).map(e => e[0]);

                    if (topMain.includes(player.name)) return true;

                    const topPro = Object.entries(Season.state.proTourOOM)
                        .sort((a, b) => b[1] - a[1])
                        .map(e => e[0])
                        .filter(name => !topMain.includes(name))
                        .slice(0, 16);

                    return topPro.includes(player.name);
                }

                if (ev.type === 'uk-open') {
                    if (player.tourCard) return true;
                    return (Season.state.ukOpenQualifiers || []).includes(player.name);
                }

                if (ev.type === 'playersf') {
                    const top64 = Object.entries(Season.state.proTourOOM)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 64)
                        .map(e => e[0]);
                    return top64.includes(player.name);
                }

                if (ev.type === 'europeanf') {
                    const top32 = Object.entries(Season.state.orderOfMerit)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 32)
                        .map(e => e[0]);
                    return top32.includes(player.name);
                }

                if (ev.type === 'world') {
                    const list = Season.buildWorldChampionshipQualifiers();
                    return list.includes(player.name);
                }

                if (ev.type === 'grandslam') {
                    const list = Season.buildGrandSlamQualifiers();
                    return list.includes(player.name);
                }

                if (ev.type === 'masters-final') {
                    const wsTop = Object.entries(Season.state.worldSeriesOOM)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 24)
                        .map(e => e[0]);
                    return wsTop.includes(player.name);
                }

                if (ev.type === 'masters') {
                    const topMain = Object.entries(Season.state.orderOfMerit)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 8)
                        .map(e => e[0]);

                    if (topMain.includes(player.name)) return true;

                    const regionTop = PLAYERS_DB
                        .filter(p => REGION_MAP[ev.region]?.includes(p.country))
                        .sort((a, b) => (Season.state.orderOfMerit[b.name] || 0) - (Season.state.orderOfMerit[a.name] || 0))
                        .filter(p => !topMain.includes(p.name))
                        .slice(0, 8)
                        .map(p => p.name);

                    return regionTop.includes(player.name);
                }

                if (ev.type === 'winmaudm') {
                    let seeds = [];
                    const oomEntries = Object.entries(Season.state.orderOfMerit);

                    if (oomEntries.length >= 24) {
                        // FIX: Add secondary sort by AVG (skill) to handle start-of-season tie (all ¬£0)
                        seeds = oomEntries.sort((a, b) => {
                            if (b[1] !== a[1]) return b[1] - a[1];
                            const pA = PLAYERS_DB.find(p => p.name === a[0]);
                            const pB = PLAYERS_DB.find(p => p.name === b[0]);
                            return (pB?.avg || 0) - (pA?.avg || 0);
                        }).slice(0, 24).map(e => e[0]);
                    } else if (typeof PLAYERS_DB !== 'undefined') {
                        // Fallback: Use PLAYERS_DB sorted by average (skill) as a proxy for ranking if OOM is empty
                        seeds = [...PLAYERS_DB].sort((a, b) => b.avg - a.avg).slice(0, 24).map(p => p.name);
                    }

                    // Exclude Luke Littler from automatic seeding - must come through qualifiers
                    seeds = seeds.filter(name => name !== 'Luke Littler');

                    if (seeds.includes(player.name)) return true;
                    // Check qualifiers list
                    const qualList = (Season.state.wmQualifiers && Season.state.wmQualifiers[ev.id]) || (Season.state.winmauQualifiers || []);
                    return qualList.includes(player.name);
                }

                if (ev.cardRequired && !player.tourCard) return false;
                return true;
            },

            startCareerEvent: (eventId, mode) => {
                Season.ensureCareerState();
                if (Tournament.state.active) {
                    alert('Finish the current event before starting another.');
                    return;
                }
                const dateObj = Season.getCareerDateObj();
                const eventsToday = Season.getEventsForDate(dateObj);
                const ev = eventsToday.find(e => e.id === eventId);
                if (!ev) return;

                const completed = Season.state.completedEvents.find(c => c.id === ev.id);
                if (completed) {
                    alert('This event is already completed.');
                    return;
                }

                const iso = Season.state.career.currentDate;
                const idx = Season.events.findIndex(e => e.id === ev.id);
                if (idx < 0) return;

                // Check eligibility for 'play' mode
                // For Q-School, skip EntrySystem checks (money/fatigue) - only verify basic eligibility
                const isEligible = Season.canCareerPlayerEnterEvent(ev, { skipEntryCheck: ev.type === 'q-school' });

                if (mode === 'play' && !isEligible) {
                    alert('You are not eligible for this event.');
                    return;
                }

                Season.state.career.lastAction = 'event';
                Season.state.career.lastActionDate = iso;
                Season.state.career.pendingEventSummary = {
                    eventId: ev.id,
                    eventName: ev.name,
                    moneyBefore: Season.getCareerPlayer() ? (Season.getCareerPlayer().money || 0) : 0
                };

                if (mode === 'play') {
                    // Only 'play' mode charges entry fees and includes player
                    Season.pendingEventPolicy = { action: mode, forceInclude: true, forceExclude: false, chargesFees: true };
                    Season.startEvent(idx, false);
                    return;
                }

                if (mode === 'watch') {
                    // Watch mode: spectator only, no fees, player not included
                    Season.pendingEventPolicy = { action: mode, forceInclude: false, forceExclude: true, chargesFees: false };
                    Season.startEvent(idx, false);
                    return;
                }

                // Sim mode: Include player only if eligible
                const canEnterSim = Season.canCareerPlayerEnterEvent(ev, { skipEntryCheck: false });
                Season.pendingEventPolicy = {
                    action: mode,
                    forceInclude: canEnterSim,
                    forceExclude: !canEnterSim,
                    chargesFees: canEnterSim // Charge fees if player is participating
                };
                Season.startEvent(idx, true);
            },

            simulateCareerDay: () => {
                if (Season.isSimulatingDay) return;
                Season.isSimulatingDay = true;

                try {
                    Season.ensureCareerState();
                    if (Tournament.state.active) {
                        alert('Finish the current event before advancing the day.');
                        return;
                    }
                    const dateObj = Season.getCareerDateObj();
                    const eventsToday = Season.getEventsForDate(dateObj);
                    const iso = Season.state.career.currentDate;

                    if (Season.state.career.dayChoices[iso]) {
                        alert('Day already scheduled.');
                        return;
                    }

                    const completedIds = new Set((Season.state.career.completedEvents || []).map(c => c.id));
                    const allEventsDoneToday = eventsToday.length > 0 && eventsToday.every(ev => completedIds.has(ev.id));

                    if (eventsToday.length > 0 && !allEventsDoneToday) {
                        const canCompete = eventsToday.some(ev => Season.canCareerPlayerEnterEvent(ev));
                        if (canCompete) Season.state.career.missedCompetitiveDays += 1;
                        Season.state.career.dayChoices[iso] = { action: 'sim', eventId: null };
                        Season.simulateEventsForDate(dateObj, true, false);
                    }

                    Season.state.career.lastAction = 'sim';
                    Season.state.career.lastActionDate = iso;

                    if (eventsToday.length === 0 || allEventsDoneToday) {
                        Season.advanceCareerDate(1);
                    }
                    Season.renderCareerHub();
                    Persistence.save();
                } finally {
                    Season.isSimulatingDay = false;
                }
            },

            trainCareerDay: (type) => {
                Season.ensureCareerState();
                if (!Season.getCareerPlayer()) {
                    alert('Select a career player before training.');
                    return;
                }
                if (Tournament.state.active) {
                    alert('Finish the current event before training.');
                    return;
                }
                const dateObj = Season.getCareerDateObj();
                const iso = Season.state.career.currentDate;
                const lastWorkDate = Season.state.career.lastWorkDate;
                const eventsToday = Season.getEventsForDate(dateObj);

                // Check if player is actually participating in any events today
                if (eventsToday.length > 0) {
                    const player = Season.getCareerPlayer();
                    const canEnterAny = eventsToday.some(ev => Season.canCareerPlayerEnterEvent(ev));
                    if (canEnterAny) {
                        alert('You cannot train on days with available competitive events.');
                        return;
                    }
                    // If no eligible events today, allow training
                }

                // Check if worked today
                if (lastWorkDate === iso) {
                    alert('You cannot train on a day you worked! You must choose one or the other.');
                    return;
                }

                // Check if already trained today
                const lastActionDate = Season.state.career.lastActionDate;
                if (lastActionDate === iso && Season.state.career.lastAction === 'train') {
                    alert('You can only train once per day.');
                    return;
                }

                if (Season.state.career.dayChoices[iso]) {
                    alert('Day already scheduled.');
                    return;
                }

                const result = Season.applyTraining(type || 'scoring');
                Season.showTrainingAnimation(type || 'scoring', result);
                Season.state.career.dayChoices[iso] = { action: 'train', eventId: null };
                Season.state.career.lastTrainDate = iso;

                // If there are unplayed events today, simulate them first
                // The simulation will advance the day automatically, so don't advance manually
                if (eventsToday.length > 0) {
                    Season.simulateEventsForDate(dateObj, true, true); // autoSim=true, skipParticipation=true
                } else {
                    // Only advance date if there were no events to simulate
                    Season.advanceCareerDate(1);
                }

                Season.renderCareerHub();
                Persistence.save();
            },

            showTrainingAnimation: (type, result) => {
                const player = Season.getCareerPlayer();
                if (!player) return;

                // Create overlay if it doesn't exist
                let overlay = document.getElementById('career-training-overlay');
                if (!overlay) {
                    overlay = document.createElement('div');
                    overlay.id = 'career-training-overlay';
                    overlay.className = 'career-training-overlay';
                    document.body.appendChild(overlay);
                }

                // Training type labels and messages
                const trainingLabels = {
                    scoring: { title: 'Scoring Session', sub: 'Precision and grouping work' },
                    checkout: { title: 'Checkout Drills', sub: 'Finishing practice' },
                    consistency: { title: 'Consistency Lab', sub: 'Shot accuracy testing' },
                    stamina: { title: 'Stamina Session', sub: 'High-intensity fitness' }
                };

                const label = trainingLabels[type] || trainingLabels.scoring;

                const formDelta = result?.formDelta ?? 0;
                const fatigueDelta = result?.fatigueDelta ?? 0;
                const avgDelta = result?.avgDelta ?? 0;
                const coDelta = result?.coDelta ?? 0;

                // Build HTML with all stats
                overlay.innerHTML = `
                    <div class="career-training-card">
                        <div class="career-training-title">${label.title}</div>
                        <div class="career-training-sub">${label.sub}</div>
                        <div class="career-training-stats">
                            <div>AVG: <strong>${avgDelta >= 0 ? '+' : ''}${avgDelta.toFixed(2)}</strong></div>
                            <div>C/O: <strong>${coDelta >= 0 ? '+' : ''}${coDelta.toFixed(2)}%</strong></div>
                            <div>FORM: <strong>${formDelta >= 0 ? '+' : ''}${Math.round(formDelta)}</strong></div>
                            <div>FAT: <strong>${fatigueDelta >= 0 ? '+' : ''}${Math.round(fatigueDelta)}%</strong></div>
                        </div>
                    </div>
                `;

                overlay.classList.add('active');

                // Auto-close after 1.8 seconds
                setTimeout(() => {
                    overlay.classList.remove('active');
                }, 1800);
            },

            restCareerDay: () => {
                Season.ensureCareerState();
                if (Tournament.state.active) {
                    alert('Finish the current event before resting.');
                    return;
                }
                const dateObj = Season.getCareerDateObj();
                const iso = Season.state.career.currentDate;
                const eventsToday = Season.getEventsForDate(dateObj);

                if (Season.state.career.dayChoices[iso]) {
                    alert('Day already scheduled.');
                    return;
                }

                if (eventsToday.length > 0) {
                    const proceed = confirm('A tournament is scheduled today. Rest will skip all events. Continue?');
                    if (!proceed) return;
                    const canCompete = eventsToday.some(ev => Season.canCareerPlayerEnterEvent(ev));
                    if (canCompete) Season.state.career.missedCompetitiveDays += 1;
                    Season.simulateEventsForDate(dateObj, true, true);
                }

                // Use new RestSystem (full rest = true rust)
                Season.performCareerRest(false);
                Season.state.career.dayChoices[iso] = { action: 'rest', eventId: null };
            },

            applyTraining: (type) => {
                const player = Season.getCareerPlayer();
                if (!player) return;

                // Ensure player has form initialized
                if (typeof player.form === 'undefined') {
                    player.form = 50;
                }

                const career = Season.state.career;
                const overused = career.trainingStreak >= 5; // Much stricter - 5+ days in a row
                const tooFatigued = (player.fatigue || 0) > 85; // Only if VERY fatigued (>85%)

                // Training has trade-offs: improving one stat may reduce the other
                // All training improves FORM significantly

                let formDelta = tooFatigued ? -2 : 4; // Base form gain
                let fatigueDelta = tooFatigued ? 20 : 12; // Training is tiring!
                let avgDelta = 0;
                let coDelta = 0;

                // Stat changes based on training type - TRADE-OFF SYSTEM
                if (type === 'scoring') {
                    // Scoring session focuses on average, slight CO% loss
                    avgDelta = overused ? 0.15 : 0.4;
                    coDelta = overused ? -0.05 : -0.1; // Small CO% trade-off
                    formDelta += 2; // Extra form bonus
                } else if (type === 'checkout') {
                    // Checkout drills focus on CO%, slight AVG loss
                    coDelta = overused ? 0.15 : 0.4;
                    avgDelta = overused ? -0.05 : -0.1; // Small AVG trade-off
                    formDelta += 2; // Extra form bonus
                } else if (type === 'consistency') {
                    // Consistency lab improves both equally, no trade-offs
                    avgDelta = overused ? 0.1 : 0.25;
                    coDelta = overused ? 0.1 : 0.25;
                    player.consistency = Math.min(100, (player.consistency || 50) + (overused ? 1 : 3));
                    formDelta += 2; // Extra form bonus
                } else if (type === 'stamina') {
                    // Stamina reduces fatigue AND improves form
                    avgDelta = overused ? 0.05 : 0.15;
                    coDelta = overused ? 0.05 : 0.15;
                    fatigueDelta = overused ? 10 : 2; // Stamina reduces fatigue loss compared to other training
                    formDelta += 4; // Extra form bonus (most impactful)
                }

                // Apply stat changes with caps
                player.avg = Math.min(110, Math.max(60, (player.avg || 75) + avgDelta));
                player.co = Math.min(60, Math.max(20, (player.co || 30) + coDelta));

                PlayerState.updateForm(player, formDelta);
                PlayerState.updateFatigue(player, fatigueDelta);

                career.trainingStreak += 1;
                career.lastAction = 'train';
                career.lastActionDate = career.currentDate;

                return { formDelta, fatigueDelta, avgDelta, coDelta };
            },

            applyRest: () => {
                const player = Season.getCareerPlayer();
                if (!player) return;

                PlayerState.updateFatigue(player, -18);
                PlayerState.updateForm(player, 1);
                player.consistency = Math.max(0, Math.min(100, (player.consistency || 50) + 1));

                Season.state.career.trainingStreak = 0;
                Season.state.career.lastAction = 'rest';
                Season.state.career.lastActionDate = Season.state.career.currentDate;
            },

            advanceCareerDate: (days) => {
                const dateObj = Season.getCareerDateObj();
                if (!dateObj) return;
                dateObj.setDate(dateObj.getDate() + (days || 1));
                Season.state.career.currentDate = Season.toISODate(dateObj);
            },

            simulateEventsForDate: (dateObj, autoSim, skipParticipation) => {
                const indices = Season.getEventIndicesForDate(dateObj);
                if (!indices.length) return;

                indices.forEach(idx => {
                    if (idx < Season.state.activeEventIndex) return;
                    const ev = Season.events[idx];
                    if (!ev) return;
                    if (skipParticipation) {
                        Season.pendingEventPolicy = { action: 'skip', forceInclude: false, forceExclude: true };
                    } else {
                        // Include player only if eligible (includes money/fatigue/eligibility checks)
                        const canEnter = Season.canCareerPlayerEnterEvent(ev);
                        Season.pendingEventPolicy = {
                            action: 'sim',
                            forceInclude: canEnter,
                            forceExclude: !canEnter,
                            chargesFees: false // Auto-entry (no dialog)
                        };
                    }
                    Season.startEvent(idx, !!autoSim);
                });
            },

            applyCareerParticipationToSelection: (ev) => {
                Season.ensureCareerState();
                const player = Season.getCareerPlayer();
                if (!player || !ev) return;
                const policy = Season.pendingEventPolicy || {};

                // Enrich player with career balance for cost calculations
                const career = Season.state.career;
                const enrichedPlayer = {
                    ...player,
                    money: career.balance || player.money || 0,
                    currentRegion: career.currentRegion || player.home?.region || 'uk',
                    fatigue: player.fatigue || 0
                };

                Season.state.career.activeEventId = ev.id;
                Season.state.career.activeEventParticipating = false;

                const playerIdx = PLAYERS_DB.findIndex(p => p.name === player.name);
                if (playerIdx < 0) return;

                if (ev.type === 'uk-open' && Tournament.state.ukOpenEntrants) {
                    const entrants = Tournament.state.ukOpenEntrants;
                    const allLists = [entrants.R1 || [], entrants.R2 || [], entrants.R3 || [], entrants.R4Top32 || []];
                    const hasPlayer = allLists.some(list => list.includes(playerIdx));

                    if (policy.forceInclude && !hasPlayer) {
                        const r1 = entrants.R1 || [];
                        if (r1.length > 0) r1[r1.length - 1] = playerIdx;
                    }

                    if (policy.forceExclude && hasPlayer) {
                        const used = new Set(allLists.flat());
                        const replacementIdx = PLAYERS_DB.findIndex((p, idx) => !used.has(idx));
                        allLists.forEach(list => {
                            const pos = list.indexOf(playerIdx);
                            if (pos > -1) list[pos] = replacementIdx >= 0 ? replacementIdx : list[pos];
                        });
                    }

                    const updatedLists = [entrants.R1 || [], entrants.R2 || [], entrants.R3 || [], entrants.R4Top32 || []];
                    Season.state.career.activeEventParticipating = updatedLists.some(list => list.includes(playerIdx));
                    Season.pendingEventPolicy = null;
                    return;
                }

                if (policy.forceExclude) {
                    Tournament.state.selectedPlayerIndices.delete(playerIdx);
                    console.log(`[Career] Player excluded from ${ev.name}`);
                }

                if (policy.forceInclude) {
                    // If tournament is at capacity and player is not already in, remove a random player to make room
                    if (ev.players && Tournament.state.selectedPlayerIndices.size >= ev.players && !Tournament.state.selectedPlayerIndices.has(playerIdx)) {
                        // Find a random player to remove (excluding the career player)
                        const candidates = Array.from(Tournament.state.selectedPlayerIndices).filter(idx => idx !== playerIdx);
                        if (candidates.length > 0) {
                            const randomIdx = candidates[Math.floor(Math.random() * candidates.length)];
                            Tournament.state.selectedPlayerIndices.delete(randomIdx);
                            console.log(`[Career] Tournament at capacity (${ev.players}), removed player ${PLAYERS_DB[randomIdx]?.name} to make room for ${player.name}`);
                        }
                    }

                    // Now add the career player
                    Tournament.state.selectedPlayerIndices.add(playerIdx);
                    Season.state.career.activeEventParticipating = true;

                    // Check if player can enter and get details
                    const canEnter = Season.canCareerPlayerEnterEvent(ev);

                    if (canEnter) {
                        // Get entry details to show costs (only for 'play' mode that charges fees)
                        if (policy.chargesFees !== false && typeof EntrySystem !== 'undefined' && EntrySystem.calculateEntryCost) {
                            const costData = EntrySystem.calculateEntryCost(ev, enrichedPlayer);
                            const location = TravelSystem.resolveEventLocation(ev);

                            console.log(`[Career] Entering ${ev.name} - Entry: ¬£${costData.entryFee}, Travel: ¬£${costData.travelCost}, Total: ¬£${costData.totalCost}`);

                            // Show animated cost confirmation dialog
                            const overlay = document.createElement('div');
                            overlay.style.cssText = `
                                position: fixed;
                                top: 0; left: 0; right: 0; bottom: 0;
                                background: rgba(0,0,0,0.7);
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                z-index: 10000;
                                animation: fadeIn 0.4s ease-out;
                            `;

                            const card = document.createElement('div');
                            card.style.cssText = `
                                background: linear-gradient(145deg, #1a1f35, #0f1525);
                                border: 2px solid var(--pdc-gold);
                                border-radius: 12px;
                                padding: 40px;
                                max-width: 500px;
                                width: 90%;
                                animation: slideDown 0.5s ease-out;
                                box-shadow: 0 10px 40px rgba(255, 215, 0, 0.2);
                            `;

                            let costHTML = `
                                <div style="text-align: center;">
                                    <div style="font-size: 16px; color: #999; margin-bottom: 20px;">EVENT ENTRY</div>
                                    <div style="font-size: 28px; font-weight: bold; color: var(--pdc-gold); margin-bottom: 5px;">${ev.name}</div>
                                    <div style="font-size: 14px; color: #aaa; margin-bottom: 30px;">${location.city}, ${location.country}</div>
                                    
                                    <div style="background: rgba(255,215,0,0.05); border-left: 3px solid var(--pdc-gold); padding: 15px; margin: 20px 0; text-align: left;">
                                        <div style="font-size: 12px; color: #999; margin-bottom: 10px;">COSTS:</div>
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 13px;">
                                            <span>Entry Fee:</span>
                                            <span style="color: var(--pdc-gold); font-weight: bold;">¬£${costData.entryFee}</span>
                                        </div>
                            `;

                            if (costData.travelCost > 0) {
                                costHTML += `
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 13px;">
                                            <span>Travel & Accommodation:</span>
                                            <span style="color: var(--pdc-gold); font-weight: bold;">¬£${costData.travelCost}</span>
                                        </div>
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 13px; color: #ff9800;">
                                            <span>Fatigue Impact:</span>
                                            <span style="font-weight: bold;">+${costData.fatigueFromTravel}</span>
                                        </div>
                                `;
                            }

                            costHTML += `
                                        <div style="border-top: 1px solid rgba(255,215,0,0.3); padding-top: 10px; margin-top: 10px; display: flex; justify-content: space-between; font-weight: bold;">
                                            <span style="color: #fff;">TOTAL COST:</span>
                                            <span style="color: var(--pdc-gold); font-size: 16px;">¬£${costData.totalCost}</span>
                                        </div>
                                    </div>
                                    
                                    <div style="margin-top: 25px; text-align: left;">
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 10px; font-size: 13px;">
                                            <span style="color: #999;">Your Balance:</span>
                                            <span style="color: #fff; font-weight: bold;">¬£${enrichedPlayer.money.toLocaleString()}</span>
                                        </div>
                                        <div style="display: flex; justify-content: space-between; font-size: 13px;">
                                            <span style="color: #999;">After Entry:</span>
                                            <span style="color: var(--pdc-gold); font-weight: bold;">¬£${(enrichedPlayer.money - costData.totalCost).toLocaleString()}</span>
                                        </div>
                                    </div>
                                    
                                    <div style="display: flex; gap: 10px; margin-top: 30px;">
                                        <button style="flex: 1; padding: 12px; background: #444; color: #fff; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;" onclick="this.closest('[data-overlay]').remove();">CANCEL</button>
                                        <button style="flex: 1; padding: 12px; background: #3498db; color: #fff; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;" onclick="this.closest('[data-overlay]').remove(); window.proceedWithEntry='play';">CONFIRM & PLAY</button>
                                        <button style="flex: 1; padding: 12px; background: var(--pdc-gold); color: #000; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;" onclick="this.closest('[data-overlay]').remove(); window.proceedWithEntry='enter';">CONFIRM</button>
                                    </div>
                                </div>
                                <style>
                                    @keyframes fadeIn {
                                        from { opacity: 0; }
                                        to { opacity: 1; }
                                    }
                                    @keyframes slideDown {
                                        from { opacity: 0; transform: translateY(-30px); }
                                        to { opacity: 1; transform: translateY(0); }
                                    }
                                </style>
                            `;

                            card.innerHTML = costHTML;
                            card.setAttribute('data-overlay', 'true');
                            overlay.appendChild(card);
                            document.body.appendChild(overlay);

                            // Wait for confirmation
                            window.proceedWithEntry = null;
                            window.pendingEventForPlay = ev.id; // Store event ID for play mode
                            const checkConfirm = setInterval(() => {
                                if (window.proceedWithEntry !== null || !document.body.contains(overlay)) {
                                    clearInterval(checkConfirm);
                                    if (document.body.contains(overlay)) {
                                        overlay.remove();
                                    }

                                    if (window.proceedWithEntry) {
                                        const playAfterEntry = (window.proceedWithEntry === 'play');
                                        const eventIdToPlay = window.pendingEventForPlay;
                                        window.proceedWithEntry = null;
                                        window.pendingEventForPlay = null;

                                        const targetSize = ev.players || Tournament.config.playerCount || Tournament.state.selectedPlayerIndices.size;
                                        if (Tournament.state.selectedPlayerIndices.size > targetSize) {
                                            const overflow = Tournament.state.selectedPlayerIndices.size - targetSize;
                                            const toTrim = Array.from(Tournament.state.selectedPlayerIndices).filter(i => i !== playerIdx).slice(0, overflow);
                                            toTrim.forEach(i => Tournament.state.selectedPlayerIndices.delete(i));
                                        }

                                        // Actually deduct money and apply travel fatigue using EntrySystem
                                        if (typeof EntrySystem !== 'undefined' && EntrySystem.enterEvent) {
                                            const result = EntrySystem.enterEvent(ev, enrichedPlayer);
                                            if (result.success) {
                                                console.log(`[Career] ${result.message}`);
                                                // Update career balance after entry
                                                Season.state.career.balance = enrichedPlayer.money;

                                                // If user clicked "CONFIRM & PLAY", start the event
                                                if (playAfterEntry && eventIdToPlay) {
                                                    setTimeout(() => {
                                                        console.log(`[Career] Starting event ${eventIdToPlay} in play mode`);
                                                        Season.startCareerEvent(eventIdToPlay, 'play');
                                                    }, 800);
                                                }
                                            }
                                        }
                                    }
                                }
                            }, 100);
                        } else {
                            // Fallback if EntrySystem not available
                            const targetSize = ev.players || Tournament.config.playerCount || Tournament.state.selectedPlayerIndices.size;
                            if (Tournament.state.selectedPlayerIndices.size > targetSize) {
                                const overflow = Tournament.state.selectedPlayerIndices.size - targetSize;
                                const toTrim = Array.from(Tournament.state.selectedPlayerIndices).filter(i => i !== playerIdx).slice(0, overflow);
                                toTrim.forEach(i => Tournament.state.selectedPlayerIndices.delete(i));
                            }
                        }
                    } else {
                        // Player not eligible but still in bracket (sim/watch mode)
                        console.log(`[Career] Player included in ${ev.name} bracket (sim/watch mode)`);
                    }
                } else {
                    // SIM/WATCH mode - player not eligible but still allow spectating
                    // Only show alert if trying to PLAY and not eligible
                    const policy = Season.pendingEventPolicy || {};
                    if (policy.action === 'play' && typeof EntrySystem !== 'undefined' && EntrySystem.canEnterEvent) {
                        const check = EntrySystem.canEnterEvent(ev, enrichedPlayer);

                        let message = `‚ùå Cannot enter ${ev.name}\n\n`;

                        if (!check.canAfford && check.cost > 0) {
                            message += `You don't have enough money\n\n`;
                            message += `Required: ¬£${check.cost.toLocaleString()}\n`;
                            message += `Your Balance: ¬£${player.money.toLocaleString()}\n`;
                            message += `Short by: ¬£${(check.cost - player.money).toLocaleString()}`;
                        } else if (check.reason?.includes('Fatigue')) {
                            message += `Your fatigue is too high (${player.fatigue.toFixed(1)}%)\n\n`;
                            message += `You must rest before entering more events`;
                        } else {
                            message += `You are not eligible for this event\n\n`;
                            message += `Reason: ${check.reason}`;
                        }

                        alert(message);
                        console.log(`[Career] Cannot enter ${ev.name} - ${message}`);
                    } else {
                        // SIM/WATCH mode - silently spectate
                        console.log(`[Career] Spectating ${ev.name} - player not eligible but watching`);
                    }

                    // Don't add player to event
                    Tournament.state.selectedPlayerIndices.delete(playerIdx);
                }

                Season.state.career.activeEventParticipating = Tournament.state.selectedPlayerIndices.has(playerIdx);
                Season.pendingEventPolicy = null;
            },

            findPlayerInBracket: () => {
                const player = Season.getCareerPlayer();
                if (!player) return;

                const playerName = player.name;
                let foundMatch = null;

                // Check group stage first (for Grand Slam)
                if (Tournament.state.groupMatches && Tournament.state.groupMatches.length > 0) {
                    Tournament.state.groupMatches.forEach((group, gIdx) => {
                        group.forEach((m, mIdx) => {
                            if (!m || !m.p1 || !m.p2) return;
                            const hasPlayer = m.p1.name === playerName || m.p2.name === playerName;
                            if (hasPlayer && !foundMatch) {
                                foundMatch = { type: 'group', groupIdx: gIdx };
                            }
                        });
                    });
                }

                // Check bracket
                const bracketRounds = (Tournament.state.bracketData && Tournament.state.bracketData.length > 0)
                    ? Tournament.state.bracketData
                    : (Tournament.state.bracket || []);

                if (!foundMatch) {
                    bracketRounds.forEach((round, rIdx) => {
                        round.forEach((m, mIdx) => {
                            if (!m || !m.p1 || !m.p2) return;
                            const hasPlayer = m.p1.name === playerName || m.p2.name === playerName;
                            if (hasPlayer && !foundMatch) {
                                foundMatch = { type: 'bracket', roundIdx: rIdx, matchIdx: mIdx };
                            }
                        });
                    });
                }

                if (foundMatch) {
                    if (foundMatch.type === 'bracket') {
                        // Find and scroll to the match element
                        const matchElement = document.getElementById(`bm-${foundMatch.roundIdx}-${foundMatch.matchIdx}`);
                        if (matchElement) {
                            matchElement.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });

                            // Add a temporary highlight pulse
                            matchElement.style.boxShadow = '0 0 20px 4px rgba(52, 152, 219, 0.8)';
                            setTimeout(() => {
                                matchElement.style.boxShadow = '';
                            }, 2000);
                        }
                    } else if (foundMatch.type === 'group') {
                        // Scroll to group stage view
                        const bracket = document.getElementById('tourn-bracket');
                        if (bracket && bracket.firstChild) {
                            bracket.firstChild.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                    }
                }
            },

            updateCareerMatchBanner: () => {
                const banner = document.getElementById('career-match-banner');
                if (!banner) return;
                const player = Season.getCareerPlayer();
                if (!player || !Tournament.state.active || !Season.state.career.activeEventId) {
                    banner.style.display = 'none';
                    return;
                }

                if (!Season.state.career.activeEventParticipating) {
                    // Player is watching but not in the event
                    const title = document.getElementById('career-match-title');
                    const status = document.getElementById('career-match-status');
                    const action = document.getElementById('career-match-action');
                    banner.style.display = 'flex';
                    if (title) title.innerText = player.name;
                    if (status) status.innerText = 'You are not in the event';
                    if (action) action.innerHTML = '';
                    return;
                }

                const playerName = player.name;
                let foundUpcoming = null;
                let isChampion = false;

                if (Tournament.config.isGroupStage && Tournament.state.groupMatches && Tournament.state.groupMatches.length > 0) {
                    Tournament.state.groupMatches.forEach((group, gIdx) => {
                        group.forEach((m, mIdx) => {
                            if (!m || !m.p1 || !m.p2 || m.winner) return;
                            const hasPlayer = m.p1.name === playerName || m.p2.name === playerName;
                            if (hasPlayer && !foundUpcoming) {
                                const opponent = m.p1.name === playerName ? m.p2.name : m.p1.name;
                                foundUpcoming = { opponent, matchIdx: mIdx, roundIdx: 0, groupIdx: gIdx };
                            }
                        });
                    });
                }

                const bracketRounds = (Tournament.state.bracketData && Tournament.state.bracketData.length > 0)
                    ? Tournament.state.bracketData
                    : (Tournament.state.bracket || []);

                bracketRounds.forEach((round, rIdx) => {
                    round.forEach((m, mIdx) => {
                        if (!m || !m.p1 || !m.p2) return;
                        const hasPlayer = m.p1.name === playerName || m.p2.name === playerName;
                        if (!hasPlayer) return;
                        if (m.winner && m.winner.name === playerName && rIdx === bracketRounds.length - 1) {
                            isChampion = true;
                        }
                        if (!m.winner && rIdx >= Tournament.state.currentActiveRound && !foundUpcoming) {
                            const opponent = m.p1.name === playerName ? m.p2.name : m.p1.name;
                            foundUpcoming = { opponent, matchIdx: mIdx, roundIdx: rIdx };
                        }
                    });
                });

                const title = document.getElementById('career-match-title');
                const status = document.getElementById('career-match-status');
                const action = document.getElementById('career-match-action');

                if (isChampion) {
                    banner.style.display = 'flex';
                    if (title) title.innerText = `${playerName} is champion`;
                    if (status) status.innerText = 'Event complete';
                    if (action) action.innerHTML = '';
                    return;
                }

                if (foundUpcoming) {
                    banner.style.display = 'flex';
                    if (title) title.innerText = `${playerName} vs ${foundUpcoming.opponent}`;
                    if (status) status.innerText = '';
                    if (action) {
                        if (foundUpcoming.groupIdx !== undefined) {
                            action.innerHTML = `<button class="btn-play-mini" onclick="Tournament.playGrandSlamMatch(${foundUpcoming.groupIdx}, ${foundUpcoming.matchIdx})">PLAY</button>`;
                        } else {
                            action.innerHTML = `<button class="btn-play-mini" onclick="Tournament.playMatch(${foundUpcoming.matchIdx}, ${foundUpcoming.roundIdx})">PLAY</button>`;
                        }
                    }
                    return;
                }

                banner.style.display = 'flex';
                if (title) title.innerText = playerName;
                if (status) status.innerText = 'You are eliminated';
                if (action) action.innerHTML = '';
            },

            handleCareerEventCompletion: (ev) => {
                Season.ensureCareerState();
                const career = Season.state.career;
                if (!career.activeEventId || career.activeEventId !== ev.id) return;
                const wasParticipating = career.activeEventParticipating;
                career.activeEventId = null;
                career.activeEventParticipating = false;

                const player = Season.getCareerPlayer();
                const bracketRounds = (Tournament.state.bracket && Tournament.state.bracket.length > 0)
                    ? Tournament.state.bracket
                    : (Tournament.state.bracketData || []);
                const finalMatch = bracketRounds.length > 0 ? bracketRounds.at(-1)?.[0] : null;
                const winnerName = Tournament.state.winner || finalMatch?.winner?.name || null;
                const wasWinner = winnerName === player?.name;
                let result = 'ELIMINATED';
                let resultColor = '#ff6b6b';
                let matchesPlayed = 0;
                let earnings = 0;
                let points = 0;
                let stageName = '';

                // Calculate matches played and find deepest round
                let deepestRoundIdx = -1;

                if (bracketRounds && bracketRounds.length > 0) {
                    bracketRounds.forEach((round, rIdx) => {
                        round.forEach(m => {
                            if (m.p1?.name === player?.name || m.p2?.name === player?.name) {
                                if (m.winner) matchesPlayed++;
                                if (m.p1?.name === player?.name || m.p2?.name === player?.name) {
                                    deepestRoundIdx = rIdx;
                                }
                            }
                        });
                    });
                }

                if (deepestRoundIdx >= 0 && Tournament.config.rounds && Tournament.config.rounds[deepestRoundIdx]) {
                    stageName = Tournament.config.rounds[deepestRoundIdx].name;
                } else {
                    stageName = 'Round ' + Math.max(1, matchesPlayed);
                }

                if (Tournament.state.groupMatches) {
                    // Group stage logic
                    let groupMatchesPlayed = 0;
                    Tournament.state.groupMatches.forEach(group => {
                        group.forEach(m => {
                            if ((m.p1?.name === player?.name || m.p2?.name === player?.name) && m.winner) {
                                groupMatchesPlayed++;
                                matchesPlayed++;
                            }
                        });
                    });

                    // If eliminated in group stage
                    if (deepestRoundIdx === -1 && groupMatchesPlayed > 0) {
                        stageName = "Group Stage";
                    }
                }

                if (wasWinner) {
                    result = 'üèÜ CHAMPION';
                    resultColor = '#ffd700';
                    stageName = "Winner";
                    if (matchesPlayed === 0) matchesPlayed = 1;
                } else if (!wasParticipating) {
                    // Player didn't participate
                    result = 'DID NOT TAKE PART';
                    resultColor = '#888888';
                    stageName = "Spectator";
                }

                // Calculate Earnings / Points
                if (ev.type === 'q-school') {
                    // Q-School: Points for wins
                    // 1 point per win, +1 if qualified (Winner)
                    let wins = matchesPlayed - (wasWinner ? 0 : 1);
                    if (wasWinner) wins = matchesPlayed; // Won all
                    // Assume 1 pt per win
                    points = Math.max(0, wins);
                    if (wasWinner) points += 1; // Bonus for winning card?
                } else {
                    // Money events
                    try {
                        let structure;
                        if (ev.prizes && typeof ev.prizes === 'object' && Object.keys(ev.prizes).length > 0) {
                            structure = {};
                            const positionMap = { 'W': 1, '1': 1, 'RU': 2, '2': 2, 'SF': 4, '4': 4, 'QF': 8, '8': 8, 'L16': 16, '16': 16, 'L32': 32, '32': 32, 'L64': 64, '64': 64, 'L128': 128, '128': 128, 'L256': 256, '256': 256 };
                            for (const [pos, amount] of Object.entries(ev.prizes)) {
                                const key = positionMap[pos] || parseInt(pos);
                                if (key) structure[key] = amount;
                            }
                        } else if (typeof PRIZE_STRUCTURE !== 'undefined') {
                            structure = PRIZE_STRUCTURE[ev.type] || PRIZE_STRUCTURE['minor'];
                        }

                        if (structure) {
                            if (wasWinner) {
                                earnings = structure[1] || 0; // Winner prize (position 1)
                            } else {
                                // Find prize for elimination round
                                // Usually structure key is "Number of players in that round" (e.g. 4 for SF)
                                // Or we can map stageName
                                // Let's use `deepestRoundIdx` logic if available
                                if (deepestRoundIdx >= 0 && bracketRounds && bracketRounds.length > 0) {
                                    // Identify how many players in this round
                                    const playersInRound = bracketRounds[deepestRoundIdx].length * 2;
                                    earnings = structure[playersInRound] || 0;
                                } else if (stageName === "Group Stage") {
                                    earnings = structure['group'] || structure[32] || 0; // Fallback
                                }
                            }
                        }
                    } catch (e) {
                        console.warn('Error calculating earnings:', e);
                    }
                }

                // Show event summary animation
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0; left: 0; right: 0; bottom: 0;
                    background: linear-gradient(135deg, rgba(20,20,40,0.95) 0%, rgba(30,15,50,0.95) 100%);
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                    animation: fadeInSummary 0.5s ease-out;
                `;

                let rewardHTML = '';
                if (!wasParticipating && !wasWinner) {
                    // Didn't participate - show no rewards
                    rewardHTML = `
                        <div style="margin-top: 10px; font-size: 24px;">Spectator - No rewards earned</div>
                    `;
                } else if (points > 0 || ev.type === 'q-school') {
                    rewardHTML = `
                        <div style="margin-top: 10px; font-size: 24px;">Points: <span style="color: var(--pdc-gold)">${points}</span></div>
                    `;
                } else {
                    rewardHTML = `
                        <div style="margin-top: 10px; font-size: 24px;">Prize: <span style="color: var(--pdc-gold)">¬£${earnings.toLocaleString()}</span></div>
                    `;
                }

                overlay.innerHTML = `
                    <div style="text-align: center; animation: slideUp 0.8s ease-out;">
                        <div style="font-size: 18px; color: #999; margin-bottom: 20px;">EVENT SUMMARY</div>
                        <div style="font-size: 36px; font-weight: bold; color: #fff; margin-bottom: 5px;">${ev.name}</div>
                        <div style="font-size: 18px; color: #aaa; margin-bottom: 25px; text-transform: uppercase; letter-spacing: 2px;">${stageName}</div>
                        
                        <div style="font-size: 60px; font-weight: bold; color: ${resultColor}; text-shadow: 0 0 20px ${resultColor}; margin: 20px 0; animation: scaleIn 0.6s ease-out 0.3s both;">${result}</div>
                        
                        <div style="font-size: 20px; color: #ddd; margin-top: 30px; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1);">
                            ${rewardHTML}
                            <div style="margin-top: 10px;">Matches Played: <span style="color: var(--pdc-gold)">${matchesPlayed}</span></div>
                            <div style="margin-top: 10px;">Fatigue: <span style="color: var(--pdc-gold)">${player?.fatigue?.toFixed(1)}%</span></div>
                        </div>
                        <div style="margin-top: 40px; font-size: 14px; color: #666;">Click anywhere to continue...</div>
                    </div>
                    <style>
                        @keyframes fadeInSummary {
                            from { opacity: 0; }
                            to { opacity: 1; }
                        }
                        @keyframes slideUp {
                            from { opacity: 0; transform: translateY(40px); }
                            to { opacity: 1; transform: translateY(0); }
                        }
                        @keyframes scaleIn {
                            from { opacity: 0; transform: scale(0.8); }
                            to { opacity: 1; transform: scale(1); }
                        }
                    </style>
                `;

                document.body.appendChild(overlay);

                overlay.addEventListener('click', () => {
                    overlay.style.opacity = '0';
                    overlay.style.transition = 'opacity 0.3s ease-out';
                    setTimeout(() => document.body.removeChild(overlay), 300);
                });

                // Auto-dismiss after 8 seconds
                setTimeout(() => {
                    if (document.body.contains(overlay)) {
                        overlay.style.opacity = '0';
                        overlay.style.transition = 'opacity 0.3s ease-out';
                        setTimeout(() => {
                            if (document.body.contains(overlay)) {
                                document.body.removeChild(overlay);
                            }
                        }, 300);
                    }
                }, 8000);

                // Apply event fatigue after completion
                if (player && typeof FatigueSystem !== 'undefined' && FatigueSystem.applyEventFatigue) {
                    FatigueSystem.applyEventFatigue(player, ev, matchesPlayed);
                    console.log(`[Career] Event fatigue applied. Player fatigue: ${player.fatigue.toFixed(1)}`);
                }

                // Add money to balance if applicable
                if (earnings > 0 && player) {
                    // Update career balance
                    if (typeof Season.state.career.balance !== 'undefined') {
                        Season.state.career.balance += earnings;
                    }
                    // Also update player money (for display compatibility)
                    if (player.money !== undefined) {
                        player.money += earnings;
                    }
                }

                const completedEvent = {
                    id: ev.id,
                    name: ev.name,
                    date: career.currentDate,
                    type: ev.type,
                    result: wasWinner ? 'WON' : stageName,
                    earnings: earnings,
                    points: points
                };
                if (!career.completedEvents) career.completedEvents = [];
                career.completedEvents.push(completedEvent);

                Persistence.save();

                // Only advance to next day if all events for today are completed
                const dateObj = Season.getCareerDateObj();
                const eventsToday = Season.getEventsForDate(dateObj);
                const completedIds = new Set(career.completedEvents.map(c => c.id));
                const allEventsCompletedToday = eventsToday.every(ev => completedIds.has(ev.id));

                if (allEventsCompletedToday && eventsToday.length > 0) {
                    // All events for today are done, advance to next day
                    Season.advanceCareerDate(1);
                    console.log(`[Career] All events completed for today. Advancing to next day.`);
                }

                // Refresh UI to show updated date and stats
                Season.renderCareerHub();
            },

            /**
             * Enter a career event - deduct money, apply travel fatigue, update location
             * Call this BEFORE starting the tournament
             */
            enterCareerEvent: (ev) => {
                const player = Season.getCareerPlayer();
                if (!player) {
                    console.error('[Career] No career player found');
                    return false;
                }

                // Use EntrySystem to handle entry
                if (typeof EntrySystem !== 'undefined' && EntrySystem.enterEvent) {
                    const result = EntrySystem.enterEvent(ev, player);
                    if (!result.success) {
                        alert(`Cannot enter event: ${result.message}`);
                        return false;
                    }
                    console.log(`[Career] Entry processed: ${result.message}`);
                }

                // Mark event as active
                Season.state.career.activeEventId = ev.id;
                Season.state.career.activeEventParticipating = true;

                // Render updated UI
                Season.renderCareerHub();
                Persistence.save();

                return true;
            },

            /**
             * Rest action - reduces fatigue but causes rust
             */
            performCareerRest: (lightTraining = false) => {
                Season.ensureCareerState();
                const player = Season.getCareerPlayer();
                const todayDate = Season.state.career.currentDate;
                const lastWorkDate = Season.state.career.lastWorkDate;

                if (!player) return;

                // Check if worked today (can't train on work days)
                if (lightTraining && lastWorkDate === todayDate) {
                    alert('You cannot train on a day you worked! You must choose one or the other.');
                    return;
                }

                if (typeof RestSystem !== 'undefined' && RestSystem.applyRest) {
                    const result = RestSystem.applyRest(player, 1, lightTraining);
                    const action = lightTraining ? 'Light Training' : 'Full Rest';
                    alert(`${action} completed!\n\nFatigue: ${result.newFatigue}\nAverage: ${result.newAvg} (-${result.avgLoss})\nCheckout: ${result.newCo}% (-${result.coLoss}%)`);
                } else {
                    // Fallback
                    player.fatigue = Math.max(0, player.fatigue - 20);
                    alert(`Rest completed! Fatigue reduced to ${player.fatigue.toFixed(1)}`);
                }

                // Mark training date if doing light training
                if (lightTraining) {
                    Season.state.career.lastTrainDate = todayDate;
                }

                Season.advanceCareerDate(1);
                Season.state.career.lastAction = lightTraining ? 'light-train' : 'rest';
                Season.state.career.lastActionDate = Season.state.career.currentDate;
                Season.renderCareerHub();
                Persistence.save();
            },

            /**
             * Training action - improves skills slowly, minimal fatigue reduction
             */
            performCareerTraining: () => {
                const player = Season.getCareerPlayer();
                if (!player) return;

                // Training improves stats slightly
                player.avg = Math.min(player.avg + 0.3, 120);
                player.co = Math.min(player.co + 0.4, 65);
                player.fatigue = Math.max(0, player.fatigue - 5); // Small fatigue reduction

                alert(`Training completed!\n\nAverage: ${player.avg.toFixed(1)} (+0.3)\nCheckout: ${player.co.toFixed(1)}% (+0.4)\nFatigue: ${player.fatigue.toFixed(1)}`);

                Season.advanceCareerDate(1);
                Season.state.career.lastAction = 'training';
                Season.state.career.lastActionDate = Season.state.career.currentDate;
                Season.renderCareerHub();
                Persistence.save();
            },

            /**
             * Get detailed event entry information with costs
             * @param {object} ev - Event object
             * @returns {string} Formatted string with event location and entry details
             */
            getEventEntryDetails: (ev) => {
                const player = Season.getCareerPlayer();
                if (!player || !ev) return 'No event data';

                const location = TravelSystem.resolveEventLocation(ev);
                const costData = EntrySystem.calculateEntryCost(ev, player);
                const check = EntrySystem.canEnterEvent(ev, player);

                let details = `üìç ${location.venueName}\n${location.city}, ${location.country} (${location.region.toUpperCase()})\n\n`;

                details += `üí∞ COSTS:\n`;
                details += `Entry Fee: ¬£${costData.entryFee}\n`;

                if (costData.travelCost > 0) {
                    details += `Travel: ¬£${costData.travelCost}\n`;
                    details += `Fatigue Impact: +${costData.fatigueFromTravel}\n`;
                } else {
                    details += `Travel: None (already in region)\n`;
                }

                details += `TOTAL: ¬£${costData.totalCost}\n\n`;

                details += `üíµ Your Balance: ¬£${player.money.toLocaleString()}\n`;
                details += `üòì Your Fatigue: ${player.fatigue.toFixed(1)}%\n`;
                details += `üìç Current Location: ${player.currentRegion.toUpperCase()}\n\n`;

                if (check.canEnter) {
                    details += `‚úÖ You can enter this event`;
                } else {
                    details += `‚ùå Cannot enter: ${check.reason}`;
                }

                return details;
            },

            /**
             * Show event entry dialogue with detailed information
             */
            showEventEntryDialog: (ev) => {
                const details = Season.getEventEntryDetails(ev);
                alert(details);
            },

            init: () => {
                // Load events from defaults if not already loaded from DB
                if (Season.events.length === 0) {
                    Season.events = [...Season.defaultEvents];
                    console.log('[Season.init] Using default events:', Season.events.length);
                }

                // Enrich events with venues and entry fees
                if (typeof EventEnrichment !== 'undefined' && EventEnrichment.enrichAllEvents) {
                    Season.events = EventEnrichment.enrichAllEvents(Season.events);
                    console.log('[Season.init] Events enriched with venues and entry fees');
                }

                // Initialize main OOM with only tour card holders
                if (Object.keys(Season.state.orderOfMerit).length === 0) {
                    PLAYERS_DB.forEach(p => {
                        if (p.tourCard) {
                            Season.state.orderOfMerit[p.name] = p.money || 0;
                        }
                    });
                }

                // Initialize subsystems
                if (typeof PlayerState !== 'undefined' && PlayerState.initPlayers) {
                    PlayerState.initPlayers();
                }
                if (typeof NewsSystem !== 'undefined' && NewsSystem.init) {
                    NewsSystem.init();
                }

                if (!Season.state.proTourOOM) Season.state.proTourOOM = {};
                if (!Season.state.challengeTourOOM) Season.state.challengeTourOOM = {};
                if (!Season.state.worldSeriesOOM) Season.state.worldSeriesOOM = {};
                if (!Season.state.wcQualified) Season.state.wcQualified = { qualifiers: new Set(), internationalQualifiers: [] };
                if (!Season.state.wcQualified.internationalQualifiers) Season.state.wcQualified.internationalQualifiers = [];
                if (!Season.state.qSchool) {
                    Season.state.qSchool = {
                        ukOOM: {}, euOOM: {}, ukFinalStageQualified: [], euFinalStageQualified: [],
                        ukParticipants: [], euParticipants: [], ukTourCardWinners: [], euTourCardWinners: [],
                        ukFinalStageWinners: [], euFinalStageWinners: [],
                        ukTourCards: 0, euTourCards: 0
                    };
                } else {
                    // Ensure all arrays exist for saved games
                    if (!Season.state.qSchool.ukFinalStageWinners) Season.state.qSchool.ukFinalStageWinners = [];
                    if (!Season.state.qSchool.euFinalStageWinners) Season.state.qSchool.euFinalStageWinners = [];
                    if (!Season.state.qSchool.ukFinalStageQualified) Season.state.qSchool.ukFinalStageQualified = [];
                    if (!Season.state.qSchool.euFinalStageQualified) Season.state.qSchool.euFinalStageQualified = [];
                    if (!Season.state.qSchool.ukParticipants) Season.state.qSchool.ukParticipants = [];
                    if (!Season.state.qSchool.euParticipants) Season.state.qSchool.euParticipants = [];
                    if (!Season.state.qSchool.ukTourCardWinners) Season.state.qSchool.ukTourCardWinners = [];
                    if (!Season.state.qSchool.euTourCardWinners) Season.state.qSchool.euTourCardWinners = [];
                }

                Season.ensureCareerState();

                // Ensure season events are ordered by calendar date
                const year = Season.state.year || 2026;
                Season.events.sort((a, b) => {
                    const da = new Date(`${year} ${a.date}`);
                    const db = new Date(`${year} ${b.date}`);
                    return da - db;
                });

                Season.renderUI();
                Season.renderCareerHub();
            },

            reset: async () => {
                // Different confirmation based on login status
                const isLoggedIn = !!AuthSystem.currentUser;
                const confirmMsg = isLoggedIn
                    ? "Reset Career Mode completely? This will also delete your cloud save."
                    : "Reset Career Mode completely?";

                if (!confirm(confirmMsg)) return;

                // If logged in, clear server save FIRST and wait for it to complete
                if (isLoggedIn) {
                    try {
                        await AuthSystem.apiCall('/save', 'POST', { data: null });
                        console.log('Cloud save deleted');
                    } catch (e) {
                        console.log('Could not clear cloud save:', e);
                    }
                }

                // Clear ALL game-related localStorage items
                localStorage.removeItem('pdc_news');
                localStorage.removeItem('pdc_player_states');
                localStorage.removeItem('pdc_tourn_state');
                localStorage.removeItem('pdc_tourn_config');
                localStorage.removeItem('pdc_season');
                localStorage.removeItem('pdc_players');
                localStorage.removeItem('pdc_match_state');
                localStorage.removeItem('pdc_app_config');
                localStorage.removeItem('pdc_active_screen');
                localStorage.removeItem('pdc_code_hash');
                localStorage.removeItem('pdc_custom_players');

                // Remove custom players from the in-memory DB
                PLAYERS_DB = PLAYERS_DB.filter(p => !p.isCustom);

                NewsSystem.items = [];

                Season.state = {
                    activeEventIndex: 0,
                    orderOfMerit: {},
                    completedEvents: [],
                    inProgress: false,
                    year: 2026,
                    proTourOOM: {},
                    proTourHistory: [],
                    challengeTourOOM: {},
                    challengeTourHistory: [],
                    worldSeriesOOM: {},
                    worldSeriesHistory: [],
                    activeOOMView: "main",
                    wcQualified: { qualifiers: new Set(), internationalQualifiers: [] },
                    qSchool: {
                        ukOOM: {}, euOOM: {}, ukFinalStageQualified: [], euFinalStageQualified: [],
                        ukParticipants: [], euParticipants: [], ukTourCardWinners: [], euTourCardWinners: [],
                        ukTourCards: 0, euTourCards: 0
                    },
                    premierLeague: {
                        year: 2026,
                        players: ["Luke Littler", "Luke Humphries", "Gian van Veen", "Michael van Gerwen", "Jonny Clayton", "Stephen Bunting", "Josh Rock", "Gerwyn Price"],
                        standings: {},
                        matchResults: [],
                        currentNight: 0,
                        playoffQualifiers: []
                    },
                    career: {
                        currentDate: null,
                        playerName: "",
                        playerType: "",
                        playerMeta: {},
                        trainingStreak: 0,
                        missedCompetitiveDays: 0,
                        lastActionDate: "",
                        lastAction: "",
                        dayChoices: {},
                        customPlayers: [],
                        activeEventId: null,
                        activeEventParticipating: false,
                        autoSimDay: null,
                        autoSimExcludeId: null,
                        intelTab: "news",
                        standingsTab: "oom",
                        qschoolTab: "uk"
                    },
                    ukOpenQualifiers: [],
                    winmauQualifiers: [],
                    etQualifiers: {}
                };

                // Reset Tournament state
                Tournament.state = {
                    active: false,
                    bracketData: [],
                    currentActiveRound: 0,
                    viewingRound: 0,
                    selectedPlayerIndices: new Set(),
                    matchQueue: []
                };

                // Reinitialize season (this also sets up OOM from fresh PLAYERS_DB)
                Season.init();
                Persistence.save();

                // Save the fresh state to cloud if logged in (and wait for it)
                if (isLoggedIn) {
                    try {
                        await AuthSystem.saveToCloud();
                        console.log('Fresh season saved to cloud');
                    } catch (e) {
                        console.log('Could not save fresh season to cloud:', e);
                    }
                }

                // Switch to season tab and show success message (no reload needed)
                App.switchTab('season');
                Season.renderUI();
                alert("Career Mode has been reset!");
            },

            closeEventInfo: () => {
                const modal = document.getElementById('event-info-modal');
                modal.classList.remove('active');
                setTimeout(() => { modal.style.display = 'none'; }, 300);
            },

            showEventInfo: (idx) => {
                const ev = Season.events[idx];
                const completed = Season.state.completedEvents.find(c => c.id === ev.id);
                const isFutureEvent = idx > Season.state.activeEventIndex;
                const isCurrentEvent = idx === Season.state.activeEventIndex;

                document.getElementById('info-header').innerText = ev.name;

                let details = `
                    <p><span>Date:</span> <strong>${ev.date}</strong></p>
                    <p><span>Type:</span> <strong>${ev.type.toUpperCase().replace(/-/g, ' ')}</strong></p>
                    <p><span>Format:</span> <strong>${ev.format.toUpperCase()}</strong></p>
                    <p><span>Players:</span> <strong>${ev.players}</strong></p>
                `;

                if (ev.location) {
                    details += `<p><span>Location:</span> <strong>${ev.location.toUpperCase()}</strong></p>`;
                }

                document.getElementById('info-details').innerHTML = details;

                const resultsDiv = document.getElementById('info-results');
                if (completed) {
                    let resHtml = `
                        <div class="event-info-results">
                            <h3>Results</h3>
                            <p style="color:var(--pdc-gold); font-size:16px; justify-content:center; text-align:center;">üèÜ ${completed.winner} wins!</p>
                    `;

                    // Show extra info based on event type
                    if (ev.type === 'premier-league') {
                        // Maybe show night winner? already shown.
                    }

                    resHtml += `</div>`;
                    resultsDiv.innerHTML = resHtml;
                } else if (isFutureEvent) {
                    // Show "Simulate to this Event" button for future events
                    resultsDiv.innerHTML = `
                        <div style="text-align:center; margin-top:15px;">
                            <div style="color:#888; margin-bottom:15px;">Event has not started yet</div>
                            <button class="btn-sim" style="padding:12px 24px; font-size:14px;" onclick="Season.closeEventInfo(); Season.simulateToEvent(${idx})">
                                ‚ö° SIMULATE TO THIS EVENT
                            </button>
                        </div>
                    `;
                } else if (isCurrentEvent) {
                    resultsDiv.innerHTML = `<div style="text-align:center; color:var(--pdc-gold); margin-top:15px;">This is the current event</div>`;
                } else {
                    resultsDiv.innerHTML = `<div style="text-align:center; color:#888; margin-top:15px;">Event has not started yet</div>`;
                }

                const modal = document.getElementById('event-info-modal');
                modal.style.display = 'flex';
                // Small delay to allow display flex to apply before opacity transition
                setTimeout(() => { modal.classList.add('active'); }, 10);

                // Close on background click
                modal.onclick = (e) => {
                    if (e.target === modal) Season.closeEventInfo();
                };
            },

            renderUI: () => {
                const stack = new Error().stack.split('\n')[2];
                console.log(`[renderUI CALLED] from: ${stack}`);

                Season.renderCareerHub();

                // ============================
                // 1Ô∏è‚É£ OOM TAB NAVIGATION
                // ============================
                const btns = document.querySelectorAll('.oom-nav-btn');
                btns.forEach(b => b.classList.remove('active'));

                const btnMain = document.getElementById("btn-main-oom");
                const btnPro = document.getElementById("btn-protour-oom");
                const btnChallenge = document.getElementById("btn-challenge-oom");
                const btnWs = document.getElementById("btn-ws-oom");

                if (Season.state.activeOOMView === "pro" && btnPro) btnPro.classList.add('active');
                else if (Season.state.activeOOMView === "challenge" && btnChallenge) btnChallenge.classList.add('active');
                else if (Season.state.activeOOMView === "worldseries" && btnWs) btnWs.classList.add('active');
                else if (btnMain) btnMain.classList.add('active');

                // ============================
                // 2Ô∏è‚É£ EVENT LISTA
                // ============================
                const list = document.getElementById('season-event-list');
                if (!list) return; // Career tab not yet visible
                list.innerHTML = '';
                const yearDisp = document.getElementById('season-year-disp');
                if (yearDisp) yearDisp.innerText = Season.state.year;

                const allDone = Season.state.activeEventIndex >= Season.events.length;
                const seasonControls = document.getElementById('season-controls');
                if (seasonControls) {
                    if (allDone) {
                        seasonControls.innerHTML = `
                            <button class="btn-gold" onclick="Season.startNewYear()">START SEASON ${Season.state.year + 1}</button>
                            <button class="btn-gold" style="background:#9a0000; margin-top:10px;" onclick="Season.reset()">RESET CAREER</button>
                        `;
                    } else {
                        seasonControls.innerHTML = `
                            <button class="btn-sim" style="width:100%; padding:15px;" onclick="Season.simulateRemainingSeason()">‚ö° SIMULATE REMAINING SEASON</button>
                            <button class="btn-gold" style="background:#9a0000;" onclick="Season.reset()">RESET CAREER</button>
                        `;
                    }
                }


                Season.events.forEach((ev, idx) => {
                    const isActive = idx === Season.state.activeEventIndex;
                    const isDone = idx < Season.state.activeEventIndex;
                    const completedData = Season.state.completedEvents.find(c => c.id === ev.id);

                    let statusClass = isActive ? 'active' : (isDone ? 'completed' : '');
                    let action = '';

                    // Determine if this event is on the current career day
                    const year = Season.state.year || 2026;
                    const evDate = new Date(`${year} ${ev.date}`);
                    const currentDateObj = Season.getCareerDateObj();
                    const isEventToday = currentDateObj &&
                        evDate.getMonth() === currentDateObj.getMonth() &&
                        evDate.getDate() === currentDateObj.getDate();

                    // Event logo mapping
                    let logoHTML = '';
                    if (ev.name === 'MATCHPLAY') {
                        logoHTML = '<img class="season-event-logo" src="worldmatchplay.png" alt="">';

                    } else if (ev.name === 'UK OPEN') {
                        logoHTML = '<img class="season-event-logo" src="ukopen.png" alt="">';

                    } else if (ev.name === 'PLAYERS CHAMPIONSHIP FINALS') {
                        logoHTML = '<img class="season-event-logo" src="playersc.png" alt="">';

                    } else if (ev.name === 'GRAND SLAM OF DARTS') {
                        logoHTML = '<img class="season-event-logo" src="mrvegas.png" alt="">';

                    } else if (ev.name === 'WORLD SERIES OF DARTS FINALS') {
                        logoHTML = '<img class="season-event-logo" src="worldseries.png" alt="">';

                    } else if (ev.name === 'WORLD CHAMPIONSHIP') {
                        logoHTML = '<img class="season-event-logo" src="worldchampionship.png" alt="">';

                    } else if (ev.name === 'WINMAU WORLD MASTERS') {
                        logoHTML = '<img class="season-event-logo" src="worldmasters.png" alt="">';

                    } else if (ev.name.includes('WORLD GRAND PRIX')) {
                        logoHTML = '<img class="season-event-logo" src="grandprix.png" alt="">';

                    } else if (ev.name.includes('MACHINESEEKER EUROPEAN CHAMPIONSHIP')) {
                        logoHTML = '<img class="season-event-logo" src="europeanchampionship.png" alt="">';

                    } else if (ev.type && (ev.type.includes('qual') || ev.type.includes('host-nation') || ev.type.includes('east-european') || ev.type.includes('nordic-baltic'))) {
                        logoHTML = '<img class="season-event-logo" src="pdc-logo.png" alt="">';

                    } else if (ev.type === 'players') {
                        logoHTML = '<img class="season-event-logo" src="playersc.png" alt="">';

                    } else if (ev.type === 'premier-league' || ev.type === 'premier-league-playoff') {
                        logoHTML = '<img class="season-event-logo" src="premierleague.png" alt="">';

                    } else if (ev.type === 'masters') {
                        logoHTML = '<img class="season-event-logo" src="worldseries.png" alt="">';

                    } else if (ev.type === 'minor') {
                        logoHTML = '<img class="season-event-logo" src="pdc-logo.png" alt="">';

                    } else if (ev.type === 'q-school') {
                        logoHTML = '<img class="season-event-logo" src="pdc-logo.png" alt="">';
                    } else if (ev.type === 'challenge') {
                        logoHTML = '<img class="season-event-logo" src="pdc-logo.png" alt="">';
                    } else if (ev.type === 'pc' || ev.name.includes('PLAYERS CHAMPIONSHIP')) {
                        logoHTML = '<img class="season-event-logo" src="playersc.png" alt="">';
                    } else {
                        // Default fallback logo for any unmatched events
                        logoHTML = '<img class="season-event-logo" src="pdc-logo.png" alt="">';
                    }



                    if (isDone && completedData) {
                        action = `<span class="s-winner">üèÜ ${completedData.winner}</span>`;
                    } else if (isEventToday) {
                        action = `<span class="s-winner">TODAY</span>`;
                    } else if (!isEventToday && !isDone) {
                        // Event not yet active and not today, show locked state with day hint
                        const dayStr = ev.date;
                        action = `<span class="s-winner" style="font-size:10px; opacity:0.6;">on ${dayStr}</span>`;
                    }

                    list.innerHTML += `
                        <div class="season-event ${statusClass}" onclick="Season.showEventInfo(${idx})" style="cursor:pointer;">
                            ${logoHTML}
                            <div>
                                <div class="s-date">${ev.date}</div>
                                <div class="s-name">${ev.name}</div>
                            </div>
                            <div>${action}</div>
                        </div>
                    `;
                });
            },

            // ... (keep rest of Season methods)

            buildGrandSlamQualifiers: () => {
                const qualified = new Set();

                const add = (name) => {
                    if (name && qualified.size < 32) qualified.add(name);
                };

                // 1Ô∏è‚É£ Major gy≈ëztesek + d√∂nt≈ës√∂k
                [
                    "WORLD CHAMPIONSHIP",
                    "MATCHPLAY",
                    "GRAND PRIX",
                    "UK OPEN",
                    "EUROPEAN CHAMPIONSHIP",
                    "PLAYERS CHAMPIONSHIP FINALS",
                    "WORLD SERIES OF DARTS FINALS"
                ].forEach(eventName => {
                    const ev = Season.state.completedEvents.find(e => e.name === eventName);
                    if (ev?.winner) add(ev.winner);
                    if (ev?.runnerUp) add(ev.runnerUp);
                });

                // 2Ô∏è‚É£ Challenge Tour top 3
                Object.entries(Season.state.challengeTourOOM)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 3)
                    .forEach(e => add(e[0]));

                // 3Ô∏è‚É£ European Tour winners
                Season.events
                    .filter(e => e.type === "minor")
                    .forEach(ev => {
                        const res = Season.state.completedEvents.find(c => c.id === ev.id);
                        if (res?.winner) add(res.winner);
                    });

                // 4Ô∏è‚É£ Players Championship winners
                Season.events
                    .filter(e => e.type === "players")
                    .forEach(ev => {
                        const res = Season.state.completedEvents.find(c => c.id === ev.id);
                        if (res?.winner) add(res.winner);
                    });

                // 5Ô∏è‚É£ Tour Card qualifier (OOM top TC)
                Object.entries(Season.state.orderOfMerit)
                    .filter(([n]) => PLAYERS_DB.find(p => p.name === n)?.tourCard)
                    .sort((a, b) => b[1] - a[1])
                    .forEach(e => add(e[0]));

                return [...qualified];
            },

            buildWorldChampionshipQualifiers: () => {
                const qualified = new Set();
                const add = (name) => {
                    if (name && qualified.size < 128) qualified.add(name);
                };

                // 1Ô∏è‚É£ Top 40 from Main OOM (Tour Card holders)
                Object.entries(Season.state.orderOfMerit)
                    .filter(([n]) => PLAYERS_DB.find(p => p.name === n)?.tourCard)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 40)
                    .forEach(e => add(e[0]));

                // 2Ô∏è‚É£ Top 40 from Pro Tour OOM
                Object.entries(Season.state.proTourOOM)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 40)
                    .forEach(e => {
                        if (!qualified.has(e[0])) add(e[0]);
                    });

                // 3Ô∏è‚É£ International qualifiers (winners from various regional tours)
                if (Season.state.wcQualified?.internationalQualifiers) {
                    Season.state.wcQualified.internationalQualifiers.forEach(name => add(name));
                }

                // 4Ô∏è‚É£ Q-SCHOOL qualifiers (top performers from Q-SCHOOL)
                if (Season.state.qSchool?.ukFinalStageQualified) {
                    Season.state.qSchool.ukFinalStageQualified.forEach(name => add(name));
                }
                if (Season.state.qSchool?.euFinalStageQualified) {
                    Season.state.qSchool.euFinalStageQualified.forEach(name => add(name));
                }

                // 5Ô∏è‚É£ Challenge Tour qualifiers (winners and top performers)
                Object.entries(Season.state.challengeTourOOM)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 3)
                    .forEach(e => {
                        if (!qualified.has(e[0])) add(e[0]);
                    });

                // 6Ô∏è‚É£ World Series winners/runners-up
                Object.entries(Season.state.worldSeriesOOM)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 5)
                    .forEach(e => {
                        if (!qualified.has(e[0])) add(e[0]);
                    });

                // 7Ô∏è‚É£ Fill remaining spots directly from main Order of Merit (descending)
                if (qualified.size < 128) {
                    Object.entries(Season.state.orderOfMerit)
                        .sort((a, b) => b[1] - a[1])
                        .forEach(e => {
                            if (qualified.size < 128) add(e[0]);
                        });
                }

                // Fallback: If we don't have 128 players yet, add top tour card holders by average
                if (qualified.size < 128) {
                    const needed = 128 - qualified.size;
                    PLAYERS_DB
                        .filter(p => p.tourCard && !qualified.has(p.name))
                        .sort((a, b) => (b.avg || 0) - (a.avg || 0))
                        .slice(0, needed)
                        .forEach(p => qualified.add(p.name));
                }

                console.log("World Championship Qualifiers:", qualified.size, [...qualified]);
                return [...qualified];
            },

            simulateUKOpenQuali: () => {

                // --- j√°t√©kosok kiv√°laszt√°sa ---
                let selected = new Set();

                // Challenge Tour top 32
                Object.entries(Season.state.challengeTourOOM)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 32)
                    .forEach(e => selected.add(e[0]));

                // Tour Card OOM 97‚Äì128
                Object.entries(Season.state.orderOfMerit)
                    .sort((a, b) => b[1] - a[1])
                    .slice(96, 128)
                    .forEach(e => selected.add(e[0]));

                // safety fill
                const pool = PLAYERS_DB
                    .map(p => p.name)
                    .filter(n => !selected.has(n));

                while (selected.size < 64) {
                    selected.add(pool[Math.floor(Math.random() * pool.length)]);
                }

                // --- szimul√°ci√≥ (egyszer≈±, gyors) ---
                const players = [...selected];

                // top32 = random fele tov√°bbjut (mint els≈ë k√∂r)
                const qualified = players
                    .sort(() => Math.random() - 0.5)
                    .slice(0, 32);

                Season.state.ukOpenQualifiers = qualified;

                console.log("UK Open Qualifiers:", qualified);
            },

            simulateWinmauQuali: (targetEventId) => {
                // Winmau Darts Masters Qualifiers
                let selected = new Set();

                // Pro Tour top 24
                Object.entries(Season.state.proTourOOM)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 24)
                    .forEach(e => selected.add(e[0]));

                // Safety fill from tour card holders
                const pool = PLAYERS_DB
                    .filter(p => p.tourCard)
                    .map(p => p.name)
                    .filter(n => !selected.has(n));

                while (selected.size < 32) {
                    if (pool.length === 0) break;
                    selected.add(pool[Math.floor(Math.random() * pool.length)]);
                }

                const players = [...selected];
                // Simulate qualifiers (top 8 advance from 32)n
                const qualified = players
                    .sort(() => Math.random() - 0.5)
                    .slice(0, 8);

                Season.state.winmauQualifiers = qualified;
                if (targetEventId) {
                    if (!Season.state.wmQualifiers) Season.state.wmQualifiers = {};
                    Season.state.wmQualifiers[targetEventId] = qualified;
                }

                console.log("Winmau Qualifiers:", qualified);
            },

            startNewYear: () => {
                Season.state.year++;
                Season.state.activeEventIndex = 0;
                Season.state.completedEvents = [];
                for (let p in Season.state.orderOfMerit) {
                    Season.state.orderOfMerit[p] = Math.floor(Season.state.orderOfMerit[p] * 0.75);
                }
                Season.state.premierLeague = {
                    year: Season.state.year,
                    players: ["Luke Littler", "Luke Humphries", "Gian van Veen", "Michael van Gerwen", "Jonny Clayton", "Stephen Bunting", "Josh Rock", "Gerwyn Price"],
                    standings: {},
                    matchResults: [],
                    currentNight: 0,
                    playoffQualifiers: []
                };
                Season.state.wcQualified = { qualifiers: new Set(), internationalQualifiers: [] };
                Season.state.ukOpenQualifiers = [];
                Season.state.etQualifiers = {};
                Season.state.wsQualifiers = {};
                Season.state.gsQualifiers = {};
                Season.state.wmQualifiers = {};
                Season.state.winmauQualifiers = [];
                if (Season.state.career) {
                    Season.state.career.currentDate = Season.toISODate(new Date(Season.state.year, 0, 1));
                    Season.state.career.dayChoices = {};
                    Season.state.career.trainingStreak = 0;
                    Season.state.career.missedCompetitiveDays = 0;
                }
                Season.renderUI();
                Persistence.save();
            },

            // 3Ô∏è‚É£ OOM T√ÅBL√ÅK (ALL VISIBLE)
            // ============================
            renderOOMTable: (tableId, data, limit) => {
                const activeView = (Season.state && Season.state.activeOOMView) || 'main'; // Define safe activeView
                console.log('renderOOMTable called with tableId:', tableId, 'data keys:', Object.keys(data || {}).length);

                // Get all entries from the data object
                const allEntries = Object.entries(data || {});
                console.log('All entries:', allEntries.length);

                // For main OOM, only show tour card holders
                const isMainOOM = tableId === 'oom-hub-main' || tableId === 'career-oom-table-main' || tableId === 'career-rank-table-main' || tableId === 'career-dashboard-oom-table';

                // Filter and sort
                const list = allEntries
                    .map(([name, money]) => {
                        const p = PLAYERS_DB.find(x => x.name === name);
                        if (!p) {
                            console.log('Player not found in DB:', name);
                            return null;
                        }
                        // For main OOM, only include tour card holders
                        if (isMainOOM && !p.tourCard) {
                            return null;
                        }
                        return { name, money: money || 0, hasTC: p.tourCard || false, p };
                    })
                    .filter(entry => entry !== null)
                    .sort((a, b) => b.money - a.money);  // Sort by money descending

                // Get career player and find their position
                const careerPlayer = Season.getCareerPlayer ? Season.getCareerPlayer() : null;
                let trimmedList = list;

                if (typeof limit === 'number' && limit > 0) {
                    // If limit is explicitly specified, use it
                    trimmedList = list.slice(0, limit);
                }

                console.log('After filtering:', list.length, 'entries');

                const table = document.getElementById(tableId);
                if (!table) {
                    console.warn('Table not found:', tableId);
                    return;
                }
                table.innerHTML = '';
                table.style.visibility = 'visible';
                table.style.display = 'table';

                // Check for Points vs Money based on Table ID if possible, else fallback to activeView
                // Assumes Q-School tables have 'q-' in ID or we are in 'q-' view
                const isPoints = (tableId.includes && (tableId.includes('q-') || tableId.includes('point'))) || activeView.includes('q-');
                const currencyHeader = isPoints ? 'Points' : 'Prize Money';

                // Add table header
                const thead = document.createElement('thead');
                const header = document.createElement('tr');
                header.innerHTML = `<th>Pos</th><th>Player</th><th style="text-align:center;">Tour Card</th><th style="text-align:right;">${currencyHeader}</th>`;
                thead.appendChild(header);
                table.appendChild(thead);

                // Add table body
                const tbody = document.createElement('tbody');

                if (trimmedList.length === 0) {
                    console.log('No entries to display');
                    const row = document.createElement('tr');
                    row.innerHTML = `<td colspan="4" style="text-align:center; color:#aaa; padding:16px; background:#1a1a1a; font-style:italic;">No players have competed yet</td>`;
                    tbody.appendChild(row);
                } else {
                    console.log('Adding', trimmedList.length, 'rows');
                    trimmedList.forEach((entry, i) => {
                        const row = document.createElement('tr');
                        const { name, money, hasTC, p } = entry;

                        // Get the actual position in the full list
                        const actualPosition = list.findIndex(e => e.name === name) + 1;

                        // Check if this is the career player
                        const isCareerPlayer = careerPlayer && name === careerPlayer.name;

                        // Apply highlighting for career player
                        if (isCareerPlayer) {
                            row.style.background = 'linear-gradient(90deg, rgba(255, 215, 0, 0.15), rgba(255, 215, 0, 0.05))';
                            row.style.borderLeft = '4px solid var(--pdc-gold)';
                            row.style.fontWeight = 'bold';
                        }

                        const tourCardBadge = hasTC
                            ? '<span style="background: var(--pdc-gold); color: black; padding: 3px 8px; border-radius: 3px; font-size: 10px; font-weight: bold; display:inline-block;">‚úì</span>'
                            : '<span style="color: #666; font-size:12px;">-</span>';

                        const moneyDisplay = isPoints ? money + ' pts' : '¬£' + money.toLocaleString();

                        row.innerHTML = `
                        <td class="oom-pos">${actualPosition}</td>
                        <td style="font-weight: bold; color: var(--pdc-gold); cursor: pointer;" onclick="Season.showPlayerAchievements('${name}')">${name}</td>
                        <td style="text-align:center;">${tourCardBadge}</td>
                        <td class="oom-money">${moneyDisplay}</td>
                    `;
                        tbody.appendChild(row);
                    });
                }

                table.appendChild(tbody);
            },

            showPlayerAchievements: (playerName) => {
                const player = PLAYERS_DB.find(p => p.name === playerName);
                if (!player) return;

                // Collect all tournament participations from completedEvents
                const tournaments = Season.state.completedEvents
                    .filter(ev => ev.participations && ev.participations[playerName])
                    .sort((a, b) => {
                        const dateA = new Date(a.date || 0);
                        const dateB = new Date(b.date || 0);
                        return dateB - dateA;
                    });

                const modal = document.createElement('div');
                modal.style.cssText = `
                position: fixed;
                inset: 0;
                background: rgba(0,0,0,0.95);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 300;
                padding: 20px;
            `;

                const content = document.createElement('div');
                content.style.cssText = `
                background: linear-gradient(145deg, #1a1f35, #12172a);
                border: 2px solid var(--pdc-gold);
                border-radius: 16px;
                padding: 30px;
                max-width: 700px;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 20px 60px rgba(0,0,0,0.9);
            `;

                let achievementsHTML = `
                <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 25px; border-bottom: 2px solid rgba(255,215,0,0.3); padding-bottom: 15px;">
                    <img src="${getFlagUrl(player.country)}" style="width: 40px; height: 30px; border-radius: 3px;">
                    <div>
                        <div style="font-size: 24px; font-weight: 900; color: var(--pdc-gold);">${playerName}</div>
                        <div style="font-size: 12px; color: #8fa3ad;">${player.country.toUpperCase()}</div>
                    </div>
                </div>
                <div style="font-size: 18px; font-weight: bold; color: var(--pdc-gold); margin-bottom: 15px;">Tournament Results</div>
            `;

                if (tournaments.length === 0) {
                    achievementsHTML += `<div style="color: #aaa; text-align: center; padding: 20px; font-style: italic;">No tournament participations yet</div>`;
                } else {
                    tournaments.forEach(ev => {
                        const result = ev.participations[playerName];

                        // Convert position to proper display format with round names
                        let positionDisplay;
                        if (result.position === 1) {
                            positionDisplay = 'CHAMPION';
                        } else if (result.position === 2) {
                            positionDisplay = 'Runner-up (F)';
                        } else if (result.position === 4) {
                            positionDisplay = 'Semi-Final (SF)';
                        } else if (result.position === 8) {
                            positionDisplay = 'Quarter-Final (QF)';
                        } else if (result.position === 16) {
                            positionDisplay = 'Last 16 (L16)';
                        } else if (result.position === 32) {
                            positionDisplay = 'Last 32 (L32)';
                        } else if (result.position === 64) {
                            positionDisplay = 'Last 64 (L64)';
                        } else if (result.position === 128) {
                            positionDisplay = 'Last 128 (L128)';
                        } else if (result.position === 256) {
                            positionDisplay = 'Last 256 (L256)';
                        } else {
                            // Fallback for unusual positions
                            const suffix = result.position === 3 ? 'rd' : 'th';
                            positionDisplay = `${result.position}${suffix} Place`;
                        }

                        const medal = result.position === 1 ? 'üèÜ' : result.position === 2 ? 'ü•à' : result.position <= 4 ? 'ü•â' : 'üìä';

                        achievementsHTML += `
                        <div style="background: rgba(255,215,0,0.05); padding: 12px; margin-bottom: 10px; border-radius: 8px; border-left: 4px solid ${result.position === 1 ? 'var(--pdc-gold)' : '#999'};">
                            <div style="color: var(--pdc-gold); font-weight: bold; font-size: 14px;">${ev.name || 'Tournament ' + ev.id}</div>
                            <div style="color: #ccc; font-size: 13px; margin-top: 4px;">${medal} ${positionDisplay}${result.money ? ` - ¬£${result.money.toLocaleString()}` : ''}</div>
                        </div>
                    `;
                    });
                }

                achievementsHTML += `
                <button onclick="this.parentElement.parentElement.remove()" style="
                    background: linear-gradient(145deg, #d4af37, #aa8c2e);
                    color: black;
                    border: none;
                    padding: 10px 20px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-weight: bold;
                    margin-top: 20px;
                    width: 100%;
                ">Close</button>
            `;

                content.innerHTML = achievementsHTML;
                modal.appendChild(content);
                document.body.appendChild(modal);
            },

            renderFormFatigueTable: (tableId) => {
                const table = document.getElementById(tableId);
                if (!table) {
                    console.warn('Table not found:', tableId);
                    return;
                }
                table.innerHTML = '';
                table.style.visibility = 'visible';
                table.style.display = 'table';

                // Get all players sorted by form
                const allPlayers = PLAYERS_DB.map(p => ({
                    name: p.name,
                    form: p.form || 50,
                    fatigue: p.fatigue || 0,
                    country: p.country
                })).sort((a, b) => b.form - a.form);

                // Add table header
                const thead = document.createElement('thead');
                const header = document.createElement('tr');
                header.innerHTML = `<th>Pos</th><th>Player</th><th style="text-align:center;">Form</th><th style="text-align:center;">Fatigue</th>`;
                thead.appendChild(header);
                table.appendChild(thead);

                // Add table body
                const tbody = document.createElement('tbody');

                if (allPlayers.length === 0) {
                    const row = document.createElement('tr');
                    row.innerHTML = `<td colspan="4" style="text-align:center; color:#aaa; padding:16px; background:#1a1a1a; font-style:italic;">No player data available</td>`;
                    tbody.appendChild(row);
                } else {
                    allPlayers.forEach((player, i) => {
                        const row = document.createElement('tr');
                        const formColor = player.form > 80 ? '#4caf50' : player.form > 50 ? '#ffeb3b' : '#f44336';
                        const fatigueColor = player.fatigue < 30 ? '#4caf50' : player.fatigue < 70 ? '#ffeb3b' : '#f44336';

                        row.innerHTML = `
                            <td class="oom-pos">${i + 1}</td>
                            <td style="font-weight: bold; color: var(--pdc-gold); cursor: pointer;" onclick="Season.showPlayerAchievements('${player.name}')">${player.name}</td>
                            <td style="text-align:center; font-size:13px;">
                                <span style="color:${formColor}; font-weight:bold;">üî• ${Math.round(player.form)}</span>
                            </td>
                            <td style="text-align:center; font-size:13px;">
                                <span style="color:${fatigueColor}; font-weight:bold;">‚ö° ${Math.round(player.fatigue)}%</span>
                            </td>
                        `;
                        tbody.appendChild(row);
                    });
                }

                table.appendChild(tbody);
            },

            startEvent: (idx, isSim) => {
                Tournament.setSelectionMethod('manual'); // Ensure season events use manual logic
                // Initialize guard if not set
                if (typeof Season.guardAgainstAutoStart === 'undefined') {
                    Season.guardAgainstAutoStart = false;
                }

                // Get full stack trace to see where startEvent is being called from
                const errorStack = new Error().stack;
                const stackLines = errorStack.split('\n').slice(1, 5).map(line => line.trim()).join('\n');
                console.log(`[startEvent CALLED] idx=${idx}, isSim=${isSim}, guard=${Season.guardAgainstAutoStart}, inProgress=${Season.state.inProgress}\nStack:\n${stackLines}`);

                // THREE-LEVEL PROTECTION: Guard + inProgress + explicit check
                const guardActive = Season.guardAgainstAutoStart === true;
                const inProgressActive = Season.state.inProgress === true;
                const tournamentActive = Tournament.state.active === true;

                // Prevent accidental re-entrance during event transitions (especially Premier League nights)
                // Check guard FIRST before doing anything else
                if (guardActive) {
                    console.warn(`[startEvent BLOCKED] guard is set, rejecting startEvent call`);
                    return;
                }

                // DOUBLE CHECK: if inProgress is true, this means another event is being processed
                // RECOVERY: If guard is NOT active, but inProgress IS active, it's likely a stuck state from a previous error.
                // We will Log a warning but PROCEED (effectively resetting the stuck state).
                if (inProgressActive) {
                    console.warn(`[startEvent WARNING] inProgress was true, but guard is false. Assuming stuck state and resetting.`);
                    Season.state.inProgress = false;
                }

                // TRIPLE CHECK: if tournament is active, we cannot start a new one
                // RECOVERY: Same as above, if we are starting a NEW event, we should force clear the old one.
                if (tournamentActive) {
                    console.warn(`[startEvent WARNING] Tournament.state.active was true. Force clearing old tournament state.`);
                    Tournament.state.active = false;
                    Persistence.clearTournamentOnly();
                }

                Tournament.config.lockRounds = true;
                Season.state.activeEventIndex = idx;

                const autoSimIfRequested = () => {
                    if (!isSim) return false;
                    try {
                        Season.silentSimulation = true;
                        Tournament.skipAdvancementAnimation = true;
                        Tournament.forceShowFinalAnimation = false;
                        Tournament.simulateToEnd();
                        return true;
                    } catch (e) {
                        console.error("AutoSim failed:", e);
                        alert("Simulation Error: " + e.message);
                        Season.state.inProgress = false;
                        Tournament.state.active = false;
                        return false;
                    } finally {
                        Tournament.skipAdvancementAnimation = false;
                        Tournament.forceShowFinalAnimation = false;
                        Season.silentSimulation = false;
                    }
                };

                Season.state.inProgress = true;
                Tournament.state.active = true;

                Tournament.clearSelection();
                Tournament.state.selectedPlayerIndices.clear();

                const ev = Season.events[idx];

                // ==============================
                // EVENT BASIC CONFIG
                // ==============================
                Tournament.config.eventType = ev.type;
                Tournament.config.eventPlayers = ev.players;
                Tournament.setMode(ev.format);

                // ==============================
                // THEME CONFIG FROM EVENT
                // ==============================
                // Theme resolution: Use whatever themePreset is set on the tournament
                // If no themePreset, fall back to tournament type, then "default", then "minor"
                // The actual theme lookup happens in applyEventColors which has the full default themes

                if (ev.themePreset) {
                    // Tournament has a specific themePreset set - ALWAYS use it
                    Tournament.config.theme = { mode: 'preset', id: ev.themePreset };
                    console.log('[Season.startEvent] Using themePreset:', ev.themePreset);
                } else if (ev.type) {
                    // No themePreset - use tournament type as the theme key
                    Tournament.config.theme = { mode: 'preset', id: ev.type };
                    console.log('[Season.startEvent] Using tournament type as theme:', ev.type);
                } else {
                    // Fall back to minor theme
                    Tournament.config.theme = { mode: 'preset', id: 'minor' };
                    console.log('[Season.startEvent] Fallback to minor theme');
                }

                // For season mode with Winmau Masters sets format, set to 2 legs/set
                if (isSim && ev.type === 'winmaudm' && ev.format === 'sets') {
                    const legsEl = document.getElementById('inp-tourn-set-legs');
                    if (legsEl) legsEl.value = '2';
                } else if (ev.format === 'sets') {
                    // Default to 3 legs/set for custom tournaments
                    const legsEl = document.getElementById('inp-tourn-set-legs');
                    if (legsEl) legsEl.value = '3';
                }

                document.getElementById('tourn-event-name').value = ev.name;
                document.getElementById('tourn-size').value = ev.players;

                // ==============================
                // üî• ROUND TARGETS - Use database rounds if available
                // ==============================
                Tournament.config.rounds = [];

                if (ev.rounds && Array.isArray(ev.rounds) && ev.rounds.length > 0) {
                    // Use rounds from database (set in admin panel)
                    Tournament.config.rounds = ev.rounds.map(r => ({
                        name: r.name,
                        target: r.target
                    }));
                    console.log('[Season.startEvent] Using rounds from database:', Tournament.config.rounds);
                } else {
                    // Generate rounds dynamically from ROUND_FORMATS
                    const formats = ROUND_FORMATS[ev.type] || {};
                    let players = ev.players;

                    while (players >= 2) {
                        const roundName =
                            players === 2 ? "F" :
                                players === 4 ? "SF" :
                                    players === 8 ? "QF" :
                                        players === 16 ? "L16" :
                                            players === 32 ? "L32" :
                                                players === 64 ? "L64" :
                                                    players === 128 ? "L128" :
                                                        players === 256 ? "L256" :
                                                            `L${players}`;

                        const target = formats[roundName] ?? ev.dist ?? 6;

                        Tournament.config.rounds.push({
                            name: roundName,
                            target: target
                        });

                        players /= 2;
                    }
                    console.log('[Season.startEvent] Generated rounds from ROUND_FORMATS');
                }

                // =======================
                // PLAYER POOL
                // =======================
                let pool = PLAYERS_DB;

                // Challenge Tour ‚Üí csak nem Tour Cardos
                if (ev.type === "challenge") {
                    pool = PLAYERS_DB.filter(p => !p.tourCard);
                }

                // Q-School ‚Üí csak nem Tour Cardos
                else if (ev.type === "q-school") {
                    pool = PLAYERS_DB.filter(p => !p.tourCard);
                }

                // WC International Qualifiers ‚Üí Exclude players already qualified for WC via rankings
                else if (ev.type === "wc-qual-intl") {
                    // Exclude top 40 from Main OOM and top 40 from Pro Tour OOM (auto-qualified for WC)
                    const exclude = new Set();

                    // Exclude top 40 by Main OOM
                    Object.entries(Season.state.orderOfMerit)
                        .filter(([n]) => PLAYERS_DB.find(p => p.name === n)?.tourCard)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 40)
                        .forEach(e => exclude.add(e[0]));

                    // Exclude top 40 from Pro Tour OOM
                    Object.entries(Season.state.proTourOOM)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 40)
                        .forEach(e => exclude.add(e[0]));

                    // Apply regional filtering based on event name
                    let regionFilter = null;
                    let isStrictRegionalEvent = false;  // Flag for strict regional enforcement
                    if (ev.name.includes("HUNGARIAN")) regionFilter = ["hun"];
                    else if (ev.name.includes("NETHERLANDS & BELGIUM")) regionFilter = ["nl", "bel"];
                    else if (ev.name.includes("MEDITERRANEAN")) regionFilter = ["esp", "ita", "por", "gre", "tur"];
                    else if (ev.name.includes("SOUTH-EAST EUROPE")) regionFilter = ["rou", "bul", "srb", "cro", "slo"];
                    else if (ev.name.includes("CZECHIA")) regionFilter = ["cze"];
                    else if (ev.name.includes("POLISH") || ev.name.includes("PDO POLISH")) regionFilter = ["pol"];
                    else if (ev.name.includes("DACH")) regionFilter = ["ger", "aut", "sui"];
                    else if (ev.name.includes("UK&IRE")) regionFilter = ["eng", "sco", "wal", "nir", "irl"];
                    else if (ev.name.includes("AFRICAN")) { regionFilter = REGION_MAP.africa; isStrictRegionalEvent = true; }
                    else if (ev.name.includes("INDIA")) { regionFilter = REGION_MAP.india; isStrictRegionalEvent = true; }
                    else if (ev.name.includes("JAPAN")) { regionFilter = ["jpn"]; isStrictRegionalEvent = true; }
                    else if (ev.name.includes("NORDIC & BALTIC")) regionFilter = REGION_MAP.nordic;
                    else if (ev.name.includes("NORTH AMERICAN")) regionFilter = REGION_MAP.america;
                    else if (ev.name.includes("ASIAN")) regionFilter = REGION_MAP.asia;
                    else if (ev.name.includes("CDC") || ev.name.includes("CDLC")) regionFilter = REGION_MAP.america;
                    else if (ev.name.includes("ANZ") || ev.name.includes("DPA") || ev.name.includes("DPNZ")) regionFilter = REGION_MAP.oceania;
                    else if (ev.name.includes("CHALLENGE TOUR")) regionFilter = null; // No regional restriction

                    if (regionFilter) {
                        pool = PLAYERS_DB.filter(p => !exclude.has(p.name) && regionFilter.includes(p.country));
                    } else {
                        pool = PLAYERS_DB.filter(p => !exclude.has(p.name));
                    }
                }

                // WC Tour Card Holder Qualifier ‚Üí For tour card holders not auto-qualified
                else if (ev.type === "wc-qual-tc") {
                    // Exclude top 40 from Main OOM and top 40 from Pro Tour OOM (auto-qualified for WC)
                    const exclude = new Set();

                    Object.entries(Season.state.orderOfMerit)
                        .filter(([n]) => PLAYERS_DB.find(p => p.name === n)?.tourCard)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 40)
                        .forEach(e => exclude.add(e[0]));

                    Object.entries(Season.state.proTourOOM)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 40)
                        .forEach(e => exclude.add(e[0]));

                    pool = PLAYERS_DB.filter(p => p.tourCard && !exclude.has(p.name));
                }

                // Pro Tour (PC, ET, Major ahol kell)
                else if (ev.cardRequired) {
                    pool = PLAYERS_DB.filter(p => p.tourCard);
                }

                // ========================
                // PREMIER LEAGUE
                // ========================
                if (ev.type === "premier-league" || ev.type === "premier-league-playoff") {
                    Season.initializePremierLeague(idx, ev, isSim);
                    return;
                }

                // ==============================
                // WC INTERNATIONAL QUALIFIERS
                // ==============================
                if (ev.type === "wc-qual-intl") {
                    const selected = Tournament.state.selectedPlayerIndices;
                    selected.clear();

                    pool.slice(0, ev.players).forEach(p => selected.add(PLAYERS_DB.indexOf(p)));

                    let attempts = 0;
                    while (selected.size < ev.players && attempts < 1000) {
                        const r = pool[Math.floor(Math.random() * pool.length)];
                        if (r) selected.add(PLAYERS_DB.indexOf(r));
                        attempts++;
                    }

                    // If still short, generate regional players
                    while (selected.size < ev.players) {
                        let newIdx = PlayerState.getReplacementPlayer(Array.from(selected), ev.type, ev.name);
                        if (newIdx >= 0) {
                            selected.add(newIdx);
                        } else {
                            // Fallback: generate regional players directly if getReplacementPlayer fails
                            if (ev.name.includes("AFRICAN")) {
                                newIdx = PlayerState.generateRandomAfricanPlayer();
                            } else if (ev.name.includes("INDIA")) {
                                newIdx = PlayerState.generateRandomIndianPlayer();
                            } else if (ev.name.includes("JAPAN")) {
                                newIdx = PlayerState.generateRandomJapanesePlayer();
                            } else {
                                break;  // No suitable player can be generated
                            }
                            if (newIdx >= 0) selected.add(newIdx);
                            else break;
                        }
                    }

                    Tournament.setSelectionMethod('manual');
                    Tournament.updateConfigUI();
                    Tournament.start();
                    if (autoSimIfRequested()) return;
                    return;
                }

                // ==============================
                // EUROPEAN TOUR QUALIFIERS (TC, HOST, EAST, NB)
                // ==============================
                if (ev.type === "et-qual-tc" || ev.type === "et-host-nation" || ev.type === "et-east-european" || ev.type === "et-nordic-baltic") {
                    const selected = Tournament.state.selectedPlayerIndices;
                    selected.clear();

                    let pool = PLAYERS_DB;
                    let generationRegion = null; // Store region for regen

                    // Build exclusion set for players already qualified for the main ET event
                    // These are top 16 Main OOM (seeds) and top 16 Pro Tour OOM (qualifiers)
                    const alreadyQualified = new Set();

                    // Top 16 Main OOM seeds
                    const mainOOMSorted = [...PLAYERS_DB]
                        .filter(p => p.tourCard)
                        .sort((a, b) => (Season.state.orderOfMerit[b.name] || 0) - (Season.state.orderOfMerit[a.name] || 0));
                    mainOOMSorted.slice(0, 16).forEach(p => alreadyQualified.add(p.name));

                    // Top 16 Pro Tour OOM qualifiers (excluding those already in seeds)
                    const proOOMSorted = [...PLAYERS_DB]
                        .filter(p => p.tourCard)
                        .sort((a, b) => (Season.state.proTourOOM[b.name] || 0) - (Season.state.proTourOOM[a.name] || 0));
                    proOOMSorted.slice(0, 32).forEach(p => {
                        // Add to qualified set (first 16 not already in seeds)
                        if (!alreadyQualified.has(p.name) && alreadyQualified.size < 32) {
                            alreadyQualified.add(p.name);
                        }
                    });

                    if (ev.type === "et-qual-tc") {
                        // Exclude top 16 Main OOM (by world ranking) and top 16 Pro Tour OOM
                        const exclude = new Set();

                        // Exclude top 16 players by world ranking (PLAYERS_DB order)
                        PLAYERS_DB.slice(0, 16).forEach(p => exclude.add(p.name));

                        // Also exclude top 16 from Pro Tour OOM
                        const proEntries = Object.entries(Season.state.proTourOOM).filter(e => e[1] > 0);
                        if (proEntries.length >= 16) {
                            proEntries.sort((a, b) => b[1] - a[1]).slice(0, 16).forEach(e => exclude.add(e[0]));
                        }

                        pool = PLAYERS_DB.filter(p => p.tourCard && !exclude.has(p.name));
                    } else if (ev.type === "et-host-nation") {
                        const hostCode = HOST_NATION[ev.targetEvent];
                        // Filter by host nation AND exclude already-qualified players
                        pool = hostCode ? PLAYERS_DB.filter(p => p.country === hostCode && !alreadyQualified.has(p.name)) : [];
                        generationRegion = hostCode; // Regen using host nation
                    } else if (ev.type === "et-east-european") {
                        // Exclude already-qualified players from East European qualifier
                        pool = PLAYERS_DB.filter(p => REGION_MAP.east.includes(p.country) && !alreadyQualified.has(p.name));
                        generationRegion = "east";
                    } else if (ev.type === "et-nordic-baltic") {
                        // Exclude already-qualified players from Nordic/Baltic qualifier
                        pool = PLAYERS_DB.filter(p => REGION_MAP.nordic.includes(p.country) && !alreadyQualified.has(p.name));
                        generationRegion = "nordic";
                    }

                    pool.slice(0, ev.players).forEach(p => selected.add(PLAYERS_DB.indexOf(p)));

                    let attempts = 0;
                    while (selected.size < ev.players && attempts < 1000) {
                        const r = pool[Math.floor(Math.random() * pool.length)];
                        if (r) selected.add(PLAYERS_DB.indexOf(r));
                        attempts++;
                    }

                    // If still short, generate random players
                    while (selected.size < ev.players) {
                        // FIX: Pass generationRegion to ensure correct nationality
                        const newIdx = PlayerState.generateRandomPlayer(ev.type, generationRegion);
                        if (newIdx >= 0) selected.add(newIdx);
                    }

                    Tournament.setSelectionMethod('manual');
                    Tournament.updateConfigUI();
                    Tournament.start();
                    if (autoSimIfRequested()) return;
                    return;
                }

                if (ev.type === "grandslam") {
                    const list = Season.buildGrandSlamQualifiers();
                    list.forEach(name => {
                        const p = PLAYERS_DB.find(x => x.name === name);
                        if (p) Tournament.state.selectedPlayerIndices.add(PLAYERS_DB.indexOf(p));
                    });

                    // Grand Slam uses group stage format
                    Tournament.config.isGroupStage = true;
                    Tournament.config.groupStageRound = true;

                    Tournament.startGrandSlamGroupStage();
                    if (autoSimIfRequested()) return;
                    return;
                }

                // ========================
                // WORLD SERIES FINALS QUALIFICATION
                // ========================
                if (ev.type === "masters-final") {

                    const selected = Tournament.state.selectedPlayerIndices;
                    selected.clear();

                    // 1Ô∏è‚É£ World Series Qualifier winners (8 spots)
                    const wsQualifiers = Season.state.wsQualifiers?.[25] || [];
                    wsQualifiers.forEach(name => {
                        const p = PLAYERS_DB.find(x => x.name === name);
                        if (p) selected.add(PLAYERS_DB.indexOf(p));
                    });

                    // 2Ô∏è‚É£ Top 22 World Series OOM
                    const wsTop22 = Object.entries(Season.state.worldSeriesOOM)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 22)
                        .map(e => e[0]);

                    wsTop22.forEach(name => {
                        const p = PLAYERS_DB.find(x => x.name === name);
                        if (p && selected.size < 32) selected.add(PLAYERS_DB.indexOf(p));
                    });

                    // 3Ô∏è‚É£ Top 4 Pro Tour OOM (if slots remain)
                    const proTop4 = Object.entries(Season.state.proTourOOM)
                        .sort((a, b) => b[1] - a[1])
                        .map(e => e[0])
                        .filter(name => !selected.has(PLAYERS_DB.findIndex(p => p.name === name)))
                        .slice(0, 4);

                    proTop4.forEach(name => {
                        const p = PLAYERS_DB.find(x => x.name === name);
                        if (p && selected.size < 32) selected.add(PLAYERS_DB.indexOf(p));
                    });

                    // 4Ô∏è‚É£ Tour Card holders to fill remaining slots
                    const tourCardPool = PLAYERS_DB.filter(p =>
                        p.tourCard && !selected.has(PLAYERS_DB.indexOf(p))
                    );

                    let attempts = 0;
                    while (selected.size < 32 && attempts < 2000) {
                        const r = tourCardPool[Math.floor(Math.random() * tourCardPool.length)];
                        if (r) selected.add(PLAYERS_DB.indexOf(r));
                        attempts++;
                    }
                    Tournament.setSelectionMethod('manual');
                    Tournament.updateConfigUI();
                    Tournament.start();
                }

                if (ev.type === "world") {

                    const list = Season.buildWorldChampionshipQualifiers();
                    console.log("World Championship: Got", list.length, "qualifiers");

                    const selected = Tournament.state.selectedPlayerIndices;
                    selected.clear();

                    const notFound = [];
                    list.forEach(name => {
                        const p = PLAYERS_DB.find(x => x.name === name);
                        if (p) {
                            selected.add(PLAYERS_DB.indexOf(p));
                        } else {
                            notFound.push(name);
                        }
                    });

                    if (notFound.length > 0) {
                        console.warn(`Players not found in PLAYERS_DB:`, notFound);
                    }

                    console.log("World Championship: Selected", selected.size, "players");

                    // If we're short, fill from top OOM tour card holders
                    if (selected.size < 128) {
                        const needed = 128 - selected.size;
                        console.warn(`World Championship short by ${needed} players, filling from OOM`);

                        const fillPool = PLAYERS_DB
                            .filter(p => p.tourCard && !selected.has(PLAYERS_DB.indexOf(p)))
                            .sort((a, b) => (Season.state.orderOfMerit[b.name] || 0) - (Season.state.orderOfMerit[a.name] || 0));

                        fillPool.slice(0, needed).forEach(p => {
                            selected.add(PLAYERS_DB.indexOf(p));
                        });

                        console.log(`Filled ${needed} spots, now have ${selected.size} players`);
                    }

                    // Reset group stage flags (in case Grand Slam ran before)
                    Tournament.config.isGroupStage = false;
                    Tournament.config.groupStageRound = false;

                    Tournament.setSelectionMethod('manual');
                    Tournament.updateConfigUI();
                    Tournament.start();
                }




                // ========================
                // UK OPEN SPECIAL
                // ========================
                if (ev.type === 'uk-open') {
                    // Ensure qualifiers exist
                    if (!Season.state.ukOpenQualifiers || Season.state.ukOpenQualifiers.length < 32) {
                        Season.simulateUKOpenQuali();
                    }

                    // Build Tour Card sorted by Order of Merit
                    const tcPlayers = PLAYERS_DB.filter(p => p.tourCard);
                    const sortedTC = [...tcPlayers].sort((a, b) => (Season.state.orderOfMerit[b.name] || 0) - (Season.state.orderOfMerit[a.name] || 0));

                    const top32 = sortedTC.slice(0, 32);
                    const ranks33_64 = sortedTC.slice(32, 64);
                    const ranks65_96 = sortedTC.slice(64, 96);
                    const ranks97_128 = sortedTC.slice(96, 128);

                    const nameToIndex = new Map(PLAYERS_DB.map((p, i) => [p.name, i]));
                    // Map qualifiers to indices and backfill if fewer than 32
                    let qualifiersIdx = Season.state.ukOpenQualifiers
                        .map(n => nameToIndex.has(n) ? nameToIndex.get(n) : null)
                        .filter(i => i !== null);
                    const used = new Set(qualifiersIdx);
                    if (qualifiersIdx.length < 32) {
                        // Prefer non-tour card players not already used
                        const nonTC = PLAYERS_DB
                            .map((p, i) => ({ p, i }))
                            .filter(x => !x.p.tourCard && !used.has(x.i));
                        for (let j = 0; j < nonTC.length && qualifiersIdx.length < 32; j++) {
                            qualifiersIdx.push(nonTC[j].i);
                            used.add(nonTC[j].i);
                        }
                        // If still short, fill from any remaining players not used
                        if (qualifiersIdx.length < 32) {
                            for (let i = 0; i < PLAYERS_DB.length && qualifiersIdx.length < 32; i++) {
                                if (!used.has(i)) { qualifiersIdx.push(i); used.add(i); }
                            }
                        }
                    }
                    qualifiersIdx = qualifiersIdx.slice(0, 32);

                    const dedupe = arr => Array.from(new Set(arr.filter(i => typeof i === 'number' && i >= 0)));

                    // Build all pools first to track who should be in each round
                    const r4TopIdx = dedupe(top32.map(p => PLAYERS_DB.indexOf(p))).slice(0, 32);
                    const r3Idx = dedupe(ranks33_64.map(p => PLAYERS_DB.indexOf(p))).slice(0, 32);
                    const r2Idx = dedupe(ranks65_96.map(p => PLAYERS_DB.indexOf(p))).slice(0, 32);
                    let r1Idx = dedupe(ranks97_128.map(p => PLAYERS_DB.indexOf(p)).slice(0, 32).concat(qualifiersIdx));

                    // Track all players reserved for later rounds
                    const reservedForLaterRounds = new Set([...r4TopIdx, ...r3Idx, ...r2Idx]);

                    // Remove any reserved players from R1
                    r1Idx = r1Idx.filter(i => !reservedForLaterRounds.has(i));

                    // Backfill R1 if short
                    if (r1Idx.length < 64) {
                        const usedInR1 = new Set(r1Idx);
                        for (let i = 0; i < PLAYERS_DB.length && r1Idx.length < 64; i++) {
                            if (!usedInR1.has(i) && !reservedForLaterRounds.has(i)) {
                                r1Idx.push(i);
                                usedInR1.add(i);
                            }
                        }
                    }

                    Tournament.state.ukOpenEntrants = {
                        R1: r1Idx.slice(0, 64),
                        R2: r2Idx,
                        R3: r3Idx,
                        R4Top32: r4TopIdx
                    };

                    // Define rounds explicitly
                    Tournament.config.rounds = [
                        { name: 'R1', target: 6 },
                        { name: 'R2', target: 6 },
                        { name: 'R3', target: 6 },
                        { name: 'L64', target: 10 },
                        { name: 'L32', target: 10 },
                        { name: 'L16', target: 10 },
                        { name: 'QF', target: 10 },
                        { name: 'SF', target: 11 },
                        { name: 'F', target: 11 }
                    ];

                    Tournament.config.eventType = 'uk-open';
                    Tournament.config.lockRounds = true;

                    // Start UK Open custom flow
                    if (Season.applyCareerParticipationToSelection) {
                        Season.applyCareerParticipationToSelection(ev);
                    }
                    Tournament.startUkOpen();
                    Persistence.save();
                    if (isSim) {
                        while (Tournament.state.active) { Tournament.simulateRound(); }
                    }
                    return;
                }


                // ========================
                // PLAYERS CHAMPIONSHIP FINALS QUALIFICATION
                // ========================
                if (ev.name === "PLAYERS CHAMPIONSHIP FINALS") {

                    const selected = Tournament.state.selectedPlayerIndices;
                    selected.clear();

                    const top64 = Object.entries(Season.state.proTourOOM)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 64)
                        .map(e => e[0]);

                    top64.forEach(name => {
                        const p = PLAYERS_DB.find(x => x.name === name);
                        if (p) selected.add(PLAYERS_DB.indexOf(p));
                    });

                    Tournament.updateConfigUI();
                    Tournament.start();
                }


                // ========================
                // EUROPEAN CHAMPIONSHIP QUALIFICATION
                // ========================
                if (ev.name === "MACHINESEEKER EUROPEAN CHAMPIONSHIP") {

                    const selected = Tournament.state.selectedPlayerIndices;
                    selected.clear();

                    const top32 = Object.entries(Season.state.orderOfMerit)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 32)
                        .map(e => e[0]);

                    top32.forEach(name => {
                        const p = PLAYERS_DB.find(x => x.name === name);
                        if (p) selected.add(PLAYERS_DB.indexOf(p));
                    });
                    Tournament.updateConfigUI();
                    Tournament.start();
                }

                // ========================
                // WORLD MATCHPLAY
                // ========================
                if ((ev.name === "MATCHPLAY" || ev.type === "matchplay") || ev.type === 'grandprix') {

                    const selected = Tournament.state.selectedPlayerIndices;
                    selected.clear();

                    // 1Ô∏è‚É£ Top 16 MAIN OOM
                    const topMain = [...PLAYERS_DB]
                        .sort((a, b) => (Season.state.orderOfMerit[b.name] || 0) - (Season.state.orderOfMerit[a.name] || 0))
                        .slice(0, 16);

                    topMain.forEach(p => selected.add(PLAYERS_DB.indexOf(p)));

                    // 2Ô∏è‚É£ Top 16 PRO TOUR OOM (dupl√°z√°s n√©lk√ºl)
                    const proSorted = [...PLAYERS_DB]
                        .filter(p => p.tourCard)
                        .sort((a, b) => (Season.state.proTourOOM[b.name] || 0) - (Season.state.proTourOOM[a.name] || 0));

                    for (let p of proSorted) {
                        if (selected.size >= 32) break;
                        selected.add(PLAYERS_DB.indexOf(p));
                    }
                    Tournament.updateConfigUI();
                    Tournament.start();
                }

                // ========================
                // WINMAU DARTS MASTERS
                // ========================
                if (ev.type === 'winmaudm') {

                    const selected = Tournament.state.selectedPlayerIndices;
                    selected.clear();

                    const seeds = Object.entries(Season.state.orderOfMerit)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 24)
                        .map(e => e[0]);

                    const qualifiers = (Season.state.wmQualifiers?.[ev.id] || []).slice(0, 8);

                    const addByName = (name) => {
                        const p = PLAYERS_DB.find(x => x.name === name);
                        if (p) selected.add(PLAYERS_DB.indexOf(p));
                    };

                    seeds.forEach(addByName);

                    if (qualifiers.length === 0) {
                        // Fallback to simulated qualifiers if prelim not played
                        Season.simulateWinmauQuali(ev.id);
                        Season.state.winmauQualifiers.forEach(addByName);
                    } else {
                        qualifiers.forEach(addByName);
                    }

                    // Safety fill from tour card holders
                    const tcPool = PLAYERS_DB.filter(p => p.tourCard && !selected.has(PLAYERS_DB.indexOf(p)));
                    let attempts = 0;
                    while (selected.size < 32 && attempts < 2000) {
                        const r = tcPool[Math.floor(Math.random() * tcPool.length)];
                        if (r) selected.add(PLAYERS_DB.indexOf(r));
                        attempts++;
                    }

                    Tournament.setSelectionMethod('manual');
                    Tournament.updateConfigUI();
                    Tournament.start();
                    if (autoSimIfRequested()) return;
                    return;
                }

                // ========================
                // WORLD SERIES / GRAND SLAM TOUR QUALIFIERS
                // ========================
                if (ev.type === 'ws-qual-tc' || ev.type === 'gs-qual-tc') {
                    const selected = Tournament.state.selectedPlayerIndices;
                    selected.clear();

                    const rankByMain = (arr) => arr.slice().sort((a, b) => (Season.state.orderOfMerit[b.name] || 0) - (Season.state.orderOfMerit[a.name] || 0));
                    const top24Main = rankByMain(PLAYERS_DB.filter(p => p.tourCard)).slice(0, 24).map(p => p.name);

                    const pool = PLAYERS_DB.filter(p => p.tourCard && !top24Main.includes(p.name));
                    pool.slice(0, ev.players).forEach(p => selected.add(PLAYERS_DB.indexOf(p)));

                    // Backfill if short
                    let attempts = 0;
                    while (selected.size < ev.players && attempts < 1000) {
                        const r = pool[Math.floor(Math.random() * pool.length)];
                        if (r) selected.add(PLAYERS_DB.indexOf(r));
                        attempts++;
                    }

                    Tournament.setSelectionMethod('manual');
                    Tournament.updateConfigUI();
                    Tournament.start();
                    if (autoSimIfRequested()) return;
                    return;
                }

                // ========================
                // WINMAU PRELIM QUALIFIER (PENULTIMATE ROUND)
                // ========================
                if (ev.type === 'wmasters-qual') {
                    const selected = Tournament.state.selectedPlayerIndices;
                    selected.clear();

                    const challengeRanked = Object.entries(Season.state.challengeTourOOM)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 32)
                        .map(e => e[0]);

                    const oomRanked = Object.entries(Season.state.orderOfMerit)
                        .sort((a, b) => b[1] - a[1])
                        .slice(24, 56)
                        .map(e => e[0]);

                    const addByName = (name) => {
                        const p = PLAYERS_DB.find(x => x.name === name);
                        if (p) selected.add(PLAYERS_DB.indexOf(p));
                    };

                    challengeRanked.forEach(addByName);
                    oomRanked.forEach(addByName);

                    const backfill = PLAYERS_DB.filter(p => p.tourCard && !selected.has(PLAYERS_DB.indexOf(p)));
                    let attempts = 0;
                    while (selected.size < ev.players && attempts < 2000) {
                        const r = backfill[Math.floor(Math.random() * backfill.length)];
                        if (r) selected.add(PLAYERS_DB.indexOf(r));
                        attempts++;
                    }

                    Tournament.setSelectionMethod('manual');
                    Tournament.updateConfigUI();
                    Tournament.start();
                    if (autoSimIfRequested()) return;
                    return;
                }

                // ========================
                // 2. MASTERS EVENTS
                // ========================
                if (ev.type === 'masters') {

                    const oomSorted = [...PLAYERS_DB]
                        .filter(p => p.tourCard)
                        .sort((a, b) => (Season.state.orderOfMerit[b.name] || 0) - (Season.state.orderOfMerit[a.name] || 0));

                    const regionSorted = [...PLAYERS_DB]
                        .filter(p => REGION_MAP[ev.region]?.includes(p.country))
                        .sort((a, b) => (Season.state.orderOfMerit[b.name] || 0) - (Season.state.orderOfMerit[a.name] || 0));

                    // Top 8 OOM
                    oomSorted.slice(0, 8).forEach(p =>
                        Tournament.state.selectedPlayerIndices.add(PLAYERS_DB.indexOf(p))
                    );

                    // Top 8 region
                    regionSorted.slice(0, 8).forEach(p =>
                        Tournament.state.selectedPlayerIndices.add(PLAYERS_DB.indexOf(p))
                    );

                    // Fill up 16-ra
                    const allSorted = [...PLAYERS_DB].sort(
                        (a, b) => (Season.state.orderOfMerit[b.name] || 0) - (Season.state.orderOfMerit[a.name] || 0)
                    );

                    allSorted.forEach(p => {
                        if (Tournament.state.selectedPlayerIndices.size < ev.players) {
                            Tournament.state.selectedPlayerIndices.add(PLAYERS_DB.indexOf(p));
                        }
                    });

                    Tournament.setSelectionMethod('manual');
                    Tournament.updateConfigUI();
                    Tournament.start();
                    if (autoSimIfRequested()) return;
                    return;
                }
                // ========================
                // Players Championship
                // ========================
                else if (ev.type === "players") {
                    pool = PLAYERS_DB.filter(p => p.tourCard);

                    pool.sort((a, b) => (Season.state.orderOfMerit[b.name] || 0) - (Season.state.orderOfMerit[a.name] || 0));
                    pool.slice(0, 128).forEach(p =>
                        Tournament.state.selectedPlayerIndices.add(PLAYERS_DB.indexOf(p))
                    );

                    // If we don't have 128 tour card holders, backfill from best Challenge Tour players
                    if (Tournament.state.selectedPlayerIndices.size < 128) {
                        const challengeTop = Object.entries(Season.state.challengeTourOOM)
                            .sort((a, b) => b[1] - a[1])
                            .map(e => e[0]);

                        for (const name of challengeTop) {
                            if (Tournament.state.selectedPlayerIndices.size >= 128) break;
                            const p = PLAYERS_DB.find(x => x.name === name);
                            if (p && !p.tourCard) {
                                Tournament.state.selectedPlayerIndices.add(PLAYERS_DB.indexOf(p));
                            }
                        }
                    }
                }
                // ========================
                // 3. EUROPEAN TOUR (MINOR)
                // ========================
                else if (ev.type === 'minor') {
                    // 16 seeds from top 16 on 2-year Main OOM
                    const rankMain = (arr) => arr.slice().sort((a, b) => (Season.state.orderOfMerit[b.name] || 0) - (Season.state.orderOfMerit[a.name] || 0));
                    // 16 qualifiers from top 16 on 1-year Pro Tour OOM
                    const rankPro = (arr) => arr.slice().sort((a, b) => (Season.state.proTourOOM[b.name] || 0) - (Season.state.proTourOOM[a.name] || 0));

                    const qData = Season.state.etQualifiers[ev.id] || {};
                    const byName = (name) => PLAYERS_DB.find(p => p.name === name);

                    // Slot 1: 16 seeds from 2-year Main OOM
                    const seeds = rankMain(PLAYERS_DB.filter(p => p.tourCard)).slice(0, 16);

                    // Track used players
                    const used = new Set(seeds.map(p => p.name));

                    // Slot 2: 16 from 1-year Pro Tour OOM (excluding seeds)
                    const proTourQualifiers = [];
                    rankPro(PLAYERS_DB.filter(p => p.tourCard)).forEach(p => {
                        if (proTourQualifiers.length < 16 && !used.has(p.name)) {
                            proTourQualifiers.push(p);
                            used.add(p.name);
                        }
                    });

                    // Slot 3: 16 from qualifier events
                    // Logic fixed to prevent duplicates within the qualifier list itself
                    const qualifierPlayerNames = [];

                    const tryAddQualifier = (name) => {
                        if (!name) return;
                        const p = byName(name);
                        if (p && !used.has(p.name)) {
                            qualifierPlayerNames.push(p);
                            used.add(p.name);
                        }
                    };

                    (qData.tc || []).forEach(tryAddQualifier);
                    (qData.host || []).forEach(tryAddQualifier);
                    (qData.nb || []).forEach(tryAddQualifier);
                    (qData.east || []).forEach(tryAddQualifier);

                    // Fill remaining qualifier slots from Pro Tour OOM (if not enough from dedicated qualifiers)
                    rankPro(PLAYERS_DB.filter(p => p.tourCard)).forEach(p => {
                        if (qualifierPlayerNames.length < 16 && !used.has(p.name)) {
                            qualifierPlayerNames.push(p);
                            used.add(p.name);
                        }
                    });

                    // If still not enough, backfill from main OOM
                    rankMain(PLAYERS_DB.filter(p => p.tourCard)).forEach(p => {
                        if (qualifierPlayerNames.length < 16 && !used.has(p.name)) {
                            qualifierPlayerNames.push(p);
                            used.add(p.name);
                        }
                    });

                    // Add all qualified players to tournament selection
                    seeds.forEach(p => Tournament.state.selectedPlayerIndices.add(PLAYERS_DB.indexOf(p)));
                    proTourQualifiers.forEach(p => Tournament.state.selectedPlayerIndices.add(PLAYERS_DB.indexOf(p)));
                    qualifierPlayerNames.forEach(p => Tournament.state.selectedPlayerIndices.add(PLAYERS_DB.indexOf(p)));

                    console.log(`[European Tour] Seeds: ${seeds.length}, Pro Tour: ${proTourQualifiers.length}, Qualifiers: ${qualifierPlayerNames.length}, Total selected: ${Tournament.state.selectedPlayerIndices.size}`);

                    if (Tournament.state.selectedPlayerIndices.size < ev.players) {
                        alert(`Warning: Not enough players for European Tour (need ${ev.players}, have ${Tournament.state.selectedPlayerIndices.size})`);
                    }

                    // Set tournament config for 48-player European Tour bracket
                    const formats = ROUND_FORMATS['minor'];
                    Tournament.config.rounds = [
                        { name: 'L48', target: formats?.L48 || 6 },
                        { name: 'L32', target: formats?.L32 || 6 },
                        { name: 'L16', target: formats?.L16 || 6 },
                        { name: 'QF', target: formats?.QF || 6 },
                        { name: 'SF', target: formats?.SF || 7 },
                        { name: 'F', target: formats?.F || 8 }
                    ];
                    Tournament.config.tiebreak = false;

                    Tournament.setSelectionMethod('manual');
                    Tournament.updateConfigUI();
                    Tournament.start();
                    if (autoSimIfRequested()) return;
                    return;
                }

                // =======================
                // CHALLENGE TOUR FILL
                // =======================
                if (ev.type === "challenge") {
                    // Pool is already filtered to non-tour card players above (line ~12740)
                    // Shuffle pool
                    const challengePool = [...pool]; // Copy pool
                    for (let i = challengePool.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [challengePool[i], challengePool[j]] = [challengePool[j], challengePool[i]];
                    }

                    // Add selected players to indices
                    challengePool.slice(0, ev.players).forEach(p => {
                        const idx = PLAYERS_DB.indexOf(p);
                        if (idx >= 0) {
                            Tournament.state.selectedPlayerIndices.add(idx);
                        } else {
                            console.error('Challenge Tour: Player not found in PLAYERS_DB:', p?.name);
                        }
                    });

                    console.log(`Challenge Tour: Added ${Tournament.state.selectedPlayerIndices.size} players from pool`);

                    // Backfill with generated players if short
                    const needed = ev.players - Tournament.state.selectedPlayerIndices.size;
                    if (needed > 0) {
                        console.log(`Challenge Tour: Generating ${needed} additional players`);
                        for (let i = 0; i < needed; i++) {
                            const newIdx = PlayerState.generateRandomPlayer(ev.type, null);
                            if (newIdx >= 0 && newIdx < PLAYERS_DB.length) {
                                Tournament.state.selectedPlayerIndices.add(newIdx);
                                console.log(`Generated player ${i + 1}/${needed}: ${PLAYERS_DB[newIdx]?.name} (idx ${newIdx})`);
                            } else {
                                console.error(`Failed to generate player ${i + 1}/${needed} for Challenge Tour`);
                                break;
                            }
                        }
                    }

                    // Final check
                    console.log(`Challenge Tour: Final count ${Tournament.state.selectedPlayerIndices.size}/${ev.players}`);
                    if (Tournament.state.selectedPlayerIndices.size < ev.players) {
                        console.warn(`Challenge Tour: Could not fill ${ev.players} players, only got ${Tournament.state.selectedPlayerIndices.size}`);
                    }
                }
                // ========================
                // 4. MINDEN M√ÅS EVENT
                // ========================
                else {
                    pool.sort((a, b) => (Season.state.orderOfMerit[b.name] || 0) - (Season.state.orderOfMerit[a.name] || 0));
                    pool.slice(0, ev.players).forEach(p => {
                        Tournament.state.selectedPlayerIndices.add(PLAYERS_DB.indexOf(p));
                    });

                    let attempts = 0;
                    while (Tournament.state.selectedPlayerIndices.size < ev.players && attempts < 2000) {
                        const rand = pool[Math.floor(Math.random() * pool.length)];
                        Tournament.state.selectedPlayerIndices.add(PLAYERS_DB.indexOf(rand));
                        attempts++;
                    }
                }

                // ========================
                // FINAL BACKFILL: Generate random players if still short
                // ========================
                if (Tournament.state.selectedPlayerIndices.size < ev.players && ev.type !== "challenge") {
                    const shortage = ev.players - Tournament.state.selectedPlayerIndices.size;
                    const usedIndices = new Set(Tournament.state.selectedPlayerIndices);
                    for (let i = 0; i < shortage; i++) {
                        let newPlayerIdx = -1;
                        if (ev.name && ev.name.includes("AFRICAN")) {
                            newPlayerIdx = PlayerState.generateRandomAfricanPlayer();
                        } else if (ev.name && ev.name.includes("INDIA")) {
                            newPlayerIdx = PlayerState.generateRandomIndianPlayer();
                        } else {
                            newPlayerIdx = PlayerState.generateRandomPlayer(ev.type, ev.region);
                        }
                        if (newPlayerIdx >= 0) {
                            Tournament.state.selectedPlayerIndices.add(newPlayerIdx);
                        }
                    }
                }

                // ========================
                // 5. FINAL SETUP
                // ========================
                if (ev.type !== "uk-open") {
                    Tournament.setSelectionMethod('manual');
                    Tournament.updateConfigUI();
                }

                Season.state.inProgress = true;
                Persistence.save();


                // ========================
                // ROUND FORMAT FROM TYPE
                // ========================
                const roundFormats = ROUND_FORMATS[ev.type];

                if (roundFormats) {
                    const rounds = [];
                    let players = ev.players;

                    while (players >= 2) {
                        const key =
                            players === 256 ? "L256" :
                                players === 128 ? "L128" :
                                    players === 64 ? "L64" :
                                        players === 32 ? "L32" :
                                            players === 16 ? "L16" :
                                                players === 8 ? "QF" :
                                                    players === 4 ? "SF" :
                                                        players === 2 ? "F" : null;

                        if (key && roundFormats[key]) {
                            rounds.push({
                                name: key,
                                target: roundFormats[key]
                            });
                        }

                        players = players / 2;
                    }

                    Tournament.config.rounds = rounds;
                }

                // ========================
                // TOURNAMENT-SPECIFIC CONFIG
                // ========================
                if (ev.type === 'world' || ev.type === 'matchplay') {
                    Tournament.config.tiebreak = true;
                }

                Tournament.start();

                if (isSim) {
                    // Fast sim without per-round animations, but still show final winner
                    Season.silentSimulation = true;
                    Tournament.skipAdvancementAnimation = true;
                    Tournament.forceShowFinalAnimation = false;
                    Tournament.simulateToEnd();
                    Tournament.skipAdvancementAnimation = false;
                    Tournament.forceShowFinalAnimation = false;
                    Season.silentSimulation = false;
                } else {
                    App.switchTab('tourn');
                }
            },

            completeEvent: (finalBracket) => {
                const isBulkSim = Season.isBulkSim || false; // Optimize: Check bulk sim flag
                const stack = new Error().stack.split('\n').slice(1, 4).join('\n');
                if (!isBulkSim) console.log(`[completeEvent CALLED] from:\n${stack}`);

                // Capture current Number 1 for news generation
                const prevNo1 = Object.keys(Season.state.orderOfMerit).sort((a, b) =>
                    (Season.state.orderOfMerit[b] || 0) - (Season.state.orderOfMerit[a] || 0)
                )[0];

                const idx = Season.state.activeEventIndex;
                const ev = Season.events[idx];

                if (Season.handleCareerEventCompletion) {
                    Season.handleCareerEventCompletion(ev);
                }

                // Use prizes from database if available, otherwise fall back to hardcoded PRIZE_STRUCTURE
                let structure;
                if (ev.prizes && typeof ev.prizes === 'object' && Object.keys(ev.prizes).length > 0) {
                    // Convert position keys (like "W", "RU", "SF", etc.) to player counts
                    structure = {};
                    const positionMap = { 'W': 1, '1': 1, 'RU': 2, '2': 2, 'SF': 4, '4': 4, 'QF': 8, '8': 8, 'L16': 16, '16': 16, 'L32': 32, '32': 32, 'L64': 64, '64': 64, 'L128': 128, '128': 128, 'L256': 256, '256': 256 };
                    for (const [pos, amount] of Object.entries(ev.prizes)) {
                        const key = positionMap[pos] || parseInt(pos);
                        if (key) structure[key] = amount;
                    }
                    console.log('[Season.completeEvent] Using prizes from database:', structure);
                } else {
                    structure = PRIZE_STRUCTURE[ev.type] || PRIZE_STRUCTURE['minor'];
                }

                // Helper function to extract player participations and positions
                const getParticipations = () => {
                    const playerPositions = {};

                    // First pass: track all players and their elimination round
                    finalBracket.forEach((round, roundIdx) => {
                        round.forEach(match => {
                            // Track both players in this match
                            if (match.p1 && !playerPositions[match.p1.name]) {
                                // Calculate approximate position based on round (higher round = better position)
                                const playersInRound = round.length * 2;
                                playerPositions[match.p1.name] = {
                                    position: playersInRound,
                                    money: structure[playersInRound] || 0,
                                    roundIdx: roundIdx
                                };
                            }
                            if (match.p2 && !playerPositions[match.p2.name]) {
                                const playersInRound = round.length * 2;
                                playerPositions[match.p2.name] = {
                                    position: playersInRound,
                                    money: structure[playersInRound] || 0,
                                    roundIdx: roundIdx
                                };
                            }

                            // Winner advances, update their position to the next round
                            if (match.winner && roundIdx < finalBracket.length - 1) {
                                const nextRoundPlayers = round.length;
                                playerPositions[match.winner.name] = {
                                    position: nextRoundPlayers,
                                    money: structure[nextRoundPlayers] || 0,
                                    roundIdx: roundIdx + 1
                                };
                            }
                        });
                    });

                    // Final round special handling
                    const finalMatch = finalBracket[finalBracket.length - 1]?.[0];
                    if (finalMatch) {
                        if (finalMatch.winner) {
                            playerPositions[finalMatch.winner.name] = {
                                position: 1,
                                money: structure[1] || 0,
                                roundIdx: finalBracket.length - 1
                            };
                        }
                        const loser = (finalMatch.winner === finalMatch.p1) ? finalMatch.p2 : finalMatch.p1;
                        if (loser) {
                            playerPositions[loser.name] = {
                                position: 2,
                                money: structure[2] || 0,
                                roundIdx: finalBracket.length - 1
                            };
                        }
                    }

                    return playerPositions;
                };

                // ===============================
                // PREMIER LEAGUE ‚Äì Special handling
                // ===============================
                if (ev.type === "premier-league") {
                    console.log(`[completeEvent] Premier League night ${ev.night} completed`);
                    Season.recordPremierLeagueNight(finalBracket);

                    // Check if this was the last night
                    if (ev.night === 16) {
                        console.log(`[completeEvent] League stage complete, moving to playoffs`);
                        // Move to playoffs
                        Season.state.premierLeague.playoffQualifiers = Season.getPremierLeagueQualifiers();
                        Season.state.completedEvents.push({
                            id: ev.id,
                            name: ev.name,
                            winner: "League completed",
                            participations: getParticipations(),
                            date: ev.date
                        });

                        Season.state.activeEventIndex++;
                        // DON'T set inProgress to false here - let the caller handle it via setTimeout to prevent cascade
                        Tournament.state.active = false;

                        if (!isBulkSim) {
                            Persistence.save();
                            // Auto-save to server after tournament completion
                            if (AuthSystem.currentUser) {
                                AuthSystem.saveToCloud().catch(e => console.log('Auto-save failed:', e.message));
                            }
                            Season.state.inProgress = false;
                            document.getElementById('setup-screen').style.display = 'flex';
                            document.getElementById('match-screen').style.display = 'none';
                            document.getElementById('tournament-hub').style.display = 'none';
                            App.switchTab('season');
                            Season.renderUI();
                            Tournament.showCelebration("LEAGUE STAGE COMPLETE", "PLAYOFF QUALIFIERS", Season.state.premierLeague.playoffQualifiers);
                        }
                    } else {
                        // Move to next night
                        console.log(`[completeEvent] Moving to next PL night (currently night ${ev.night})`);
                        Season.state.completedEvents.push({
                            id: ev.id,
                            name: ev.name,
                            winner: finalBracket[2][0].winner.name,
                            participations: getParticipations(),
                            date: ev.date
                        });

                        Season.state.activeEventIndex++;
                        // DON'T set inProgress to false here - let the caller (initializePremierLeague) handle it via setTimeout
                        // This prevents the guard from being bypassed during the transition
                        Tournament.state.active = false;

                        if (!isBulkSim) {
                            Persistence.save();
                            // Auto-save to server after tournament completion
                            if (AuthSystem.currentUser) {
                                AuthSystem.saveToCloud().catch(e => console.log('Auto-save failed:', e.message));
                            }
                            Season.state.inProgress = false;
                            document.getElementById('setup-screen').style.display = 'flex';
                            document.getElementById('match-screen').style.display = 'none';
                            document.getElementById('tournament-hub').style.display = 'none';
                            App.switchTab('season');
                            // Guard is already set in initializePremierLeague
                            console.log(`[completeEvent] Guard status: ${Season.guardAgainstAutoStart}, inProgress: ${Season.state.inProgress}`);
                            console.log(`[completeEvent] About to renderUI, next event idx=${Season.state.activeEventIndex}`);
                            Season.renderUI();
                            console.log(`[completeEvent] renderUI done`);
                        }
                    }
                    return;
                }

                // ===============================
                // PREMIER LEAGUE PLAYOFFS ‚Äì Special handling
                // ===============================
                if (ev.type === "premier-league-playoff") {
                    const finalMatch = finalBracket.at(-1)[0];
                    const winnerName = finalMatch && finalMatch.winner ? finalMatch.winner.name : "Unknown";

                    Season.state.completedEvents.push({
                        id: ev.id,
                        name: ev.name,
                        winner: winnerName,
                        participations: getParticipations(),
                        date: ev.date
                    });

                    // Add win news
                    if (!isBulkSim && winnerName !== "Unknown" && NewsSystem) {
                        const runnerUp = finalMatch.winner === finalMatch.p1 ? finalMatch.p2?.name : finalMatch.p1?.name;
                        const championQuote = NewsSystem.quotes.champion[Math.floor(Math.random() * NewsSystem.quotes.champion.length)];
                        NewsSystem.add('win', {
                            headline: `${winnerName.toUpperCase()} CROWNED PREMIER LEAGUE CHAMPION!`,
                            subtext: runnerUp ? `${winnerName} defeated ${runnerUp} in the final to claim the title. ${championQuote}` : `${winnerName} claims the Premier League title! ${championQuote}`,
                            player: winnerName,
                            event: "Premier League Darts",
                            importance: 'high'
                        });
                    }

                    Season.state.activeEventIndex++;
                    // DON'T set inProgress to false here - let the caller handle it via setTimeout to prevent cascade
                    Tournament.state.active = false;

                    if (!isBulkSim) {
                        Persistence.save();
                        // Auto-save to server after tournament completion
                        if (AuthSystem.currentUser) {
                            AuthSystem.saveToCloud().catch(e => console.log('Auto-save failed:', e.message));
                        }
                        Season.state.inProgress = false;
                        document.getElementById('setup-screen').style.display = 'flex';
                        document.getElementById('match-screen').style.display = 'none';
                        document.getElementById('tournament-hub').style.display = 'none';
                        App.switchTab('season');
                        // Set guard to prevent cascading auto-starts
                        if (!Season.guardAgainstAutoStart) {
                            Season.guardAgainstAutoStart = true;
                        }
                        Season.renderUI();
                        Tournament.showCelebration("PREMIER LEAGUE CHAMPION", winnerName, [winnerName]);
                    }
                    return;
                }

                // ===============================
                // GRAND SLAM ‚Äì Special handling
                // ===============================
                if (ev.type === "grandslam") {
                    // Grand Slam payouts: Groups (index 0 is empty), L16 (1), QF (2), SF (3), F (4)
                    const grandSlamRounds = [
                        { players: 32, name: "Group" },
                        { players: 16, name: "L16" },
                        { players: 8, name: "QF" },
                        { players: 4, name: "SF" },
                        { players: 2, name: "F" }
                    ];

                    const payouts = {};

                    finalBracket.forEach((roundMatches, roundIdx) => {
                        const roundInfo = grandSlamRounds[roundIdx];
                        if (!roundInfo) return;
                        const money = structure[roundInfo.players] || 0;

                        roundMatches.forEach(m => {
                            if (!m.winner) return;
                            const loser = (m.winner === m.p1) ? m.p2 : m.p1;
                            if (loser) payouts[loser.name] = money;
                        });
                    });

                    // Winner prize
                    const finalMatch = finalBracket.at(-1)[0];
                    if (finalMatch && finalMatch.winner) {
                        payouts[finalMatch.winner.name] = structure[1];
                    }

                    // Add to history
                    Season.state.proTourHistory.push({
                        date: ev.date,
                        payouts
                    });

                    if (!isBulkSim) {
                        Season.trimProTourHistory(ev.date);
                        Season.recalculateProTourOOM();
                    }

                    // Complete event
                    const winnerName = finalMatch && finalMatch.winner ? finalMatch.winner.name : "Unknown";
                    Season.state.completedEvents.push({
                        id: ev.id,
                        name: ev.name,
                        winner: winnerName,
                        participations: getParticipations(),
                        date: ev.date
                    });

                    // Add win news
                    if (!isBulkSim && winnerName !== "Unknown" && NewsSystem) {
                        const runnerUp = finalMatch.winner === finalMatch.p1 ? finalMatch.p2?.name : finalMatch.p1?.name;
                        const championQuote = NewsSystem.quotes.champion[Math.floor(Math.random() * NewsSystem.quotes.champion.length)];
                        NewsSystem.add('win', {
                            headline: `${winnerName.toUpperCase()} CROWNED ${ev.name.toUpperCase()} CHAMPION!`,
                            subtext: runnerUp ? `${winnerName} defeated ${runnerUp} in the final to claim the title. ${championQuote}` : `${winnerName} wins! ${championQuote}`,
                            player: winnerName,
                            event: ev.name,
                            importance: 'high'
                        });
                    }

                    Season.state.activeEventIndex++;
                    // DON'T set inProgress to false - let caller manage via guard
                    Tournament.state.active = false;

                    if (!isBulkSim) {
                        Persistence.save();
                        // Auto-save to server after tournament completion
                        if (AuthSystem.currentUser) {
                            AuthSystem.saveToCloud().catch(e => console.log('Auto-save failed:', e.message));
                        }
                        document.getElementById('setup-screen').style.display = 'flex';
                        document.getElementById('match-screen').style.display = 'none';
                        document.getElementById('tournament-hub').style.display = 'none';
                        App.switchTab('season');
                        Season.renderUI();
                    }
                    return;
                }

                // ===============================
                // UK OPEN QUALI ‚Äì TOP 32 ELMENT√âS
                // ===============================
                if (ev.type === "uk-open-quali") {

                    const qualified = new Set();

                    // TOP 32 = round 1 gy≈ëztesei
                    finalBracket[0].forEach(m => {
                        if (m.winner) qualified.add(m.winner.name);
                    });

                    Season.state.ukOpenQualifiers = [...qualified];

                    Season.state.completedEvents.push({
                        id: ev.id,
                        name: ev.name,
                        winner: "Qualifiers decided",
                        participations: getParticipations(),
                        date: ev.date
                    });

                    Season.state.activeEventIndex++;
                    // DON'T set inProgress to false - let caller manage via guard
                    Tournament.state.active = false;

                    if (!isBulkSim) {
                        Persistence.save();
                        // Auto-save to server after tournament completion
                        if (AuthSystem.currentUser) {
                            AuthSystem.saveToCloud().catch(e => console.log('Auto-save failed:', e.message));
                        }
                        // üî• UI RESET (EZ HI√ÅNYZOTT)
                        document.getElementById('setup-screen').style.display = 'flex';
                        document.getElementById('match-screen').style.display = 'none';
                        document.getElementById('tournament-hub').style.display = 'none';
                        App.switchTab('season');
                        Season.renderUI();
                    }
                    return;
                }

                // ================= ET QUALIFIER STORAGE =================
                if (ev.type === "et-qual-tc" || ev.type === "et-host-nation" || ev.type === "et-east-european" || ev.type === "et-nordic-baltic") {
                    const target = ev.targetEvent;
                    const slots = ev.slots || 8;

                    if (!Season.state.etQualifiers) {
                        Season.state.etQualifiers = {};
                    }
                    if (!Season.state.etQualifiers[target]) {
                        Season.state.etQualifiers[target] = { tc: [], host: [], nb: [], east: [] };
                    }

                    const store = Season.state.etQualifiers[target];

                    const positions = getParticipations();
                    const sorted = Object.entries(positions)
                        .sort((a, b) => a[1].position - b[1].position)
                        .map(e => e[0]);

                    const qualifiedPlayers = sorted.slice(0, slots);

                    if (ev.type === "et-qual-tc") store.tc = qualifiedPlayers;
                    if (ev.type === "et-host-nation") store.host = qualifiedPlayers;
                    if (ev.type === "et-nordic-baltic") store.nb = qualifiedPlayers;
                    if (ev.type === "et-east-european") store.east = qualifiedPlayers;

                    const targetEvent = Season.events.find(e => e.id === target);
                    const targetName = targetEvent ? targetEvent.name : `Event ${target}`;
                    if (!Season.isBulkSim) {
                        Tournament.showCelebration("QUALIFIED", targetName, qualifiedPlayers);
                    }

                    Season.state.completedEvents.push({
                        id: ev.id,
                        name: ev.name,
                        winner: qualifiedPlayers[0] || "Qualifiers decided",
                        participations: positions,
                        date: ev.date
                    });

                    Season.state.activeEventIndex++;
                    // DON'T set inProgress to false - let caller manage via guard
                    Tournament.state.active = false;

                    if (!isBulkSim) {
                        Persistence.save();
                        // Auto-save to server after tournament completion
                        if (AuthSystem.currentUser) {
                            AuthSystem.saveToCloud().catch(e => console.log('Auto-save failed:', e.message));
                        }
                        document.getElementById('setup-screen').style.display = 'flex';
                        document.getElementById('match-screen').style.display = 'none';
                        document.getElementById('tournament-hub').style.display = 'none';
                        App.switchTab('season');
                        Season.renderUI();
                    }
                    return;
                }

                // ================= WC QUALIFIER STORAGE =================
                if (ev.type === "wc-qual-intl" || ev.type === "wc-qual-tc") {
                    const slots = ev.slots || 1;

                    // Initialize wcQualified structure if needed
                    if (!Season.state.wcQualified) {
                        Season.state.wcQualified = { qualifiers: new Set(), internationalQualifiers: [] };
                    }
                    if (!Season.state.wcQualified.internationalQualifiers) {
                        Season.state.wcQualified.internationalQualifiers = [];
                    }

                    const positions = getParticipations();
                    const sorted = Object.entries(positions)
                        .sort((a, b) => a[1].position - b[1].position)
                        .map(e => e[0]);

                    const qualifiedPlayers = sorted.slice(0, slots);

                    // Add qualified players to the WC international qualifiers list
                    qualifiedPlayers.forEach(name => {
                        if (!Season.state.wcQualified.internationalQualifiers.includes(name)) {
                            Season.state.wcQualified.internationalQualifiers.push(name);
                        }
                    });

                    if (!Season.isBulkSim) {
                        Tournament.showCelebration("QUALIFIED FOR WORLD CHAMPIONSHIP", ev.name, qualifiedPlayers);
                    }

                    Season.state.completedEvents.push({
                        id: ev.id,
                        name: ev.name,
                        winner: qualifiedPlayers[0] || "Qualifiers decided",
                        participations: positions,
                        date: ev.date
                    });

                    Season.state.activeEventIndex++;
                    Tournament.state.active = false;

                    if (!isBulkSim) {
                        Persistence.save();
                        // Auto-save to server after tournament completion
                        if (AuthSystem.currentUser) {
                            AuthSystem.saveToCloud().catch(e => console.log('Auto-save failed:', e.message));
                        }
                        document.getElementById('setup-screen').style.display = 'flex';
                        document.getElementById('match-screen').style.display = 'none';
                        document.getElementById('tournament-hub').style.display = 'none';
                        App.switchTab('season');
                        Season.renderUI();
                    }
                    return;
                }

                // ================= WS & GS QUALIFIER STORAGE =================
                if (ev.type === "ws-qual-tc" || ev.type === "gs-qual-tc") {
                    const qualStore = ev.type === "ws-qual-tc" ? "wsQualifiers" : "gsQualifiers";
                    const target = ev.targetEvent;
                    const slots = ev.slots || 8;

                    if (!Season.state[qualStore]) {
                        Season.state[qualStore] = {};
                    }
                    if (!Season.state[qualStore][target]) {
                        Season.state[qualStore][target] = [];
                    }

                    const positions = getParticipations();
                    const sorted = Object.entries(positions)
                        .sort((a, b) => a[1].position - b[1].position)
                        .map(e => e[0]);

                    const qualifiedPlayers = sorted.slice(0, slots);
                    Season.state[qualStore][target] = qualifiedPlayers;

                    const targetEvent = Season.events.find(e => e.id === target);
                    const targetName = targetEvent ? targetEvent.name : `Event ${target}`;
                    if (!Season.isBulkSim) {
                        Tournament.showCelebration("QUALIFIED", targetName, qualifiedPlayers);
                    }

                    Season.state.completedEvents.push({
                        id: ev.id,
                        name: ev.name,
                        winner: qualifiedPlayers[0] || "Qualifiers decided",
                        participations: positions,
                        date: ev.date
                    });

                    Season.state.activeEventIndex++;
                    // DON'T set inProgress to false - let caller manage via guard
                    Tournament.state.active = false;

                    if (!isBulkSim) {
                        Persistence.save();
                        // Auto-save to server after tournament completion
                        if (AuthSystem.currentUser) {
                            AuthSystem.saveToCloud().catch(e => console.log('Auto-save failed:', e.message));
                        }
                        document.getElementById('setup-screen').style.display = 'flex';
                        document.getElementById('match-screen').style.display = 'none';
                        document.getElementById('tournament-hub').style.display = 'none';
                        App.switchTab('season');
                        Season.renderUI();
                    }
                    return;
                }

                // ================= WINMAU MASTERS QUALIFIER STORAGE =================
                if (ev.type === "wmasters-qual") {
                    const target = ev.targetEvent;
                    const slots = ev.slots || 8;

                    if (!Season.state.wmQualifiers) {
                        Season.state.wmQualifiers = {};
                    }
                    if (!Season.state.wmQualifiers[target]) {
                        Season.state.wmQualifiers[target] = [];
                    }

                    const positions = getParticipations();
                    const sorted = Object.entries(positions)
                        .sort((a, b) => a[1].position - b[1].position)
                        .map(e => e[0]);

                    const qualifiedPlayers = sorted.slice(0, slots);
                    Season.state.wmQualifiers[target] = qualifiedPlayers;

                    const targetEvent = Season.events.find(e => e.id === target);
                    const targetName = targetEvent ? targetEvent.name : `Event ${target}`;
                    if (!Season.isBulkSim) {
                        Tournament.showCelebration("QUALIFIED", targetName, qualifiedPlayers);
                    }

                    Season.state.completedEvents.push({
                        id: ev.id,
                        name: ev.name,
                        winner: qualifiedPlayers[0] || "Qualifiers decided",
                        participations: positions,
                        date: ev.date
                    });
                    Season.state.activeEventIndex++;
                    // DON'T set inProgress to false - let caller manage via guard
                    Tournament.state.active = false;

                    if (!isBulkSim) {
                        Persistence.save();
                        // Auto-save to server after tournament completion
                        if (AuthSystem.currentUser) {
                            AuthSystem.saveToCloud().catch(e => console.log('Auto-save failed:', e.message));
                        }
                        document.getElementById('setup-screen').style.display = 'flex';
                        document.getElementById('match-screen').style.display = 'none';
                        document.getElementById('tournament-hub').style.display = 'none';
                        App.switchTab('season');
                        Season.renderUI();
                    }
                    return;
                }




                // ================= WORLD SERIES OOM =================
                if (ev.type === "masters" || ev.type === "masters-final") {

                    finalBracket.forEach((roundMatches, roundIdx) => {
                        const playersInRound = ev.players / Math.pow(2, roundIdx);
                        const pts = WORLD_SERIES_POINTS[playersInRound] || 0;

                        roundMatches.forEach(m => {
                            if (!m.winner) return;
                            const loser = (m.winner === m.p1) ? m.p2 : m.p1;
                            if (loser) {
                                Season.state.worldSeriesOOM[loser.name] =
                                    (Season.state.worldSeriesOOM[loser.name] || 0) + pts;
                            }
                        });
                    });

                    // Winner extra
                    const finalMatch = finalBracket.at(-1)[0];
                    if (finalMatch.winner) {
                        Season.state.worldSeriesOOM[finalMatch.winner.name] =
                            (Season.state.worldSeriesOOM[finalMatch.winner.name] || 0) + WORLD_SERIES_POINTS[1];

                    }

                    // History
                    Season.state.worldSeriesHistory.push({
                        date: ev.date,
                        event: ev.name,
                        bracket: finalBracket
                    });
                }


                // ================= MAIN OOM PAYOUT =================
                finalBracket.forEach((roundMatches, roundIdx) => {
                    const playersInRound = ev.players / Math.pow(2, roundIdx);
                    const loserMoney = structure[playersInRound] || 0;

                    roundMatches.forEach(m => {
                        if (!m.winner) return;

                        const loser = (m.winner === m.p1) ? m.p2 : m.p1;
                        if (loser) {
                            // Initialize if not in OOM yet (for non-tour card holders winning money)
                            if (Season.state.orderOfMerit[loser.name] === undefined) {
                                Season.state.orderOfMerit[loser.name] = 0;
                            }
                            Season.state.orderOfMerit[loser.name] += loserMoney;

                            // Update career balance if this is the career player
                            Season.ensureCareerState();
                            const careerPlayer = Season.getCareerPlayer();
                            if (careerPlayer && careerPlayer.name === loser.name) {
                                Season.state.career.balance = (Season.state.career.balance || 0) + loserMoney;
                            }
                        }
                    });
                });

                // Winner money (MAIN OOM)
                const finalRound = finalBracket[finalBracket.length - 1] || [];
                const finalPlayedMatch = finalRound.find(m => m && m.winner) || finalRound[0];
                const championName = finalPlayedMatch && finalPlayedMatch.winner ? finalPlayedMatch.winner.name : "Unknown";
                if (finalPlayedMatch && finalPlayedMatch.winner) {
                    // Initialize if not in OOM yet (for non-tour card holders winning money)
                    if (Season.state.orderOfMerit[championName] === undefined) {
                        Season.state.orderOfMerit[championName] = 0;
                    }
                    Season.state.orderOfMerit[championName] += structure[1];

                    // Update career balance if this is the career player
                    Season.ensureCareerState();
                    const careerPlayer = Season.getCareerPlayer();
                    if (careerPlayer && careerPlayer.name === championName) {
                        Season.state.career.balance = (Season.state.career.balance || 0) + structure[1];
                    }
                }

                // ================= PRO TOUR OOM =================
                if (ev.type === "players" || ev.type === "minor") {

                    const payouts = {};

                    finalBracket.forEach((roundMatches, roundIdx) => {
                        const playersInRound = ev.players / Math.pow(2, roundIdx);
                        const money = structure[playersInRound] || 0;

                        roundMatches.forEach(m => {
                            if (!m.winner) return;
                            const loser = (m.winner === m.p1) ? m.p2 : m.p1;
                            if (loser) payouts[loser.name] = money;
                        });
                    });

                    // winner
                    payouts[championName] = structure[1];

                    Season.state.proTourHistory.push({
                        date: ev.date,
                        payouts
                    });

                    Season.trimProTourHistory(ev.date);
                    Season.recalculateProTourOOM();
                }
                // ================= CHALLENGE TOUR OOM =================
                if (ev.type === "challenge") {

                    const payouts = {};

                    finalBracket.forEach((roundMatches, roundIdx) => {
                        const playersInRound = ev.players / Math.pow(2, roundIdx);
                        const money = structure[playersInRound] || 0;

                        roundMatches.forEach(m => {
                            if (!m.winner) return;
                            const loser = (m.winner === m.p1) ? m.p2 : m.p1;
                            if (loser) payouts[loser.name] = money;
                        });
                    });

                    // winner
                    payouts[championName] = structure[1];

                    Season.state.challengeTourHistory.push({
                        date: ev.date,
                        payouts
                    });

                    if (!isBulkSim) {
                        Season.recalculateChallengeTourOOM();
                    }
                }

                // ================= Q-SCHOOL TOUR CARD =================
                if (ev.type === "q-school") {
                    const location = ev.location; // 'uk' or 'eu'
                    const eventName = ev.name;
                    const isFinalStage = eventName.includes("Final Stage");
                    const isFirstStage = eventName.includes("First Stage");
                    const oom = location === 'uk' ? Season.state.qSchool.ukOOM : Season.state.qSchool.euOOM;
                    const finalStageWinners = location === 'uk' ? Season.state.qSchool.ukFinalStageWinners : Season.state.qSchool.euFinalStageWinners;
                    const qualified = location === 'uk' ? Season.state.qSchool.ukFinalStageQualified : Season.state.qSchool.euFinalStageQualified;
                    const participants = location === 'uk' ? Season.state.qSchool.ukParticipants : Season.state.qSchool.euParticipants;
                    const tourCardWinners = location === 'uk' ? Season.state.qSchool.ukTourCardWinners : Season.state.qSchool.euTourCardWinners;

                    // Track all players who participated in this event (for both First and Final Stage)
                    finalBracket.forEach((round) => {
                        round.forEach(match => {
                            if (match.p1 && !participants.includes(match.p1.name)) participants.push(match.p1.name);
                            if (match.p2 && !participants.includes(match.p2.name)) participants.push(match.p2.name);
                        });
                    });

                    // If this is first Final Stage event, re-add qualified players to OOM with 0 points
                    if (isFinalStage && qualified.length > 0 && Object.keys(oom).length < qualified.length) {
                        qualified.forEach(playerName => {
                            if (!(playerName in oom)) {
                                oom[playerName] = 0;
                            }
                        });
                    }

                    // Award 1 point per match win for ALL rounds
                    finalBracket.forEach((round, roundIdx) => {
                        round.forEach(match => {
                            if (match.winner) {
                                const winnerName = match.winner.name;
                                oom[winnerName] = (oom[winnerName] || 0) + 1; // 1 point per match win
                            }
                        });
                    });

                    let firstStageMadeIt = [];
                    let tourCardAwarded = [];

                    // If Final Stage, both finalists get Tour Cards
                    if (isFinalStage) {
                        const finalMatch = finalBracket[finalBracket.length - 1][0];
                        if (finalMatch.p1) {
                            const pIdx = PLAYERS_DB.findIndex(p => p.name === finalMatch.p1.name);
                            if (pIdx > -1) {
                                PLAYERS_DB[pIdx].tourCard = true;
                                tourCardAwarded.push(finalMatch.p1.name);
                            }
                            finalStageWinners.push(finalMatch.p1.name);
                            if (!tourCardWinners.includes(finalMatch.p1.name)) tourCardWinners.push(finalMatch.p1.name);
                        }
                        if (finalMatch.p2) {
                            const pIdx = PLAYERS_DB.findIndex(p => p.name === finalMatch.p2.name);
                            if (pIdx > -1) {
                                PLAYERS_DB[pIdx].tourCard = true;
                                tourCardAwarded.push(finalMatch.p2.name);
                            }
                            finalStageWinners.push(finalMatch.p2.name);
                            if (!tourCardWinners.includes(finalMatch.p2.name)) tourCardWinners.push(finalMatch.p2.name);
                        }

                        // Update counters
                        if (location === 'uk') Season.state.qSchool.ukTourCards += tourCardAwarded.length;
                        else Season.state.qSchool.euTourCards += tourCardAwarded.length;

                        if (!Season.isBulkSim) {
                            Tournament.showCelebration("TOUR CARDS AWARDED", location.toUpperCase(), tourCardAwarded);
                        }

                        // After the final day of Final Stage, award OOM tour cards (UK: top 5, EU: top 8) excluding existing tour-card winners/finalists
                        if (eventName.includes("Final Stage Day 4")) {
                            const extraWinners = [];
                            const taken = new Set([...finalStageWinners, ...tourCardWinners]);
                            const maxExtras = location === 'eu' ? 8 : 5;

                            Object.entries(oom)
                                .sort((a, b) => b[1] - a[1])
                                .forEach(([name]) => {
                                    if (extraWinners.length >= maxExtras) return;
                                    if (taken.has(name)) return;
                                    const idx = PLAYERS_DB.findIndex(p => p.name === name);
                                    if (idx > -1 && !PLAYERS_DB[idx].tourCard) {
                                        PLAYERS_DB[idx].tourCard = true;
                                        extraWinners.push(name);
                                        taken.add(name);
                                        if (!tourCardWinners.includes(name)) tourCardWinners.push(name);
                                    }
                                });

                            if (extraWinners.length > 0) {
                                if (location === 'uk') Season.state.qSchool.ukTourCards += extraWinners.length;
                                else Season.state.qSchool.euTourCards += extraWinners.length;

                                if (!Season.isBulkSim) {
                                    Tournament.showCelebration("OOM TOUR CARDS", location.toUpperCase(), extraWinners);
                                }
                            }
                        }
                    } else if (isFirstStage) {
                        // Get top 16 by points from OOM - these qualify for Final Stage
                        const topQualifiers = Object.entries(oom)
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 16)
                            .map(entry => entry[0]);

                        // Store qualified players
                        if (location === 'uk') Season.state.qSchool.ukFinalStageQualified = topQualifiers;
                        else Season.state.qSchool.euFinalStageQualified = topQualifiers;

                        // Reset OOM points for Final Stage
                        Object.keys(oom).forEach(player => oom[player] = 0);

                        if (!Season.isBulkSim) {
                            Tournament.showCelebration("QUALIFIED TO FINAL STAGE", location.toUpperCase(), topQualifiers);
                        }
                    }
                }

                // ================= SEASON STATE =================
                // Replace any prior record for this event id to avoid stale winners
                Season.state.completedEvents = Season.state.completedEvents.filter(e => e.id !== ev.id);
                Season.state.completedEvents.push({
                    id: ev.id,
                    name: ev.name,
                    winner: championName,
                    participations: getParticipations(),
                    date: ev.date
                });

                // ================= NEWS: TOURNAMENT WIN =================
                console.log('[completeEvent] Checking tournament win news:', {
                    championName,
                    hasNewsSystem: !!NewsSystem,
                    NewsSystemExists: typeof NewsSystem,
                    windowNewsSystem: typeof window.NewsSystem
                });
                if (!isBulkSim && championName && NewsSystem) {
                    const finalMatch = finalBracket[finalBracket.length - 1]?.[0];
                    const runnerUp = finalMatch ? (finalMatch.winner === finalMatch.p1 ? finalMatch.p2?.name : finalMatch.p1?.name) : "Unknown";

                    console.log('[completeEvent] About to add win news for', championName, 'vs', runnerUp);
                    const championQuote = NewsSystem.quotes.champion[Math.floor(Math.random() * NewsSystem.quotes.champion.length)];
                    NewsSystem.add('win', {
                        headline: `${championName.toUpperCase()} CROWNED ${ev.name.toUpperCase()} CHAMPION!`,
                        subtext: runnerUp ? `In a thrilling final, ${championName} defeated ${runnerUp} to lift the trophy. ${championQuote}` : `${championName} claims victory! ${championQuote}`,
                        player: championName,
                        event: ev.name,
                        importance: 'high'
                    });
                }

                Season.state.activeEventIndex++;
                Season.state.inProgress = false;
                Tournament.state.active = false;

                // Check for Number 1 change
                const newNo1 = Object.keys(Season.state.orderOfMerit).sort((a, b) =>
                    (Season.state.orderOfMerit[b] || 0) - (Season.state.orderOfMerit[a] || 0)
                )[0];

                if (!isBulkSim && newNo1 && prevNo1 && newNo1 !== prevNo1) {
                    if (NewsSystem) {
                        NewsSystem.add('rank', {
                            headline: `NEW WORLD NUMBER ONE!`,
                            subtext: `${newNo1} has overtaken ${prevNo1} at the top of the Order of Merit following the ${ev.name}.`,
                            player: newNo1,
                            importance: 10
                        });
                    }
                }

                Persistence.save();

                // Auto-save to server after tournament completion
                if (AuthSystem.currentUser) {
                    AuthSystem.saveToCloud().catch(e => console.log('Auto-save failed:', e.message));
                }

                document.getElementById('setup-screen').style.display = 'flex';
                document.getElementById('match-screen').style.display = 'none';
                document.getElementById('tournament-hub').style.display = 'none';

                App.switchTab('season');
                Season.renderUI();
            },
            trimProTourHistory: (date) => {
                const cutoff = new Date(date);
                cutoff.setMonth(cutoff.getMonth() - 12);

                Season.state.proTourHistory = Season.state.proTourHistory.filter(
                    e => new Date(e.date) >= cutoff
                );
            },

            recalculateProTourOOM: () => {
                // Optimize: Only initialize players that have earned points
                const oom = {};

                Season.state.proTourHistory.forEach(ev => {
                    for (let name in ev.payouts) {
                        oom[name] = (oom[name] || 0) + ev.payouts[name];
                    }
                });

                Season.state.proTourOOM = oom;
            },

            recalculateChallengeTourOOM: () => {
                // Optimize: Only initialize players that have earned points
                const oom = {};

                Season.state.challengeTourHistory.forEach(ev => {
                    for (let name in ev.payouts) {
                        oom[name] = (oom[name] || 0) + ev.payouts[name];
                    }
                });

                Season.state.challengeTourOOM = oom;
            },

            initializePremierLeague: (eventIdx, ev, isSim) => {
                Season.state.inProgress = true;
                Tournament.state.active = true;
                if (isSim) {
                    // Set guard IMMEDIATELY to prevent any cascade simulations
                    Season.guardAgainstAutoStart = true;
                    console.log(`[initializePremierLeague] Guard set to true at start of sim`);
                    Season.silentSimulation = true;
                    Tournament.skipAdvancementAnimation = true;
                }

                const night = ev.night;

                // PLAYOFF VERSION
                if (ev.type === "premier-league-playoff") {
                    // Select playoff qualifiers
                    Tournament.state.selectedPlayerIndices.clear();
                    const qualifiers = Season.state.premierLeague.playoffQualifiers;

                    qualifiers.forEach(name => {
                        const idx = PLAYERS_DB.findIndex(p => p.name === name);
                        if (idx > -1) {
                            Tournament.state.selectedPlayerIndices.add(idx);
                        }
                    });

                    if (Season.applyCareerParticipationToSelection) {
                        Season.applyCareerParticipationToSelection(ev);
                    }

                    // Set up tournament
                    Tournament.config.eventType = ev.type;
                    Tournament.config.eventPlayers = 4;
                    Tournament.setMode('legs');
                    Tournament.config.tiebreak = false;

                    document.getElementById('tourn-event-name').value = ev.name;
                    document.getElementById('tourn-size').value = 4;

                    // Playoff format: Best of 21 legs (First to 11) for both SF and F
                    Tournament.config.rounds = [
                        { name: "SF", target: 11 },
                        { name: "F", target: 11 }
                    ];

                    // Get standings to seed playoff (1st plays 4th, 2nd plays 3rd)
                    const standings = Object.entries(Season.state.premierLeague.standings)
                        .sort((a, b) => {
                            if (b[1].points !== a[1].points) return b[1].points - a[1].points;
                            return (b[1].finalWins - a[1].finalWins) - (b[1].semiFinalFinishes - a[1].semiFinalFinishes);
                        });

                    const seed1 = PLAYERS_DB.find(p => p.name === standings[0][0]);
                    const seed2 = PLAYERS_DB.find(p => p.name === standings[1][0]);
                    const seed3 = PLAYERS_DB.find(p => p.name === standings[2][0]);
                    const seed4 = PLAYERS_DB.find(p => p.name === standings[3][0]);

                    Tournament.state.currentActiveRound = 0;
                    Tournament.state.viewingRound = 0;
                    Tournament.state.matchQueue = [];
                    Tournament.state.bracketData = [];

                    // Playoff seeding: 1 vs 4, 2 vs 3
                    const r0 = [
                        { p1: seed1, p2: seed4, winner: null, score: null, averages: null },
                        { p1: seed2, p2: seed3, winner: null, score: null, averages: null }
                    ];

                    Tournament.state.bracketData.push(r0);
                    Tournament.state.bracketData.push([]); // Final

                    Persistence.save();
                    requestWakeLock();

                    if (isSim) {
                        // Simulate all playoff rounds
                        while (Tournament.state.currentActiveRound < Tournament.config.rounds.length && Tournament.state.active) {
                            Tournament.simulateRound();
                        }
                        // After all rounds are done, complete the event
                        Tournament.state.active = false;
                        Season.guardAgainstAutoStart = true;
                        const bracketToComplete = JSON.parse(JSON.stringify(Tournament.state.bracketData)); // Deep copy before clearing
                        Season.completeEvent(bracketToComplete);

                        // Clear tournament state IMMEDIATELY to prevent bracket data carryover
                        Tournament.state.bracketData = [];
                        Tournament.state.currentActiveRound = 0;
                        Tournament.state.viewingRound = 0;
                        Tournament.state.matchQueue = [];
                        Tournament.state.selectedPlayerIndices.clear();

                        Tournament.skipAdvancementAnimation = false;
                        Season.silentSimulation = false;

                        // Reset flags immediately for Sim mode to allow simulateRemainingSeason to continue
                        Season.state.inProgress = false;
                        Season.guardAgainstAutoStart = false;
                    } else {
                        document.getElementById('setup-screen').style.display = 'none';
                        document.getElementById('tourn-hub-title').innerText = ev.name;
                        Tournament.renderHub();
                    }
                    return;
                }

                // LEAGUE NIGHT VERSION
                // Initialize standings on first night
                if (night === 1) {
                    Season.state.premierLeague.currentNight = 1;
                    Season.state.premierLeague.standings = {};
                    Season.state.premierLeague.matchResults = [];

                    Season.state.premierLeague.players.forEach(name => {
                        Season.state.premierLeague.standings[name] = {
                            wins: 0, losses: 0, points: 0,
                            finalWins: 0, runnerUpFinishes: 0, semiFinalFinishes: 0,
                            money: 0
                        };
                    });

                    if (!Season.silentSimulation) {
                        alert(`üèÜ PREMIER LEAGUE 2026\n\nLineup:\n${Season.state.premierLeague.players.join('\n')}`);
                    }
                }

                Season.state.premierLeague.currentNight = night;

                // Select all Premier League players
                Tournament.state.selectedPlayerIndices.clear();
                Season.state.premierLeague.players.forEach(name => {
                    const idx = PLAYERS_DB.findIndex(p => p.name === name);
                    if (idx > -1) {
                        Tournament.state.selectedPlayerIndices.add(idx);
                    }
                });

                if (Season.applyCareerParticipationToSelection) {
                    Season.applyCareerParticipationToSelection(ev);
                }

                // Set up tournament
                Tournament.config.eventType = ev.type;
                Tournament.config.eventPlayers = 8;
                Tournament.setMode('legs');
                Tournament.config.tiebreak = false;

                document.getElementById('tourn-event-name').value = ev.name;
                document.getElementById('tourn-size').value = 8;

                // Premier League format: Best of 11 legs (First to 6)
                Tournament.config.rounds = [
                    { name: "QF", target: 6 },
                    { name: "SF", target: 6 },
                    { name: "F", target: 6 }
                ];

                // Start regular tournament
                const participants = [];
                Tournament.state.selectedPlayerIndices.forEach(idx => {
                    participants.push({ ...PLAYERS_DB[idx] });
                });

                // Shuffle for night randomness
                for (let i = participants.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [participants[i], participants[j]] = [participants[j], participants[i]];
                }

                Tournament.state.currentActiveRound = 0;
                Tournament.state.viewingRound = 0;
                Tournament.state.matchQueue = [];
                Tournament.state.bracketData = [];

                const r0 = [];
                for (let i = 0; i < participants.length; i += 2) {
                    r0.push({ p1: participants[i], p2: participants[i + 1], winner: null, score: null, averages: null });
                }

                Tournament.state.bracketData.push(r0);
                for (let i = 1; i < 3; i++) {
                    Tournament.state.bracketData.push([]);
                }

                Persistence.save();
                requestWakeLock();

                if (isSim) {
                    console.log(`[PL SIM] Starting PL night ${night}, ${ev.players} players`);
                    // Simulate all rounds for Premier League night
                    while (Tournament.state.currentActiveRound < Tournament.config.rounds.length && Tournament.state.active) {
                        Tournament.simulateRound();
                    }
                    // After all rounds are done, complete the event
                    console.log(`[PL SIM] Completed simulation, calling completeEvent`);
                    Tournament.state.active = false;
                    // Guard is already set at the beginning of initializePremierLeague
                    const bracketToComplete = JSON.parse(JSON.stringify(Tournament.state.bracketData)); // Deep copy before clearing
                    Season.completeEvent(bracketToComplete);

                    // Clear tournament state IMMEDIATELY to prevent bracket data carryover
                    Tournament.state.bracketData = [];
                    Tournament.state.currentActiveRound = 0;
                    Tournament.state.viewingRound = 0;
                    Tournament.state.matchQueue = [];
                    Tournament.state.selectedPlayerIndices.clear();

                    console.log(`[PL SIM] Guard set, keeping inProgress true until guard is cleared`);
                    Tournament.skipAdvancementAnimation = false;
                    Season.silentSimulation = false;

                    // Reset flags immediately for Sim mode to allow simulateRemainingSeason to continue
                    console.log(`[PL SIM] Clearing inProgress and guard immediately`);
                    Season.state.inProgress = false;
                    Season.guardAgainstAutoStart = false;
                    return;
                } else {
                    document.getElementById('setup-screen').style.display = 'none';
                    document.getElementById('tourn-hub-title').innerText = ev.name;
                    Tournament.renderHub();
                }
            },

            recordPremierLeagueNight: (bracketData) => {
                const finalMatch = bracketData[2][0];
                const sf1 = bracketData[1][0];
                const sf2 = bracketData[1][1];

                // Final winner: 5 points + ¬£10,000
                if (finalMatch.winner) {
                    Season.state.premierLeague.standings[finalMatch.winner.name].points += 5;
                    Season.state.premierLeague.standings[finalMatch.winner.name].finalWins += 1;
                    Season.state.premierLeague.standings[finalMatch.winner.name].money += 10000;
                }

                // Final loser: 3 points
                const finalLoser = finalMatch.winner === finalMatch.p1 ? finalMatch.p2 : finalMatch.p1;
                if (finalLoser) {
                    Season.state.premierLeague.standings[finalLoser.name].points += 3;
                    Season.state.premierLeague.standings[finalLoser.name].runnerUpFinishes += 1;
                }

                // SF finishers: 2 points each (the losers of the SF matches)
                [sf1, sf2].forEach(sf => {
                    const sfLoser = sf.winner === sf.p1 ? sf.p2 : sf.p1;

                    // Only award SF points if this player didn't make it to the final
                    // (finalLoser already got runner-up points, so skip them)
                    if (sfLoser && sfLoser.name !== finalLoser.name) {
                        Season.state.premierLeague.standings[sfLoser.name].points += 2;
                        Season.state.premierLeague.standings[sfLoser.name].semiFinalFinishes += 1;
                    }
                });
            },

            getPremierLeagueQualifiers: () => {
                // Top 4 qualify for playoffs
                const standings = Object.entries(Season.state.premierLeague.standings)
                    .sort((a, b) => {
                        if (b[1].points !== a[1].points) return b[1].points - a[1].points;
                        return (b[1].finalWins - a[1].finalWins) - (b[1].semiFinalFinishes - a[1].semiFinalFinishes);
                    });

                return standings.slice(0, 4).map(e => e[0]);
            },

            renderPremierLeagueStandings: () => {
                const container = document.getElementById('premier-league-standings');
                if (!container) return;

                container.innerHTML = '';

                const standings = Object.entries(Season.state.premierLeague.standings)
                    .sort((a, b) => {
                        if (b[1].points !== a[1].points) return b[1].points - a[1].points;
                        return (b[1].finalWins - a[1].finalWins) - (b[1].semiFinalFinishes - a[1].semiFinalFinishes);
                    });

                const table = document.createElement('table');
                table.style.cssText = 'width: 100%; font-size: 12px; border-collapse: collapse; margin-bottom: 10px;';

                // Header
                const headerRow = table.insertRow();
                headerRow.style.cssText = 'background: #222; border-bottom: 1px solid #444;';
                ['Pos', 'Player', 'Pts', 'Wins', 'RU', 'SF', '¬£'].forEach(h => {
                    const cell = headerRow.insertCell();
                    cell.innerText = h;
                    cell.style.cssText = 'padding: 5px; text-align: center; color: #aaa; font-weight: bold;';
                });

                // Rows
                standings.forEach(([name, stats], idx) => {
                    const row = table.insertRow();
                    const isQualified = idx < 4;
                    row.style.cssText = isQualified ? 'background: #0a2a1a; border-bottom: 1px solid #333;' : 'background: #1a1a1a; border-bottom: 1px solid #333;';

                    const data = [idx + 1, name, stats.points, stats.finalWins, stats.runnerUpFinishes, stats.semiFinalFinishes, '¬£' + stats.money];
                    data.forEach((d, i) => {
                        const cell = row.insertCell();
                        cell.innerText = d;
                        cell.style.cssText = `padding: 5px; text-align: ${i === 1 ? 'left' : 'center'}; color: ${isQualified ? 'var(--pdc-gold)' : '#aaa'};`;
                    });
                });

                container.appendChild(table);

                // Show current night info
                const infoDiv = document.createElement('div');
                infoDiv.style.cssText = 'text-align: center; margin-top: 10px; color: #aaa; font-size: 11px;';
                infoDiv.innerText = `Night ${Season.state.premierLeague.currentNight} / 16`;
                container.appendChild(infoDiv);
            },

            renderPremierLeagueStandingsTo: (containerId) => {
                const container = document.getElementById(containerId);
                if (!container) return;

                container.innerHTML = '';

                const standings = Object.entries(Season.state.premierLeague.standings)
                    .sort((a, b) => {
                        if (b[1].points !== a[1].points) return b[1].points - a[1].points;
                        return (b[1].finalWins - a[1].finalWins) - (b[1].semiFinalFinishes - a[1].semiFinalFinishes);
                    });

                const table = document.createElement('table');
                table.style.cssText = 'width: 100%; font-size: 12px; border-collapse: collapse; margin-bottom: 10px;';

                const headerRow = table.insertRow();
                headerRow.style.cssText = 'background: #222; border-bottom: 1px solid #444;';
                ['Pos', 'Player', 'Pts', 'Wins', 'RU', 'SF', '¬£'].forEach(h => {
                    const cell = headerRow.insertCell();
                    cell.innerText = h;
                    cell.style.cssText = 'padding: 5px; text-align: center; color: #aaa; font-weight: bold;';
                });

                standings.forEach(([name, stats], idx) => {
                    const row = table.insertRow();
                    const isQualified = idx < 4;
                    row.style.cssText = isQualified ? 'background: #0a2a1a; border-bottom: 1px solid #333;' : 'background: #1a1a1a; border-bottom: 1px solid #333;';

                    const data = [idx + 1, name, stats.points, stats.finalWins, stats.runnerUpFinishes, stats.semiFinalFinishes, '¬£' + stats.money];
                    data.forEach((d, i) => {
                        const cell = row.insertCell();
                        cell.innerText = d;
                        cell.style.cssText = `padding: 5px; text-align: ${i === 1 ? 'left' : 'center'}; color: ${isQualified ? 'var(--pdc-gold)' : '#aaa'};`;
                    });
                });

                container.appendChild(table);

                const infoDiv = document.createElement('div');
                infoDiv.style.cssText = 'text-align: center; margin-top: 10px; color: #aaa; font-size: 11px;';
                infoDiv.innerText = `Night ${Season.state.premierLeague.currentNight} / 16`;
                container.appendChild(infoDiv);
            },

            renderQSchoolStandings: () => {
                Season.renderQSchoolStandingsForLocation('uk');
                Season.renderQSchoolStandingsForLocation('eu');
            },

            renderQSchoolStandingsForLocation: (location) => {
                const containerId = `qschool-standings-${location}`;
                const container = document.getElementById(containerId);
                if (!container) return;

                container.innerHTML = '';

                const oom = location === 'uk' ? Season.state.qSchool.ukOOM : Season.state.qSchool.euOOM;
                const tourCardWinners = location === 'uk' ? Season.state.qSchool.ukTourCardWinners : Season.state.qSchool.euTourCardWinners;

                // Sort by points descending
                const standings = Object.entries(oom).sort((a, b) => b[1] - a[1]);

                if (standings.length === 0) {
                    container.innerHTML = '<div style="text-align: center; color: #aaa; padding: 20px;">No players yet</div>';
                    return;
                }

                const table = document.createElement('table');
                table.style.cssText = 'width: 100%; font-size: 12px; border-collapse: collapse; margin-bottom: 10px;';

                // Header
                const headerRow = table.insertRow();
                headerRow.style.cssText = 'background: #222; border-bottom: 1px solid #444;';
                ['Pos', 'Player', 'Points', 'Status'].forEach(h => {
                    const cell = headerRow.insertCell();
                    cell.innerText = h;
                    cell.style.cssText = 'padding: 5px; text-align: center; color: #aaa; font-weight: bold;';
                });

                // Rows
                standings.forEach(([name, points], idx) => {
                    const row = table.insertRow();
                    const isTourCard = tourCardWinners.includes(name);

                    let status = '';
                    let bgColor = '#1a1a1a';
                    let textColor = '#aaa';

                    if (isTourCard) {
                        status = 'üèÜ TOUR CARD';
                        bgColor = '#0a3a0a';
                        textColor = 'var(--pdc-gold)';
                    }

                    row.style.cssText = `background: ${bgColor}; border-bottom: 1px solid #333;`;

                    const data = [idx + 1, name, points, status];
                    data.forEach((d, i) => {
                        const cell = row.insertCell();
                        cell.innerText = d;
                        cell.style.cssText = `padding: 5px; text-align: ${i === 1 ? 'left' : 'center'}; color: ${textColor};`;
                    });
                });

                container.appendChild(table);

                // Show location info
                const infoDiv = document.createElement('div');
                infoDiv.style.cssText = 'text-align: center; margin-top: 10px; color: #aaa; font-size: 11px;';
                infoDiv.innerText = `${location.toUpperCase()} Q-SCHOOL - ${standings.length} Players`;
                container.appendChild(infoDiv);
            }
            ,

            renderQSchoolStandingsForLocationTo: (location, containerId) => {
                const container = document.getElementById(containerId);
                if (!container) return;

                container.innerHTML = '';

                const oom = location === 'uk' ? Season.state.qSchool.ukOOM : Season.state.qSchool.euOOM;
                const tourCardWinners = location === 'uk' ? Season.state.qSchool.ukTourCardWinners : Season.state.qSchool.euTourCardWinners;

                const standings = Object.entries(oom).sort((a, b) => b[1] - a[1]);

                if (standings.length === 0) {
                    container.innerHTML = '<div style="text-align: center; color: #aaa; padding: 20px;">No players yet</div>';
                    return;
                }

                const table = document.createElement('table');
                table.style.cssText = 'width: 100%; font-size: 12px; border-collapse: collapse; margin-bottom: 10px;';

                const headerRow = table.insertRow();
                headerRow.style.cssText = 'background: #222; border-bottom: 1px solid #444;';
                ['Pos', 'Player', 'Points', 'Status'].forEach(h => {
                    const cell = headerRow.insertCell();
                    cell.innerText = h;
                    cell.style.cssText = 'padding: 5px; text-align: center; color: #aaa; font-weight: bold;';
                });

                standings.forEach(([name, points], idx) => {
                    const row = table.insertRow();
                    const isTourCard = tourCardWinners.includes(name);

                    let status = '';
                    let bgColor = '#1a1a1a';
                    let textColor = '#aaa';

                    if (isTourCard) {
                        status = 'TOUR CARD';
                        bgColor = '#0a3a0a';
                        textColor = 'var(--pdc-gold)';
                    }

                    row.style.cssText = `background: ${bgColor}; border-bottom: 1px solid #333;`;

                    const data = [idx + 1, name, points, status];
                    data.forEach((d, i) => {
                        const cell = row.insertCell();
                        cell.innerText = d;
                        cell.style.cssText = `padding: 5px; text-align: ${i === 1 ? 'left' : 'center'}; color: ${textColor};`;
                    });
                });

                container.appendChild(table);

                const infoDiv = document.createElement('div');
                infoDiv.style.cssText = 'text-align: center; margin-top: 10px; color: #aaa; font-size: 11px;';
                infoDiv.innerText = `${location.toUpperCase()} Q-SCHOOL - ${standings.length} Players`;
                container.appendChild(infoDiv);
            }
        };
        window.Tournament = {
            config: { mode: 'sets', playerCount: 32, rounds: [], selectionMethod: 'random', tiebreak: false },
            state: { active: false, bracketData: [], currentActiveRound: 0, viewingRound: 0, selectedPlayerIndices: new Set(), matchQueue: [] },
            skipAdvancementAnimation: false,
            forceShowFinalAnimation: false,
            roundAdvanceAnimating: false,
            pendingAdvanceAction: null,
            getCurrentEvent: () => {
                const isCustomTab = document.getElementById('tab-tourn')?.classList.contains('active');
                if (isCustomTab) return null;
                return (typeof Season !== 'undefined' && Season.state.inProgress) ? Season.events[Season.state.activeEventIndex] : null;
            },


            setMode: (mode) => {
                Tournament.config.mode = mode;
                const btnSets = document.getElementById('tourn-mode-sets');
                const btnLegs = document.getElementById('tourn-mode-legs');
                if (btnSets) btnSets.className = `format-btn ${mode === 'sets' ? 'selected' : ''}`;
                if (btnLegs) btnLegs.className = `format-btn ${mode === 'legs' ? 'selected' : ''}`;
                const legDiv = document.getElementById('tourn-legs-per-set-div');
                if (legDiv) legDiv.style.display = (mode === 'sets') ? 'block' : 'none';
                Tournament.updateConfigUI();
            },
            setSelectionMethod: (method) => {
                Tournament.config.selectionMethod = method;
                const btnRandom = document.getElementById('sel-random');
                const btnManual = document.getElementById('sel-manual');
                const manualSelector = document.getElementById('manual-selector');
                if (btnRandom) btnRandom.className = `format-btn ${method === 'random' ? 'selected' : ''}`;
                if (btnManual) btnManual.className = `format-btn ${method === 'manual' ? 'selected' : ''}`;
                if (manualSelector) manualSelector.style.display = (method === 'manual') ? 'flex' : 'none';
                if (method === 'manual') Tournament.updatePlayerSelectUI();
            },
            startGrandSlamGroupStage: () => {
                const ev = Tournament.getCurrentEvent();
                const isBulkSim = typeof Season !== 'undefined' && Season.isBulkSim;

                const size = isBulkSim ? 32 : parseInt(document.getElementById('tourn-size').value);
                Tournament.config.tiebreak = isBulkSim ? false : document.getElementById('tourn-tiebreak').checked;
                Tournament.config.playerCount = size;

                let participants = [];
                Tournament.state.selectedPlayerIndices.forEach(idx => participants.push({ ...PLAYERS_DB[idx] }));

                // Sort by average (seeding) - don't shuffle randomly
                participants.sort((a, b) => (b.avg || 0) - (a.avg || 0));

                // Create 8 groups of 4 using snake seeding pattern
                // Seed 1-8 go to positions 0,7,6,1,2,5,4,3 to avoid early matchups
                const numGroups = 8;
                const playersPerGroup = 4;
                const groups = Array(numGroups).fill(null).map(() => []);

                // Distribute players using snake pattern
                const seedPositions = [0, 7, 6, 1, 2, 5, 4, 3]; // Seeding pattern
                for (let i = 0; i < participants.length; i++) {
                    const groupIdx = seedPositions[i % 8];
                    groups[groupIdx].push(participants[i]);
                }

                // Initialize group stage state
                Tournament.state.active = true;
                Tournament.state.currentActiveRound = 0;
                Tournament.state.viewingRound = 0;
                Tournament.state.matchQueue = [];
                Tournament.state.bracketData = [];
                Tournament.state.groupStageData = groups;
                Tournament.state.groupMatches = [];
                Tournament.state.groupStandings = [];

                // Generate round-robin matches for each group
                let matchId = 0;
                for (let g = 0; g < groups.length; g++) {
                    const group = groups[g];
                    const groupMatches = [];
                    const standings = {};

                    // Initialize standings
                    group.forEach(p => {
                        standings[p.name] = { wins: 0, losses: 0, legsFor: 0, legsAgainst: 0, points: 0 };
                    });

                    // Create round-robin pairings
                    for (let i = 0; i < group.length; i++) {
                        for (let j = i + 1; j < group.length; j++) {
                            groupMatches.push({
                                id: matchId++,
                                group: g,
                                p1: group[i],
                                p2: group[j],
                                winner: null,
                                score: null,
                                averages: null
                            });
                        }
                    }

                    Tournament.state.groupMatches.push(groupMatches);
                    Tournament.state.groupStandings.push(standings);
                }

                // Set up Grand Slam rounds
                Tournament.config.rounds = [
                    { name: "Group", target: 5 },
                    { name: "L16", target: 10 },
                    { name: "QF", target: 16 },
                    { name: "SF", target: 16 },
                    { name: "F", target: 16 }
                ];

                // Skip UI updates during bulk simulation
                if (!isBulkSim) {
                    Persistence.save();
                    requestWakeLock();
                    document.getElementById('setup-screen').style.display = 'none';
                    document.getElementById('tourn-hub-title').innerText = document.getElementById('tourn-event-name').value;
                    Tournament.renderGrandSlamGroupStage();
                }
            },
            seedBracket: (participants) => {
                // ========================
                // PROPER TOURNAMENT SEEDING
                // Uses standard bracket seeding where:
                // 1 vs N, 2 vs N-1, 3 vs N-2, etc.
                // This ensures top seeds meet only in later rounds
                // ========================
                const totalPlayers = participants.length;

                const ev = Tournament.getCurrentEvent();
                const isEuropeanTour = ev && ev.type === 'european-tour';
                const isUkOpen = ev && ev.name && ev.name.includes('UK OPEN');
                const fullSeeding = isEuropeanTour || isUkOpen;

                // Sort by average rating (descending), putting byes (null) at the end
                const sorted = [...participants].sort((a, b) => {
                    if (!a) return 1;  // null goes to end
                    if (!b) return -1; // non-null comes first
                    return (b.avg || 0) - (a.avg || 0);
                });

                // Determine how many players to seed
                const numSeeded = fullSeeding ? totalPlayers : Math.floor(totalPlayers / 2);

                console.log(`[Seeding] Event: ${ev?.name || 'Standalone'}, Type: ${ev?.type || 'N/A'}, Seeding ${numSeeded}/${totalPlayers} players`);

                // Add seed numbers only to seeded players
                for (let i = 0; i < sorted.length; i++) {
                    if (sorted[i]) {
                        sorted[i].seed = i < numSeeded ? (i + 1) : null;
                    }
                }

                // Separate seeded and unseeded players
                const seededPlayers = sorted.slice(0, numSeeded);
                const unseededPlayers = sorted.slice(numSeeded);

                // Shuffle unseeded players (random draw)
                for (let i = unseededPlayers.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [unseededPlayers[i], unseededPlayers[j]] = [unseededPlayers[j], unseededPlayers[i]];
                }

                // Standard bracket seeding pattern for seeded players
                const bracketOrder = Tournament.generateBracketOrder(totalPlayers);

                const bracket = [];
                let unseededIndex = 0;

                bracketOrder.forEach(seedNum => {
                    if (seedNum <= numSeeded && seedNum <= seededPlayers.length) {
                        // Place seeded player in their designated position
                        bracket.push(seededPlayers[seedNum - 1]);
                    } else {
                        // Place unseeded player (random draw order)
                        if (unseededIndex < unseededPlayers.length) {
                            bracket.push(unseededPlayers[unseededIndex]);
                            unseededIndex++;
                        } else if (seedNum <= sorted.length) {
                            // Fallback to remaining sorted players if we run out
                            bracket.push(sorted[seedNum - 1]);
                        }
                    }
                });

                return bracket;
            },

            generateBracketOrder: (size) => {
                // Generate standard tournament bracket seeding order
                // This creates proper matchups: 1vN, 2vN-1, 3vN-2, etc.
                // by interleaving top and bottom seeds
                if (size === 2) return [1, 2];
                if (size === 1) return [1];

                // Safety: ensure size is a power of 2
                if (size <= 0 || (size & (size - 1)) !== 0) {
                    console.error(`generateBracketOrder: size ${size} is not a power of 2`);
                    return Array.from({ length: size }, (_, i) => i + 1);
                }

                const halfSize = size / 2;
                const topHalf = Tournament.generateBracketOrder(halfSize);
                const bottomHalf = [];

                topHalf.forEach(seed => {
                    bottomHalf.push(size + 1 - seed);
                });

                // Interleave to create proper bracket: topHalf[0], bottomHalf[0], topHalf[1], bottomHalf[1], etc.
                const result = [];
                for (let i = 0; i < topHalf.length; i++) {
                    result.push(topHalf[i]);
                    result.push(bottomHalf[i]);
                }

                return result;
            },
            startUkOpen: () => {
                const ev = Season.events[Season.state.activeEventIndex];
                // Get R1 participants (64 players)
                const r1Idx = Tournament.state.ukOpenEntrants?.R1 || [];
                let participants = r1Idx.map(i => PLAYERS_DB[i] ? { ...PLAYERS_DB[i] } : null).filter(p => p && p.name);

                // Ensure even player count
                if (participants.length % 2 !== 0) {
                    console.warn(`UK Open R1: Odd player count (${participants.length}), removing last player`);
                    participants = participants.slice(0, participants.length - 1);
                }

                console.log(`üéØ UK Open R1 starting with ${participants.length} players (${participants.length / 2} matches)`);

                // Random draw for R1
                for (let i = participants.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [participants[i], participants[j]] = [participants[j], participants[i]];
                }

                Tournament.state.active = true;
                Tournament.state.currentActiveRound = 0;
                Tournament.state.viewingRound = 0;
                Tournament.state.matchQueue = [];
                Tournament.state.bracketData = [];

                // Create Round 1 matches
                const r0 = [];
                for (let i = 0; i < participants.length; i += 2) {
                    if (participants[i] && participants[i + 1]) {
                        r0.push({ p1: participants[i], p2: participants[i + 1], winner: null, score: null, averages: null });
                    }
                }
                Tournament.state.bracketData.push(r0);
                for (let i = 1; i < Tournament.config.rounds.length; i++) {
                    Tournament.state.bracketData.push([]);
                }

                requestWakeLock();
                document.getElementById('setup-screen').style.display = 'none';
                document.getElementById('tournament-hub').style.display = 'flex';
                document.getElementById('tournament-hub').style.visibility = 'visible';
                document.getElementById('tourn-hub-title').innerText = document.getElementById('tourn-event-name').value;
                Tournament.renderHub();
            },
            updateConfigUI: () => {
                const tournSizeEl = document.getElementById('tourn-size');
                if (!tournSizeEl) return;
                const size = parseInt(tournSizeEl.value);
                Tournament.config.playerCount = size;
                const selTotalEl = document.getElementById('sel-total');
                if (selTotalEl) selTotalEl.innerText = size;
                Tournament.updateSelectionCount();
                const container = document.getElementById('tourn-rounds-container');
                if (!container) return;
                container.innerHTML = '';
                let roundsNeeded = Math.log2(size);
                let roundNames = ["L256", "L128", "L64", "L32", "L16", "QF", "SF", "F"];
                let names = roundNames.slice(roundNames.length - roundsNeeded);
                for (let i = 0; i < roundsNeeded; i++) {
                    const div = document.createElement('div');
                    div.className = 'tourn-input-group';

                    const ev = Season.events[Season.state.activeEventIndex];
                    const val = Tournament.getRoundTarget(i, roundsNeeded);

                    const isLocked = Tournament.config.lockRounds;
                    const inputStyle = isLocked ? 'opacity: 0.7; cursor: not-allowed;' : '';
                    const disabledAttr = isLocked ? 'disabled' : '';

                    div.innerHTML = `
                    <label style="margin:0; font-size:10px;">${names[i]}</label>
                    <input type="number" id="t-rnd-${i}" value="${val}" min="1" max="99" style="padding:5px; text-align:center;${inputStyle}" ${disabledAttr}>
                `;
                    container.appendChild(div);
                }
            },
            updatePlayerSelectUI: () => {
                const container = document.getElementById('player-list-container');
                if (!container || container.children.length > 0) return;

                const ev = Tournament.getCurrentEvent();
                let regionFilter = null;

                // Apply strict regional filtering for qualifier events
                if (ev?.type === 'wc-qual-intl') {
                    if (ev.name.includes("AFRICAN")) regionFilter = REGION_MAP.africa;
                    else if (ev.name.includes("INDIA")) regionFilter = REGION_MAP.india;
                    else if (ev.name.includes("JAPAN")) regionFilter = ["jpn"];
                    else if (ev.name.includes("NORDIC & BALTIC")) regionFilter = REGION_MAP.nordic;
                    else if (ev.name.includes("NORTH AMERICAN")) regionFilter = REGION_MAP.america;
                    else if (ev.name.includes("ASIAN")) regionFilter = REGION_MAP.asia;
                    else if (ev.name.includes("HUNGARIAN")) regionFilter = ["hun"];
                    else if (ev.name.includes("NETHERLANDS & BELGIUM")) regionFilter = ["nl", "bel"];
                    else if (ev.name.includes("MEDITERRANEAN")) regionFilter = ["esp", "ita", "por", "gre", "tur"];
                    else if (ev.name.includes("SOUTH-EAST EUROPE")) regionFilter = ["rou", "bul", "srb", "cro", "slo"];
                    else if (ev.name.includes("CZECHIA")) regionFilter = ["cze"];
                    else if (ev.name.includes("POLISH") || ev.name.includes("PDO POLISH")) regionFilter = ["pol"];
                    else if (ev.name.includes("DACH")) regionFilter = ["ger", "aut", "sui"];
                    else if (ev.name.includes("UK&IRE")) regionFilter = ["eng", "sco", "wal", "nir", "irl"];
                    else if (ev.name.includes("CDC") || ev.name.includes("CDLC")) regionFilter = REGION_MAP.america;
                    else if (ev.name.includes("ANZ") || ev.name.includes("DPA") || ev.name.includes("DPNZ")) regionFilter = REGION_MAP.oceania;
                }

                let html = '';
                PLAYERS_DB.forEach((p, idx) => {
                    // Skip players that don't match regional filter
                    if (regionFilter && !regionFilter.includes(p.country)) return;

                    const flag = getFlagUrl(p.country);
                    html += `
                        <div class="player-option" id="p-opt-${idx}" onclick="Tournament.togglePlayer(${idx})">
                            <input type="checkbox" id="chk-${idx}" style="pointer-events:none; margin-right:10px;">
                            <img src="${flag}" style="width:20px; height:14px; margin-right:8px;">
                            <span style="font-size:13px;">${p.name}</span>
                        </div>`;
                });
                container.innerHTML = html;
            },
            togglePlayer: (idx) => {
                const set = Tournament.state.selectedPlayerIndices;
                const chk = document.getElementById(`chk-${idx}`);
                const div = document.getElementById(`p-opt-${idx}`);

                const ev = Tournament.getCurrentEvent();
                const player = PLAYERS_DB[idx];

                if (set.has(idx)) {
                    set.delete(idx);
                    chk.checked = false;
                    div.classList.remove('selected');
                } else {
                    // Enforce regional restrictions for JAPAN tour
                    if (ev?.type === 'wc-qual-intl' && ev.name.includes("JAPAN") && player.country !== "jpn") {
                        alert("Only Japanese players can participate in the PDJ JAPAN TOUR.");
                        return;
                    }

                    if (set.size >= Tournament.config.playerCount) {
                        alert(`Limit reached.`);
                        return;
                    }
                    set.add(idx);
                    chk.checked = true;
                    div.classList.add('selected');
                }
                Tournament.updateSelectionCount();
            },
            updateSelectionCount: () => {
                const selCountEl = document.getElementById('sel-count');
                if (selCountEl) selCountEl.innerText = Tournament.state.selectedPlayerIndices.size;
            },
            clearSelection: () => {
                Tournament.state.selectedPlayerIndices.clear();
                document.querySelectorAll('.player-option').forEach(el => el.classList.remove('selected'));
                document.querySelectorAll('.player-option input').forEach(el => el.checked = false);
                Tournament.updateSelectionCount();
            },
            filterPlayerList: () => {
                const searchEl = document.getElementById('player-search');
                if (!searchEl) return;
                const term = searchEl.value.toLowerCase();
                const opts = document.getElementsByClassName('player-option');
                for (let i = 0; i < opts.length; i++) {
                    const txt = opts[i].innerText.toLowerCase();
                    opts[i].style.display = txt.includes(term) ? 'flex' : 'none';
                }
            },
            start: () => {
                const ev = Tournament.getCurrentEvent();
                let size = parseInt(document.getElementById('tourn-size')?.value) || (ev ? ev.players : 32);

                // ===== VALIDATION =====
                // Check manual selection has enough players
                if (Tournament.config.selectionMethod === 'manual') {
                    if (Tournament.state.selectedPlayerIndices.size === 0) {
                        alert("Please select at least 2 players to create a tournament.");
                        return;
                    }
                    if (Tournament.state.selectedPlayerIndices.size < 2) {
                        alert("Please select at least 2 players to create a tournament.");
                        return;
                    }
                    if (Tournament.state.selectedPlayerIndices.size < size) {
                        alert(`You selected ${Tournament.state.selectedPlayerIndices.size} players but tournament requires ${size}. Please select more players or reduce tournament size.`);
                        return;
                    }
                }

                // ================= SKIP & REPLACEMENT SYSTEM =================
                if (ev && Tournament.config.selectionMethod === 'manual') {
                    const selected = Array.from(Tournament.state.selectedPlayerIndices);
                    const toRemove = [];
                    const toAdd = [];

                    // Check withdrawals BEFORE applying fatigue reduction
                    selected.forEach(idx => {
                        const p = PLAYERS_DB[idx];
                        if (PlayerState.shouldSkipEvent(p, ev.type)) {
                            toRemove.push(idx);
                            PlayerState.updateFatigue(p, -25);

                            // Add News
                            if (Season.addNews) Season.addNews(`${p.name} withdraws from ${ev.name} due to fatigue.`);
                        }
                    });

                    // Apply fatigue reduction for everyone AFTER withdrawal checks
                    PlayerState.applyEventFatigueReduction();

                    // Process all replacements after identifying all withdrawals
                    const removedSet = new Set(toRemove);
                    toRemove.forEach(removedIdx => {
                        // Build current list: ALL players currently in tournament (including withdrawn ones not yet removed)
                        // plus all replacements added so far - this ensures withdrawn players can't replace themselves
                        const currentList = Array.from(Tournament.state.selectedPlayerIndices)
                            .concat(toAdd);

                        const repIdx = PlayerState.getReplacementPlayer(currentList, ev.type, ev.name);
                        if (repIdx !== -1 && !removedSet.has(repIdx)) {
                            toAdd.push(repIdx);
                            if (Season.addNews) Season.addNews(`${PLAYERS_DB[repIdx].name} enters ${ev.name} as a replacement.`);
                        } else {
                            console.warn(`Could not find replacement for ${PLAYERS_DB[removedIdx].name}`);
                        }
                    });

                    toRemove.forEach(i => Tournament.state.selectedPlayerIndices.delete(i));
                    toAdd.forEach(i => Tournament.state.selectedPlayerIndices.add(i));

                    // Ensure we don't exceed tournament size
                    const targetSize = ev.players;
                    if (Tournament.state.selectedPlayerIndices.size > targetSize) {
                        console.warn(`Too many players after replacements (${Tournament.state.selectedPlayerIndices.size}/${targetSize}), trimming excess`);
                        const excess = Tournament.state.selectedPlayerIndices.size - targetSize;
                        const toRemoveExcess = Array.from(Tournament.state.selectedPlayerIndices).slice(targetSize);
                        toRemoveExcess.forEach(i => Tournament.state.selectedPlayerIndices.delete(i));
                    }

                    // Force update visible count if needed
                    const actualSize = parseInt(document.getElementById('tourn-size')?.value) || ev.players;
                    if (toRemove.length > 0) console.log(`Skipped: ${toRemove.length} players. Replaced with qualifiers.`);
                }
                // =============================================================

                if (ev && typeof Season !== 'undefined' && Season.applyCareerParticipationToSelection) {
                    Season.applyCareerParticipationToSelection(ev);
                }

                size = parseInt(document.getElementById('tourn-size')?.value) || (ev ? ev.players : 32);
                const tiebreakEl = document.getElementById('tourn-tiebreak');
                Tournament.config.tiebreak = tiebreakEl ? tiebreakEl.checked : false;

                // Save Custom Theme - but ONLY for manual tournaments, not Season events
                // Season.startEvent() already sets Tournament.config.theme from themePreset
                const themeEl = document.getElementById('tourn-theme');
                const isCustomTab = document.getElementById('tab-tourn')?.classList.contains('active');
                const isSeasonEvent = !isCustomTab && typeof Season !== 'undefined' && Season.state.inProgress;
                if (themeEl && !isSeasonEvent) {
                    if (themeEl.value === 'custom') {
                        const c1 = document.getElementById('theme-col-1').value;
                        const c2 = document.getElementById('theme-col-2').value;
                        Tournament.config.theme = { mode: 'custom', color1: c1, color2: c2 };
                    } else {
                        Tournament.config.theme = { mode: 'preset', id: themeEl.value };
                    }
                }

                // Support non-power-of-2 by rounding up to next power of 2
                const nextPowerOf2 = Math.pow(2, Math.ceil(Math.log2(size)));
                const numRounds = Math.log2(nextPowerOf2);

                // Only rebuild rounds if they haven't been pre-configured
                if (isCustomTab || !Tournament.config.rounds || Tournament.config.rounds.length === 0) {
                    Tournament.config.rounds = [];

                    for (let i = 0; i < numRounds; i++) {
                        const el = document.getElementById(`t-rnd-${i}`);
                        if (el) {
                            Tournament.config.rounds.push({
                                name: el.previousElementSibling.innerText,
                                target: parseInt(el.value)
                            });
                        } else {
                            // Fallback for rounds without UI elements
                            Tournament.config.rounds.push({
                                name: `R${i}`,
                                target: 5
                            });
                        }
                    }
                }
                let participants = [];
                const eligibleRegions = (ev && ev.eligibleRegions) || [];
                if (Tournament.config.selectionMethod === 'manual') {
                    const actualSize = Tournament.state.selectedPlayerIndices.size;
                    if (actualSize !== size) {
                        console.warn(`Size mismatch: Expected ${size}, got ${actualSize}. Proceeding with actual size.`);
                        // Update size to match actual selection after replacement system
                        // This handles cases where withdrawals/replacements have adjusted the count
                    }
                    Tournament.state.selectedPlayerIndices.forEach(idx => {
                        const player = PLAYERS_DB[idx];
                        if (player && player.name) {
                            participants.push({ ...player });
                        } else {
                            console.error(`Invalid player index ${idx} in selectedPlayerIndices (PLAYERS_DB length: ${PLAYERS_DB.length})`);
                        }
                    });

                    // If we have fewer participants than expected due to invalid indices, log warning
                    if (participants.length < Tournament.state.selectedPlayerIndices.size) {
                        console.error(`Lost ${Tournament.state.selectedPlayerIndices.size - participants.length} players due to invalid indices`);
                    }

                    // Safety: If we somehow have more participants than the tournament size, trim to exact size
                    if (ev && ev.players && participants.length > ev.players) {
                        console.warn(`Tournament has ${participants.length} participants but only ${ev.players} slots. Trimming excess players.`);
                        participants = participants.slice(0, ev.players);
                    }
                } else {
                    if (ev && ev.type === 'q-school') {
                        participants = PLAYERS_DB.filter(p => !p.tourCard && (eligibleRegions.length === 0 || eligibleRegions.includes(p.country)));
                    } else if (ev && ev.type === 'challenge') {
                        // Challenge Tour: exclude players with tour cards, only non-card players
                        participants = PLAYERS_DB.filter(p => !p.tourCard && (eligibleRegions.length === 0 || eligibleRegions.includes(p.country)));
                    } else {
                        participants = [...PLAYERS_DB];
                    }
                    if (participants.length < size) { alert("Not enough players DB."); return; }
                    for (let i = participants.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[participants[i], participants[j]] = [participants[j], participants[i]]; }
                    participants = participants.slice(0, size);
                }

                // Q-SCHOOL: Exclude players from other venue, exclude qualified, and backfill replacements
                if (ev && ev.type === 'q-school') {
                    const location = ev.location; // 'uk' or 'eu'
                    const otherVenueParticipants = location === 'uk' ? (Season.state.qSchool.euParticipants || []) : (Season.state.qSchool.ukParticipants || []);
                    const eligibleRegions = ev.eligibleRegions || [];

                    // Exclude players who have already participated in the other venue
                    participants = participants.filter(p => !otherVenueParticipants.includes(p.name));

                    // For First Stage, also exclude already qualified players for Final Stage
                    let qualified = [];
                    if (ev.name.includes('First Stage')) {
                        qualified = location === 'uk' ? (Season.state.qSchool.ukFinalStageQualified || []) : (Season.state.qSchool.euFinalStageQualified || []);
                        participants = participants.filter(p => !qualified.includes(p.name));

                        // Remove qualified players from OOM so they don't show in standings
                        const oom = location === 'uk' ? Season.state.qSchool.ukOOM : Season.state.qSchool.euOOM;
                        qualified.forEach(playerName => delete oom[playerName]);
                    }

                    // Backfill to maintain bracket size using eligible, unused players
                    const isEligible = (p) => !p.tourCard && (eligibleRegions.length === 0 || eligibleRegions.includes(p.country));
                    const currentNames = new Set(participants.map(p => p.name));
                    const replacementPool = PLAYERS_DB
                        .filter(p => isEligible(p))
                        .filter(p => !otherVenueParticipants.includes(p.name))
                        .filter(p => !qualified.includes(p.name))
                        .filter(p => !currentNames.has(p.name));

                    // Shuffle replacement pool
                    for (let i = replacementPool.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [replacementPool[i], replacementPool[j]] = [replacementPool[j], replacementPool[i]];
                    }

                    while (participants.length < size && replacementPool.length > 0) {
                        participants.push({ ...replacementPool.pop() });
                    }

                    if (participants.length < size) {
                        alert(`Warning: Only ${participants.length} eligible players available after exclusions. Bracket will proceed with byes.`);
                    }
                }

                for (let i = participants.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[participants[i], participants[j]] = [participants[j], participants[i]]; }

                // Support non-power-of-2 by adding byes for lower-ranked participants
                const byesNeeded = nextPowerOf2 - participants.length;

                // Add bye markers for the bracket structure
                for (let i = 0; i < byesNeeded; i++) {
                    participants.push(null); // null represents a bye
                }

                Tournament.state.active = true;
                Tournament.state.currentActiveRound = 0;
                Tournament.state.viewingRound = 0;
                Tournament.state.matchQueue = []; // Clear queue
                Tournament.state.bracketData = [];

                // Reset Grand Slam group stage flags
                Tournament.config.isGroupStage = false;
                Tournament.state.groupMatches = [];
                Tournament.state.groupStageData = [];
                Tournament.state.groupStandings = [];
                Tournament.activeGroupIdx = undefined;
                Tournament.activeMatchIdx = undefined;

                // ========================
                // SEEDING ALGORITHM
                // ========================
                const seededBracket = Tournament.seedBracket(participants);

                const r0 = [];
                for (let i = 0; i < seededBracket.length; i += 2) {
                    const p1 = seededBracket[i];
                    const p2 = seededBracket[i + 1];

                    // Handle byes - if one player is null (bye), the other advances
                    let match = { p1: p1, p2: p2, winner: null, score: null, averages: null };
                    if (p1 === null && p2 !== null) {
                        match.winner = p2; // Bye winner is p2
                    } else if (p2 === null && p1 !== null) {
                        match.winner = p1; // Bye winner is p1
                    }
                    r0.push(match);
                }
                Tournament.state.bracketData.push(r0);
                for (let i = 1; i < numRounds; i++) { Tournament.state.bracketData.push([]); }

                Persistence.save();
                requestWakeLock(); // Request Wake Lock
                document.getElementById('setup-screen').style.display = 'none';
                document.getElementById('tourn-hub-title').innerText = document.getElementById('tourn-event-name').value;
                Tournament.renderHub();
            },
            changeViewRound: (dir) => {
                const next = Tournament.state.viewingRound + dir;
                if (next >= 0 && next < Tournament.config.rounds.length) { Tournament.state.viewingRound = next; Tournament.renderHub(); }
            },

            getRoundTarget: function (roundIndex, totalRounds) {
                const ev = Tournament.getCurrentEvent();
                if (!ev) {
                    // Smart defaults for custom tournaments
                    if (!totalRounds) {
                        const size = parseInt(document.getElementById('tourn-size')?.value || 32);
                        totalRounds = Math.log2(size);
                    }
                    const distFromFinal = totalRounds - 1 - roundIndex;
                    if (distFromFinal === 0) return 11; // Final
                    if (distFromFinal === 1) return 11; // Semi-Final
                    if (distFromFinal === 2) return 10; // Quarter-Final
                    return 6; // Early rounds
                }
                const players = ev.players / Math.pow(2, roundIndex);

                let roundName = "F";
                if (players > 2) roundName = "L" + players;
                if (players === 8) roundName = "QF";
                if (players === 4) roundName = "SF";

                const cfg = ROUND_FORMATS[ev.type];

                if (!cfg) {
                    return 5; // Q-school safe default
                }

                // For sets mode with Winmau Masters, check for sets-specific keys
                if (Tournament.config.mode === 'sets' && ev.type === 'winmaudm') {
                    const setsKey = roundName + '_sets';
                    if (cfg[setsKey] !== undefined) {
                        // Convert sets to legs based on legs per set setting (Winmau uses 2 legs per set)
                        const legsPerSet = 2;
                        return cfg[setsKey] * legsPerSet;
                    }
                }

                // Fall back to regular leg targets
                if (cfg[roundName] === undefined) {
                    return 5; // Q-school safe default
                }

                return cfg[roundName];
            },


            traceMatch: (direction, matchIdx) => {
                const currentRound = Tournament.state.viewingRound;
                let targetRound, targetMatchIdx;
                if (direction === -1) {
                    if (currentRound === 0) return;
                    targetRound = currentRound - 1; targetMatchIdx = matchIdx * 2;
                    Tournament.state.viewingRound = targetRound; Tournament.renderHub();
                    const m1 = document.getElementById(`bm-${targetMatchIdx}`);
                    const m2 = document.getElementById(`bm-${targetMatchIdx + 1}`);
                    if (m1) { m1.classList.add('highlight'); m1.scrollIntoView({ behavior: "smooth", block: "center" }); }
                    if (m2) { m2.classList.add('highlight'); }
                    setTimeout(() => { if (m1) m1.classList.remove('highlight'); if (m2) m2.classList.remove('highlight'); }, 2000);
                } else {
                    if (currentRound === Tournament.config.rounds.length - 1) return;
                    targetRound = currentRound + 1; targetMatchIdx = Math.floor(matchIdx / 2);
                    Tournament.state.viewingRound = targetRound; Tournament.renderHub();
                    const m = document.getElementById(`bm-${targetMatchIdx}`);
                    if (m) { m.classList.add('highlight'); m.scrollIntoView({ behavior: "smooth", block: "center" }); setTimeout(() => m.classList.remove('highlight'), 2000); }
                }
            },

            simulateCurrentRound: () => {
                // Check if this is group stage (either by flag or by checking if group data exists)
                if (Tournament.config.isGroupStage ||
                    (Tournament.state.groupMatches && Tournament.state.groupMatches.length > 0 &&
                        !Tournament.state.groupMatches.every(gm => gm.every(m => m.winner)))) {
                    Tournament.simulateGroupStage();
                    return;
                }

                // Optimize: Skip animations and DOM updates during bulk simulation
                const isBulkSim = typeof Season !== 'undefined' && Season.isBulkSim;
                const isSilent = typeof Season !== 'undefined' && Season.silentSimulation;

                // Simulate only the current active round
                const activeR = Tournament.state.currentActiveRound;
                const matches = Tournament.state.bracketData[activeR];
                const roundInfo = Tournament.config.rounds[activeR];

                let simulatedCount = 0;
                const advancingPlayers = isBulkSim ? null : []; // Skip array allocation in bulk sim

                if (!matches || !Array.isArray(matches)) {
                    if (!isBulkSim) {
                        console.error('simulateCurrentRound: matches array is undefined or invalid');
                        alert('Tournament bracket error. Please restart the tournament.');
                    }
                    return;
                }

                // Use optimized for loop instead of forEach
                const matchCount = matches.length;
                const target = roundInfo.target;
                for (let i = 0; i < matchCount; i++) {
                    const m = matches[i];
                    if (!m.winner && m.p1 && m.p2) {
                        Tournament.fastSim(m, target);
                        simulatedCount++;
                        if (!isBulkSim && m.winner) {
                            advancingPlayers.push({
                                player: m.winner,
                                avg: m.averages[m.winner === m.p1 ? 0 : 1]
                            });
                        }
                    }
                }

                if (simulatedCount > 0) {
                    if (Tournament.config.eventType === 'premier-league' || Tournament.config.eventType === 'premier-league-playoff') {
                        Tournament.checkRoundCompleteNoAutoAdvance();
                        if (!isBulkSim) {
                            Persistence.save();
                            Tournament.renderHub();
                        }
                    } else {
                        // Show advancement animation BEFORE advancing rounds (but only if NOT in bulk sim)
                        if (!isBulkSim && !isSilent && advancingPlayers && advancingPlayers.length > 0) {
                            // Check if round is complete before showing animation
                            let allMatchesComplete = true;
                            for (let i = 0; i < matchCount; i++) {
                                if (!matches[i].winner) { allMatchesComplete = false; break; }
                            }

                            if (allMatchesComplete) {
                                // Show animation first, then advance round after it ends
                                const animDurationMs = 1300; // match overlay auto-close timing
                                Tournament.showAdvancementAnimation(advancingPlayers, activeR);

                                setTimeout(() => {
                                    const prevSkip = Tournament.skipAdvancementAnimation;
                                    Tournament.skipAdvancementAnimation = true; // avoid double animation in checkRoundComplete
                                    Tournament.closeAdvancementOverlay();
                                    Tournament.checkRoundComplete();
                                    Tournament.skipAdvancementAnimation = prevSkip;
                                    Persistence.save();
                                    Tournament.renderHub();
                                }, animDurationMs);
                            } else {
                                // Not all matches complete, just update display
                                Persistence.save();
                                Tournament.renderHub();
                            }
                        } else {
                            Tournament.checkRoundComplete();
                            if (!isBulkSim) {
                                Persistence.save();
                                Tournament.renderHub();
                            }
                        }
                    }
                } else {
                    // If everything is already played, advance state quietly instead of alerting
                    let allDone = true;
                    for (let i = 0; i < matchCount; i++) {
                        if (!matches[i].winner) { allDone = false; break; }
                    }
                    if (allDone) {
                        if (Tournament.config.eventType === 'premier-league' || Tournament.config.eventType === 'premier-league-playoff') {
                            Tournament.checkRoundCompleteNoAutoAdvance();
                        } else {
                            Tournament.checkRoundComplete();
                        }
                        if (!isBulkSim) {
                            Persistence.save();
                            Tournament.renderHub();
                        }
                    } else if (!isSilent) {
                        alert("No matches to simulate.");
                    }
                }
            },

            simulateToEnd: () => {
                // Simulate all remaining rounds and show only final winner
                let finalWinner = null;
                const isBulkSim = Season.isBulkSim;

                // Build player index cache for bulk sim performance
                if (isBulkSim && !Tournament._playerIndexCache) {
                    Tournament._playerIndexCache = new Map();
                    for (let i = 0; i < PLAYERS_DB.length; i++) {
                        Tournament._playerIndexCache.set(PLAYERS_DB[i].name, i);
                    }
                }

                // Check if Grand Slam with incomplete group stage
                if (Tournament.config.isGroupStage && Tournament.state.groupMatches && Tournament.state.groupMatches.length > 0) {
                    // Optimized check for incomplete groups
                    let allGroupsComplete = true;
                    outer: for (let g = 0; g < Tournament.state.groupMatches.length; g++) {
                        const matches = Tournament.state.groupMatches[g];
                        for (let m = 0; m < matches.length; m++) {
                            if (!matches[m].winner) {
                                allGroupsComplete = false;
                                break outer;
                            }
                        }
                    }

                    if (!allGroupsComplete) {
                        // Simulate group stage first - this will call initiateGrandSlamKnockout
                        // which sets currentActiveRound to 1 and creates the knockout bracket
                        Tournament.simulateGroupStage();
                    }
                }

                // After group stage simulation, ensure we're pointing at a valid round with matches
                // Grand Slam: bracketData[0] is empty placeholder, bracketData[1] is L16
                while (Tournament.state.currentActiveRound < Tournament.config.rounds.length &&
                    Tournament.state.bracketData[Tournament.state.currentActiveRound] &&
                    Tournament.state.bracketData[Tournament.state.currentActiveRound].length === 0) {
                    Tournament.state.currentActiveRound++;
                }

                while (Tournament.state.currentActiveRound < Tournament.config.rounds.length - 1) {
                    const activeR = Tournament.state.currentActiveRound;
                    const matches = Tournament.state.bracketData[activeR];
                    const roundInfo = Tournament.config.rounds[activeR];

                    if (!matches || !Array.isArray(matches) || matches.length === 0) {
                        // Skip empty rounds (e.g., Grand Slam group placeholder at index 0)
                        Tournament.state.currentActiveRound++;
                        continue;
                    }

                    matches.forEach(m => {
                        if (!m.winner && m.p1 && m.p2) {
                            Tournament.fastSim(m, roundInfo.target);
                        }
                    });

                    Tournament.skipAdvancementAnimation = true;
                    Tournament.checkRoundComplete();
                    Tournament.skipAdvancementAnimation = false;
                }

                // Now simulate the finals
                const finalRound = Tournament.state.bracketData[Tournament.config.rounds.length - 1];
                const finalRoundInfo = Tournament.config.rounds[Tournament.config.rounds.length - 1];

                if (finalRound && Array.isArray(finalRound)) {
                    finalRound.forEach(m => {
                        if (!m.winner && m.p1 && m.p2) {
                            Tournament.fastSim(m, finalRoundInfo.target);
                            if (m.winner) {
                                finalWinner = {
                                    player: m.winner,
                                    avg: m.averages[m.winner === m.p1 ? 0 : 1]
                                };
                            }
                        }
                    });

                    Tournament.checkRoundComplete();
                }

                // Skip expensive rendering and persistence during bulk sim
                if (!Season.isBulkSim) {
                    Persistence.save();
                    Tournament.renderHub();
                }

                // Show only the tournament winner animation
                if (finalWinner && (typeof Season === 'undefined' || (Season && (!Season.silentSimulation || Tournament.forceShowFinalAnimation)))) {
                    console.log('Showing final tournament winner animation');
                    setTimeout(() => {
                        Tournament.showAdvancementAnimation([finalWinner], Tournament.config.rounds.length - 1);
                    }, 500);
                }
            },

            showAdvancementAnimation: (players, completedRoundIdx) => {
                console.log('showAdvancementAnimation called with', players.length, 'players, round:', completedRoundIdx);
                const overlay = document.getElementById('advancement-overlay');
                const grid = document.getElementById('adv-grid');
                const title = document.getElementById('adv-title');
                const subtitle = document.getElementById('adv-subtitle');

                if (!overlay) {
                    console.error('Advancement overlay not found!');
                    return;
                }

                // Check if this is the final round
                const isFinalRound = completedRoundIdx === Tournament.config.rounds.length - 1;

                if (isFinalRound || players.length === 1) {
                    // Tournament winner
                    title.textContent = 'TOURNAMENT WINNER!';
                    subtitle.textContent = '';
                } else {
                    // Players advancing to next round
                    const nextRoundIdx = completedRoundIdx + 1;
                    const nextRoundName = Tournament.config.rounds[nextRoundIdx].name;
                    title.textContent = 'PLAYERS ADVANCING';
                    subtitle.textContent = `TO ${nextRoundName}`;
                }

                grid.innerHTML = '';
                players.forEach((p, index) => {
                    const div = document.createElement('div');
                    div.className = 'advancement-player';
                    div.style.animationDelay = `${index * 0.1}s`;
                    const avg = p.avg ? parseFloat(p.avg).toFixed(2) : '0.00';
                    const country = p.player?.country || 'unknown';
                    div.innerHTML = `
                        <img src="${getFlagUrl(country)}" class="advancement-flag">
                        <div class="advancement-player-name">${p.player?.name || 'Unknown'}</div>
                        <div class="advancement-player-avg">${avg}</div>
                    `;
                    grid.appendChild(div);
                });

                console.log('Displaying overlay...');
                overlay.style.display = 'flex';

                // Make overlay clickable to skip
                overlay.onclick = () => {
                    Tournament.closeAdvancementOverlay();
                };

                // Auto-close after animation duration
                setTimeout(() => {
                    if (overlay.style.display === 'flex') {
                        Tournament.closeAdvancementOverlay();
                    }
                }, 1200);

                // Add visual effect to the matches
                players.forEach(p => {
                    const playerMatches = document.querySelectorAll('.bracket-match.completed');
                    playerMatches.forEach(match => {
                        if (match.textContent.includes(p.player.name)) {
                            match.classList.add('just-won');
                            setTimeout(() => match.classList.remove('just-won'), 800);
                        }
                    });
                });
            },

            showCelebration: (title, subtitle, playerNames) => {
                // Suppress in BULK sim only. Allow in single Event Sim (silentSimulation is true in both).
                if (Season.isBulkSim) return;

                const overlay = document.getElementById('advancement-overlay');
                const grid = document.getElementById('adv-grid');
                const titleEl = document.getElementById('adv-title');
                const subtitleEl = document.getElementById('adv-subtitle');

                if (!overlay) return;

                titleEl.textContent = title;
                subtitleEl.textContent = subtitle;
                grid.innerHTML = '';

                playerNames.forEach((name, index) => {
                    const p = PLAYERS_DB.find(x => x.name === name) || { name: name, country: 'unknown' };

                    const div = document.createElement('div');
                    div.className = 'advancement-player';
                    div.style.animationDelay = `${index * 0.05}s`;

                    // Simple flag logic or fallback
                    const flagUrl = p.country ? getFlagUrl(p.country) : 'pdc-logo.png';

                    div.innerHTML = `
                        <img src="${flagUrl}" class="advancement-flag" onerror="this.src='pdc-logo.png'">
                        <div class="advancement-player-name">${p.name}</div>
                    `;
                    grid.appendChild(div);
                });

                overlay.style.display = 'flex';

                // For celebrations, we DON'T auto-close. User must click "CONTINUE" or overlay.
                overlay.onclick = (e) => {
                    if (e.target === overlay) Tournament.closeAdvancementOverlay();
                };
            },

            closeAdvancementOverlay: () => {
                document.getElementById('advancement-overlay').style.display = 'none';
            },

            simulateRound: () => {
                // Deprecated - use simulateCurrentRound instead
                Tournament.simulateCurrentRound();
            },

            startAutoPlay: () => {
                const checkboxes = document.querySelectorAll('.match-select-cb:checked');

                if (checkboxes.length === 0) {
                    alert("select matches");
                    return;
                }

                const activeR = Tournament.state.currentActiveRound;
                const matches = Tournament.state.bracketData[activeR];
                const roundInfo = Tournament.config.rounds[activeR];
                Tournament.state.matchQueue = [];

                checkboxes.forEach(cb => {
                    const idx = parseInt(cb.value);
                    if (matches[idx] && !matches[idx].winner) {
                        Tournament.state.matchQueue.push(idx);
                    }
                });

                matches.forEach((m, idx) => {
                    if (!m.winner && m.p1 && m.p2 && !Tournament.state.matchQueue.includes(idx)) {
                        Tournament.fastSim(m, roundInfo.target);
                    }
                });
                Persistence.save();

                if (Tournament.state.matchQueue.length > 0) {
                    Tournament.playNextInQueue();
                } else {
                    Tournament.renderHub();
                    Tournament.checkRoundComplete();
                }
            },

            watchRoundAll: () => {
                const activeR = Tournament.state.currentActiveRound;
                const matches = Tournament.state.bracketData[activeR] || [];
                const roundInfo = Tournament.config.rounds[activeR];
                Tournament.state.matchQueue = [];

                matches.forEach((m, idx) => {
                    if (!m.winner && m.p1 && m.p2) {
                        Tournament.state.matchQueue.push(idx);
                    }
                });

                if (Tournament.state.matchQueue.length > 0) {
                    Tournament.playNextInQueue();
                } else if (roundInfo) {
                    Tournament.checkRoundComplete();
                }
            },

            playNextInQueue: () => {
                if (Tournament.state.matchQueue.length === 0) {
                    Tournament.renderHub();
                    return;
                }
                const nextMatchIdx = Tournament.state.matchQueue.shift();
                Tournament.playMatch(nextMatchIdx);
            },

            updateWatchButtonState: () => {
                const count = document.querySelectorAll('.match-select-cb:checked').length;
                const btn = document.querySelector('.btn-watch');
                if (btn) btn.innerText = count > 0 ? "WATCH SELECTED" : "WATCH ROUND";
            },

            renderGrandSlamGroupStage: () => {
                const hub = document.getElementById('tournament-hub');
                const bracket = document.getElementById('tourn-bracket');
                bracket.innerHTML = '';

                const html = document.createElement('div');
                html.style.cssText = 'display: flex; flex-direction: column; gap: 20px; padding: 10px;';

                // Render all groups
                for (let g = 0; g < Tournament.state.groupStageData.length; g++) {
                    const group = Tournament.state.groupStageData[g];
                    const matches = Tournament.state.groupMatches[g];
                    const standings = Tournament.state.groupStandings[g];

                    const groupDiv = document.createElement('div');
                    groupDiv.style.cssText = 'border: 1px solid #444; padding: 15px; border-radius: 4px; background: #1a1a1a;';

                    // Group title
                    const title = document.createElement('h3');
                    title.style.cssText = 'margin: 0 0 10px 0; color: var(--pdc-gold); font-size: 14px;';
                    title.innerText = `GROUP ${String.fromCharCode(65 + g)}`;
                    groupDiv.appendChild(title);

                    // Standings table
                    const table = document.createElement('table');
                    table.style.cssText = 'width: 100%; font-size: 12px; margin-bottom: 10px; border-collapse: collapse;';

                    const headerRow = table.insertRow();
                    headerRow.style.cssText = 'background: #222; border-bottom: 1px solid #444;';
                    ['Player', 'W', 'L', 'Pts', 'LF', 'LA'].forEach(h => {
                        const cell = headerRow.insertCell();
                        cell.innerText = h;
                        cell.style.cssText = 'padding: 5px; text-align: center; color: #aaa;';
                    });

                    // Sort standings
                    const sorted = Object.entries(standings)
                        .sort((a, b) => {
                            if (b[1].points !== a[1].points) return b[1].points - a[1].points;
                            return (b[1].legsFor - b[1].legsAgainst) - (a[1].legsFor - a[1].legsAgainst);
                        });

                    sorted.forEach(([name, stats], idx) => {
                        const row = table.insertRow();

                        // Check if this is the career player
                        const careerPlayer = (typeof Season !== 'undefined' && Season.getCareerPlayer) ? Season.getCareerPlayer() : null;
                        const isCareerPlayer = careerPlayer && name === careerPlayer.name;

                        let rowStyle = idx < 2 ? 'background: #0a2a1a; border-bottom: 1px solid #333;' : 'background: #1a1a1a; border-bottom: 1px solid #333;';
                        if (isCareerPlayer) {
                            rowStyle = 'background: linear-gradient(90deg, rgba(52, 152, 219, 0.4), rgba(52, 152, 219, 0.1)); border-bottom: 1px solid #3498db; border-left: 3px solid #3498db;';
                        }
                        row.style.cssText = rowStyle;

                        const cells = [name, stats.wins, stats.losses, stats.points, stats.legsFor, stats.legsAgainst];
                        cells.forEach((c, i) => {
                            const cell = row.insertCell();
                            cell.innerText = c;
                            let cellStyle = `padding: 5px; text-align: ${i === 0 ? 'left' : 'center'}; color: ${idx < 2 ? 'var(--pdc-gold)' : '#aaa'};`;
                            if (isCareerPlayer && i === 0) {
                                cellStyle += ' font-weight: bold; padding-left: 8px;';
                            }
                            cell.style.cssText = cellStyle;
                        });
                    });

                    groupDiv.appendChild(table);

                    // Matches
                    const matchesDiv = document.createElement('div');
                    matchesDiv.style.cssText = 'display: flex; flex-direction: column; gap: 8px;';

                    matches.forEach((m, idx) => {
                        const matchCard = document.createElement('div');

                        // Check if career player is in this match
                        const careerPlayer = (typeof Season !== 'undefined' && Season.getCareerPlayer) ? Season.getCareerPlayer() : null;
                        const isCareerMatch = careerPlayer && (m.p1.name === careerPlayer.name || m.p2.name === careerPlayer.name);

                        let borderColor = m.winner ? '#008000' : '#666';
                        if (isCareerMatch && !m.winner) {
                            borderColor = '#3498db';
                        }

                        matchCard.style.cssText = 'background: #222; padding: 8px; border-radius: 4px; border-left: 3px solid ' + borderColor + ';';

                        const matchText = `${m.p1.name} vs ${m.p2.name}`;
                        const scoreText = m.score ? ` - ${m.score[0]}-${m.score[1]}` : '';
                        const statusText = m.winner ? ` (W: ${m.winner.name})` : '';

                        matchCard.innerHTML = `<span style="font-size: 11px; color: #aaa;">${matchText}${scoreText}${statusText}</span>`;

                        if (!m.winner) {
                            const playBtn = document.createElement('button');
                            playBtn.className = 'btn-play-mini';
                            playBtn.innerText = 'PLAY';
                            playBtn.style.marginTop = '5px';
                            playBtn.onclick = () => Tournament.playGrandSlamMatch(g, idx);
                            matchCard.appendChild(playBtn);
                        }

                        matchesDiv.appendChild(matchCard);
                    });

                    groupDiv.appendChild(matchesDiv);
                    html.appendChild(groupDiv);
                }

                // Add action buttons
                const actionsDiv = document.createElement('div');
                actionsDiv.style.cssText = 'display: flex; gap: 10px; padding: 15px 10px; justify-content: center; flex-wrap: wrap;';

                const simBtn = document.createElement('button');
                simBtn.className = 'btn-sim';
                simBtn.style.cssText = 'padding: 8px 16px; font-size: 12px;';
                simBtn.innerText = '‚ö° SIMULATE GROUP STAGE';
                simBtn.onclick = () => Tournament.simulateGroupStage();
                actionsDiv.appendChild(simBtn);

                // Add Simulate to End button
                const simToEndBtn = document.createElement('button');
                simToEndBtn.className = 'btn-sim';
                simToEndBtn.style.cssText = 'padding: 8px 16px; font-size: 12px; background: linear-gradient(145deg, #c9a227, #967818);';
                simToEndBtn.innerText = 'üèÜ SIMULATE TO END';
                simToEndBtn.onclick = () => Tournament.simulateToEnd();
                actionsDiv.appendChild(simToEndBtn);

                html.appendChild(actionsDiv);

                bracket.appendChild(html);
                hub.style.display = 'flex';
                document.getElementById('match-screen').style.display = 'none';

                // Set round name and format
                document.getElementById('tourn-round-name').innerText = 'Group';
                const typeStr = (Tournament.config.mode === 'sets') ? 'Sets' : 'Legs';
                document.getElementById('tourn-round-fmt').innerText = `First to 5 ${typeStr}`;
                document.getElementById('btn-prev-round').disabled = true;
                document.getElementById('btn-next-round').disabled = false;

                if (typeof Season !== 'undefined' && Season.updateCareerMatchBanner) {
                    Season.updateCareerMatchBanner();
                }
            },
            simulateGroupStage: () => {
                const isBulkSim = typeof Season !== 'undefined' && Season.isBulkSim;
                const isSilent = typeof Season !== 'undefined' && Season.silentSimulation;

                // Check if group stage data exists
                if (!Tournament.state.groupMatches || Tournament.state.groupMatches.length === 0) {
                    if (!isBulkSim && !isSilent) {
                        console.error('simulateGroupStage: No group matches data found');
                        alert('No group stage data found. Please enter the tournament first.');
                    }
                    return;
                }

                // Ensure rounds config exists
                if (!Tournament.config.rounds || Tournament.config.rounds.length === 0) {
                    if (!isBulkSim && !isSilent) {
                        console.error('simulateGroupStage: No rounds config found');
                        alert('Tournament configuration error. Please restart the tournament.');
                    }
                    return;
                }

                let totalSimulated = 0;
                const roundInfo = Tournament.config.rounds[0]; // Group stage target

                // Simulate all group matches with optimized loop
                const groupMatches = Tournament.state.groupMatches;
                const groupCount = groupMatches.length;

                for (let g = 0; g < groupCount; g++) {
                    const matches = groupMatches[g];
                    const matchCount = matches.length;
                    for (let m = 0; m < matchCount; m++) {
                        const match = matches[m];
                        if (!match.winner && match.p1 && match.p2) {
                            Tournament.fastSim(match, roundInfo.target);
                            Tournament.updateGroupStandings(g, match);
                            totalSimulated++;
                        }
                    }
                }

                if (totalSimulated > 0) {
                    // Check if all groups are complete
                    let allGroupsComplete = true;
                    for (let g = 0; g < groupCount && allGroupsComplete; g++) {
                        const matches = groupMatches[g];
                        for (let m = 0; m < matches.length; m++) {
                            if (!matches[m].winner) {
                                allGroupsComplete = false;
                                break;
                            }
                        }
                    }

                    if (allGroupsComplete) {
                        if (!isBulkSim) Persistence.save();
                        Tournament.initiateGrandSlamKnockout();
                    } else {
                        if (!isBulkSim) Persistence.save();
                        if (!isBulkSim) Tournament.renderGrandSlamGroupStage();
                    }
                    if (!isBulkSim && !isSilent) {
                        alert(`Simulated ${totalSimulated} group matches!`);
                    }
                } else {
                    if (!isBulkSim && !isSilent) {
                        alert("No matches to simulate.");
                    }
                }
            },

            updateGroupStandings: (groupIdx, match) => {
                const standings = Tournament.state.groupStandings[groupIdx];
                const p1Name = match.p1.name;
                const p2Name = match.p2.name;
                const [score1, score2] = match.score;

                if (!standings[p1Name]) {
                    standings[p1Name] = { wins: 0, losses: 0, points: 0, legsFor: 0, legsAgainst: 0 };
                }
                if (!standings[p2Name]) {
                    standings[p2Name] = { wins: 0, losses: 0, points: 0, legsFor: 0, legsAgainst: 0 };
                }

                standings[p1Name].legsFor += score1;
                standings[p1Name].legsAgainst += score2;
                standings[p2Name].legsFor += score2;
                standings[p2Name].legsAgainst += score1;

                if (score1 > score2) {
                    standings[p1Name].wins++;
                    standings[p1Name].points += 2;
                    standings[p2Name].losses++;
                } else {
                    standings[p2Name].wins++;
                    standings[p2Name].points += 2;
                    standings[p1Name].losses++;
                }
            },

            playGrandSlamMatch: (groupIdx, matchIdx) => {
                requestWakeLock();
                SOUND_180.load();
                SOUND_INTRO.load();

                const match = Tournament.state.groupMatches[groupIdx][matchIdx];
                const roundInfo = Tournament.config.rounds[0]; // Group stage

                Tournament.activeGroupIdx = groupIdx;
                Tournament.activeMatchIdx = matchIdx;

                App.config.event = document.getElementById('tourn-event-name').value + ` - Group ${String.fromCharCode(65 + groupIdx)}`;
                App.config.target = roundInfo.target;
                App.config.mode = Tournament.config.mode;
                App.config.tiebreak = Tournament.config.tiebreak;

                App.startMatch(match.p1, match.p2, roundInfo.target);
            },
            leaveEvent: () => {
                // Save current tournament state
                Persistence.save();

                // Hide tournament hub and show setup/hub screen
                const hub = document.getElementById('tournament-hub');
                const setup = document.getElementById('setup-screen');
                if (hub) hub.style.display = 'none';
                if (setup) setup.style.display = 'flex';

                // Detect origin tab (where the user started the tournament from)
                // If the tournament tab button is active, it was a custom tournament
                const isCustomTab = document.getElementById('tab-btn-tourn')?.classList.contains('active');
                const targetTab = isCustomTab ? 'tourn' : 'season';

                if (typeof App !== 'undefined' && App.switchTab) {
                    App.switchTab(targetTab);
                }

                if (targetTab === 'season' && typeof Season !== 'undefined' && Season.renderUI) {
                    Season.renderUI();
                }

                console.log(`[Tournament.leaveEvent] Left event, returning to ${targetTab} tab`);
            },

            resumeEvent: () => {
                if (!Tournament.state.active) {
                    console.warn('[Tournament.resumeEvent] No active tournament to resume');
                    return;
                }

                // Hide season screen and show tournament hub
                document.getElementById('setup-screen').style.display = 'none';
                document.getElementById('tournament-hub').style.display = 'flex';

                // Render the current tournament state
                Tournament.renderHub();

                console.log('[Tournament.resumeEvent] Event resumed');
            },

            renderHub: () => {
                // Ensure tournament title is set correctly
                const tournName = Tournament.config.name || document.getElementById('tourn-event-name')?.value || 'TOURNAMENT';
                const hubTitle = document.getElementById('tourn-hub-title');
                if (hubTitle) hubTitle.innerText = tournName;

                // Apply theme colors to the hub
                if (App.applyEventColors) App.applyEventColors(tournName);

                // Check if this is group stage
                if (Tournament.config.isGroupStage) {
                    Tournament.renderGrandSlamGroupStage();
                    return;
                }

                // If viewing round 0 in a Grand Slam knockout, show group standings instead
                if (Tournament.state.viewingRound === 0 && Tournament.state.groupStageData && Tournament.state.groupStageData.length > 0) {
                    Tournament.renderGrandSlamGroupStage();
                    return;
                }

                const hub = document.getElementById('tournament-hub');
                const bracket = document.getElementById('tourn-bracket');
                const activeRoundIdx = Tournament.state.currentActiveRound;

                bracket.innerHTML = '';

                // Single-sided bracket layout
                const wrapper = document.createElement('div');
                wrapper.style.display = 'flex';
                wrapper.style.gap = '60px';
                wrapper.style.flex = '1';
                wrapper.style.overflowX = 'auto';
                wrapper.style.overflowY = 'auto';
                wrapper.style.alignItems = 'flex-start';
                wrapper.style.WebkitOverflowScrolling = 'touch';

                // Mobile responsive gap
                if (window.innerWidth <= 768) {
                    wrapper.style.gap = '40px';
                }

                Tournament.config.rounds.forEach((roundInfo, roundIdx) => {
                    const matches = Tournament.state.bracketData[roundIdx] || [];
                    const column = Tournament.createBracketColumn(roundInfo, roundIdx, matches, activeRoundIdx, 0);
                    wrapper.appendChild(column);
                });

                bracket.appendChild(wrapper);

                // Scroll to keep the active round in view
                setTimeout(() => {
                    const activeColumn = bracket.querySelector('.bracket-round-column:nth-child(' + (activeRoundIdx + 1) + ')');
                    if (activeColumn && activeRoundIdx > 0) {
                        activeColumn.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                    }
                }, 100);

                hub.style.display = 'flex';
                document.getElementById('match-screen').style.display = 'none';

                Tournament.updateWatchButtonState();
                if (typeof Season !== 'undefined' && Season.updateCareerMatchBanner) {
                    Season.updateCareerMatchBanner();
                }
                Persistence.save();
            },

            updateThemeSelector: function () {
                const themeEl = document.getElementById('tourn-theme');
                if (!themeEl) return;

                const currentValue = themeEl.value;
                const themes = EVENT_THEMES || DataLoader.getDefaultThemes();

                // Clear existing preset options but keep Default and Custom
                const defaultOpt = themeEl.options[0]; // Default / Auto
                const customOpt = themeEl.options[themeEl.options.length - 1]; // Custom Theme...

                themeEl.innerHTML = '';
                themeEl.appendChild(defaultOpt);

                // Mapping of technical IDs to readable names
                const nameMap = {
                    'world': 'World Championship (Green/Gold)',
                    'matchplay': 'World Matchplay (Red/Blue)',
                    'premier-league': 'Premier League (Blue/Neon)',
                    'grandprix': 'World Grand Prix (Blue/Teal)',
                    'grandslam': 'Grand Slam (Orange/Black)',
                    'uk-open': 'UK Open (Yellow/Red)',
                    'players': 'Players Championship (Red/Black)',
                    'playersf': 'Players Championship Finals',
                    'europeanf': 'European Championship (Purple/Silver)',
                    'masters': 'The Masters (Gold/Black)',
                    'winmaudm': 'Winmau World Masters (Black/White)',
                    'wmasters-qual': 'Winmau Qualifiers',
                    'challenge': 'Challenge Tour',
                    'q-school': 'Q-School',
                    'wc-qual-intl': 'WC International Qualifier',
                    'gs-qual-tc': 'Grand Slam Qualifier'
                };

                // Add themes from EVENT_THEMES
                Object.keys(themes).forEach(id => {
                    // Skip 'minor' as it's the fallback base, and duplicates or internal types if needed
                    if (id === 'minor' || id.includes('qual-tc') || id.includes('host-nation')) return;

                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = nameMap[id] || (id.charAt(0).toUpperCase() + id.slice(1).replace(/-/g, ' '));
                    themeEl.appendChild(option);
                });

                themeEl.appendChild(customOpt);

                // Restore previous value if it still exists
                if (Array.from(themeEl.options).some(opt => opt.value === currentValue)) {
                    themeEl.value = currentValue;
                }
            },

            createBracketColumn: (roundInfo, roundIdx, matches, activeRoundIdx, matchIndexOffset = 0) => {
                const column = document.createElement('div');
                column.className = 'bracket-round-column';

                // Column header
                const header = document.createElement('div');
                header.className = 'round-column-header';
                const typeStr = (Tournament.config.mode === 'sets') ? 'Sets' : 'Legs';
                header.innerHTML = `
                    <div class="round-column-name">${roundInfo.name}</div>
                    <div class="round-column-format">First to ${roundInfo.target} ${typeStr}</div>
                `;
                column.appendChild(header);

                // Matches list
                const matchesList = document.createElement('div');
                matchesList.className = 'bracket-matches-list';

                if (matches.length === 0) {
                    matchesList.innerHTML = `<div style="text-align:center; color:#555; padding:20px;">Awaiting Results</div>`;
                } else {
                    matches.forEach((m, localIdx) => {
                        const idx = matchIndexOffset + localIdx; // Actual index in bracketData
                        const card = document.createElement('div');
                        card.className = `bracket-match ${m.winner ? 'completed' : ''}`;
                        card.id = `bm-${roundIdx}-${idx}`;

                        const getPHTML = (p, score, avg, isWinner) => {
                            const name = p ? p.name : 'TBD';
                            const flag = p ? getFlagUrl(p.country) : '';
                            const avgTxt = (m.winner && avg) ? `(${avg})` : '';
                            const seedTxt = p && p.seed ? `(${p.seed})` : '';

                            // Check if this is the career player
                            const careerPlayer = (typeof Season !== 'undefined' && Season.getCareerPlayer) ? Season.getCareerPlayer() : null;
                            const isCareerPlayer = p && careerPlayer && p.name === careerPlayer.name;

                            // Add Q-School points if applicable
                            const currentEvent = Tournament.getCurrentEvent();
                            let pointsTxt = '';
                            if (currentEvent && currentEvent.type === 'q-school' && p) {
                                const oom = currentEvent.location === 'uk' ? Season.state.qSchool.ukOOM : Season.state.qSchool.euOOM;
                                const pts = oom[p.name] || 0;
                                pointsTxt = ` [${pts}pts]`;
                            }

                            let statsTxt = '';
                            if (p && !m.winner) {
                                const liveP = typeof PLAYERS_DB !== 'undefined' ? PLAYERS_DB.find(dbP => dbP.name === p.name) : p;
                                if (liveP) {
                                    const f = Math.round(liveP.form || 50);
                                    const ft = Math.round(liveP.fatigue || 0);
                                    const fColor = f > 80 ? '#4caf50' : f > 50 ? '#ffeb3b' : '#f44336';
                                    const ftColor = ft < 30 ? '#4caf50' : ft < 70 ? '#ffeb3b' : '#f44336';
                                    statsTxt = `<span style="font-size:0.8em; margin-left:6px; opacity:0.9; display:inline-block;">
                                        <span style="color:${fColor};" title="Form">üî•${f}</span> <span style="color:${ftColor};" title="Fatigue">‚ö°${ft}</span>
                                    </span>`;
                                }
                            }

                            let baseStyle = isWinner ? "color:var(--pdc-gold); font-weight:900;" : (m.winner ? "color:#555; text-decoration:line-through;" : "color:#aaa;");

                            // Add career player highlight
                            if (isCareerPlayer) {
                                if (!m.winner) {
                                    baseStyle += " background: linear-gradient(90deg, rgba(52, 152, 219, 0.3), transparent); border-left: 3px solid #3498db; padding-left: 5px;";
                                } else if (isWinner) {
                                    baseStyle += " background: linear-gradient(90deg, rgba(255, 215, 0, 0.2), transparent); border-left: 3px solid var(--pdc-gold); padding-left: 5px;";
                                } else {
                                    baseStyle += " border-left: 3px solid rgba(52, 152, 219, 0.5); padding-left: 5px;";
                                }
                            }

                            return `
                                <div class="bm-row" style="${baseStyle}">
                                    ${p ? `<img src="${flag}" class="bm-flag">` : ''}
                                    <span class="bm-name">${name}${seedTxt && !m.winner ? ' ' + seedTxt : ''}${pointsTxt}${statsTxt}</span>
                                    <span class="bm-avg">${avgTxt}</span>
                                    <span class="bm-score">${score !== null ? score : ''}</span>
                                </div>
                            `;
                        };

                        let checkbox = '';
                        const isPlayable = (!m.winner && roundIdx === activeRoundIdx && m.p1 && m.p2);
                        if (isPlayable) {
                            checkbox = `<input type="checkbox" class="match-select-cb" value="${idx}" data-round="${roundIdx}" onchange="Tournament.updateWatchButtonState()">`;
                        }

                        let html = `
                            <button class="match-nav-btn" onclick="Tournament.traceMatch(-1, ${idx}, ${roundIdx})">&lt;</button>
                            ${checkbox}
                            <div class="bm-content">
                                ${getPHTML(m.p1, m.score ? m.score[0] : null, m.averages ? m.averages[0] : null, m.winner === m.p1)}
                                ${getPHTML(m.p2, m.score ? m.score[1] : null, m.averages ? m.averages[1] : null, m.winner === m.p2)}
                            </div>
                        `;

                        html += `<div style="display:flex; align-items:center;">`;

                        if (isPlayable) {
                            html += `<div class="bm-action"><button class="btn-play-mini" onclick="Tournament.playMatch(${idx}, ${roundIdx})">PLAY</button></div>`;
                        }

                        html += `<button class="match-nav-btn" onclick="Tournament.traceMatch(1, ${idx}, ${roundIdx})">&gt;</button></div>`;

                        card.innerHTML = html;

                        // Wrap card in bracket-match-wrapper for tree lines
                        const wrapper = document.createElement('div');
                        wrapper.className = 'bracket-match-wrapper';
                        if (m.winner) {
                            wrapper.classList.add('completed');
                            card.classList.add('completed');
                        }
                        wrapper.appendChild(card);
                        matchesList.appendChild(wrapper);
                    });
                }

                column.appendChild(matchesList);
                return column;
            },
            playMatch: (matchIdx, roundIdx = null) => {
                requestWakeLock();
                SOUND_180.load();
                SOUND_INTRO.load();

                if (roundIdx === null) roundIdx = Tournament.state.currentActiveRound;
                const m = Tournament.state.bracketData[roundIdx][matchIdx];
                const roundInfo = Tournament.config.rounds[roundIdx];
                Tournament.activeMatchIdx = matchIdx;

                App.config.event = document.getElementById('tourn-event-name').value + ` - ${roundInfo.name}`;
                App.config.target = roundInfo.target;
                App.config.mode = Tournament.config.mode;
                App.config.tiebreak = Tournament.config.tiebreak;
                if (Tournament.config.mode === 'sets') {
                    const ev = Tournament.getCurrentEvent();
                    if (ev && ev.type === 'winmaudm') {
                        App.config.setLegs = 3; // Best of 3 legs per set (first to 2 wins the set)
                    } else {
                        App.config.setLegs = (roundInfo.target * 2) - 1;
                    }
                }

                App.startMatch(m.p1, m.p2, roundInfo.target);
            },
            // === NEW INTRO SEQUENCE ===
            playIntroSequence: (p1, p2) => {
                document.getElementById('ci-event').innerText = App.config.event.toUpperCase();
                document.getElementById('ci-p1').innerText = p1.name;
                document.getElementById('ci-n1').innerText = p1.country.toUpperCase();
                document.getElementById('ci-flag-1').src = getFlagUrl(p1.country);
                document.getElementById('ci-nation-1').innerText = p1.country.toUpperCase();

                document.getElementById('ci-p2').innerText = p2.name;
                document.getElementById('ci-n2').innerText = p2.country.toUpperCase();
                document.getElementById('ci-flag-2').src = getFlagUrl(p2.country);
                document.getElementById('ci-nation-2').innerText = p2.country.toUpperCase();

                const introDiv = document.getElementById('clean-intro');
                introDiv.style.display = 'flex';
                introDiv.style.opacity = '1';

                // Play Audio
                SOUND_INTRO.currentTime = 0;
                SOUND_INTRO.play().catch(e => console.log("Intro audio error", e));

                // Wait 6 seconds
                setTimeout(() => {
                    introDiv.style.transition = "opacity 1s ease";
                    introDiv.style.opacity = '0';
                    setTimeout(() => {
                        introDiv.style.display = 'none';
                        // Stop Audio
                        SOUND_INTRO.pause();
                        SOUND_INTRO.currentTime = 0;
                        // Start the match automatically after intro
                        App.startLeg();
                    }, 1000);
                }, 6000);
            },

            fastSim: (match, target) => {
                let s1 = 0, s2 = 0;
                const isBulkSim = Season.isBulkSim;

                // Optimize: Cache modifier lookups
                let mod1 = 0, mod2 = 0;
                if (typeof PlayerState !== 'undefined' && PlayerState.getPerformanceModifier) {
                    mod1 = PlayerState.getPerformanceModifier(match.p1);
                    mod2 = PlayerState.getPerformanceModifier(match.p2);
                }

                // Effective Averages - cache these values
                const eff1 = match.p1.avg * (1 + mod1);
                const eff2 = match.p2.avg * (1 + mod2);

                // Optimized win probability calculation with clamping
                let winProbP1 = 0.50 + ((eff1 - eff2) * 0.025);
                winProbP1 = winProbP1 < 0.01 ? 0.01 : (winProbP1 > 0.99 ? 0.99 : winProbP1);

                // Simulate match with minimal overhead
                while (s1 < target && s2 < target) {
                    if (Math.random() < winProbP1) s1++; else s2++;
                }

                match.score = [s1, s2];
                match.winner = (s1 > s2) ? match.p1 : match.p2;

                // Only generate detailed averages when not bulk simming
                if (!isBulkSim) {
                    match.averages = [
                        (eff1 + (Math.random() * 10 - 5)).toFixed(2),
                        (eff2 + (Math.random() * 10 - 5)).toFixed(2)
                    ];
                } else {
                    // Simpler averages for bulk sim
                    match.averages = [eff1.toFixed(2), eff2.toFixed(2)];
                }

                // Update Form/Fatigue - optimized for bulk sim
                if (typeof PlayerState !== 'undefined' && typeof PLAYERS_DB !== 'undefined') {
                    const diff = Math.abs(s1 - s2);
                    const winnerCopy = match.winner;
                    const loserCopy = (winnerCopy === match.p1) ? match.p2 : match.p1;

                    // Use cached name-to-index map for bulk sim performance
                    let winnerIdx, loserIdx;
                    if (isBulkSim && Tournament._playerIndexCache) {
                        winnerIdx = Tournament._playerIndexCache.get(winnerCopy.name);
                        loserIdx = Tournament._playerIndexCache.get(loserCopy.name);
                        if (winnerIdx === undefined) winnerIdx = PLAYERS_DB.findIndex(p => p.name === winnerCopy.name);
                        if (loserIdx === undefined) loserIdx = PLAYERS_DB.findIndex(p => p.name === loserCopy.name);
                    } else {
                        winnerIdx = PLAYERS_DB.findIndex(p => p.name === winnerCopy.name);
                        loserIdx = PLAYERS_DB.findIndex(p => p.name === loserCopy.name);
                    }

                    if (winnerIdx !== -1 && loserIdx !== -1) {
                        const winnerReal = PLAYERS_DB[winnerIdx];
                        const loserReal = PLAYERS_DB[loserIdx];

                        // Inline form updates for speed
                        const formDelta = diff >= 2 ? 3 : 1;
                        winnerReal.form = Math.min(100, Math.max(0, (winnerReal.form || 50) + formDelta));
                        loserReal.form = Math.min(100, Math.max(0, (loserReal.form || 50) - formDelta));
                        winnerReal.fatigue = Math.min(100, (winnerReal.fatigue || 0) + 5);
                        loserReal.fatigue = Math.min(100, (loserReal.fatigue || 0) + 5);

                        // Update local copies
                        winnerCopy.form = winnerReal.form;
                        winnerCopy.fatigue = winnerReal.fatigue;
                        loserCopy.form = loserReal.form;
                        loserCopy.fatigue = loserReal.fatigue;

                        // Skip news/rivalry tracking in bulk sim for speed
                        if (!isBulkSim) {
                            const ev = Tournament.getCurrentEvent();
                            const eventName = ev ? ev.name : (Tournament.config?.name || App.config?.event || "Tournament");

                            const isUpset = winnerIdx > loserIdx + 20;

                            if (isUpset && NewsSystem) {
                                NewsSystem.add('upset', {
                                    player: winnerCopy.name,
                                    rank: winnerIdx + 1,
                                    rival: loserCopy.name,
                                    event: eventName
                                });
                            }

                            if (typeof RivalryTracker !== 'undefined' && eventName) {
                                const isFinal = Tournament.state.bracketData &&
                                    Tournament.state.currentActiveRound === Tournament.state.bracketData.length - 1;
                                RivalryTracker.recordMatch(
                                    winnerCopy.name,
                                    loserCopy.name,
                                    eventName,
                                    isUpset,
                                    isFinal
                                );
                            }
                        }
                    }
                }
            },
            onMatchFinished: (winnerIdx, scoreStr, avgs) => {
                // PLAYER STATE UPDATES
                let matchObj = null;
                if (Tournament.activeGroupIdx !== undefined) {
                    matchObj = Tournament.state.groupMatches[Tournament.activeGroupIdx][Tournament.activeMatchIdx];
                } else if (Tournament.state.bracketData && Tournament.state.bracketData[Tournament.state.currentActiveRound]) {
                    matchObj = Tournament.state.bracketData[Tournament.state.currentActiveRound][Tournament.activeMatchIdx];
                }

                if (matchObj && matchObj.p1 && matchObj.p2) {
                    const winnerCopy = (winnerIdx === 0) ? matchObj.p1 : matchObj.p2;
                    const loserCopy = (winnerIdx === 0) ? matchObj.p2 : matchObj.p1;

                    // FIND REAL PLAYERS IN DB TO UPDATE PERSISTENT STATS
                    const winnerReal = (typeof PLAYERS_DB !== 'undefined') ? PLAYERS_DB.find(p => p.name === winnerCopy.name) : winnerCopy;
                    const loserReal = (typeof PLAYERS_DB !== 'undefined') ? PLAYERS_DB.find(p => p.name === loserCopy.name) : loserCopy;

                    const scores = scoreStr.split(' - ').map(Number);
                    const diff = Math.abs(scores[0] - scores[1]);

                    if (diff >= 2) {
                        PlayerState.updateForm(winnerReal, 3);
                        PlayerState.updateForm(loserReal, -3);
                    } else {
                        PlayerState.updateForm(winnerReal, 1);
                        PlayerState.updateForm(loserReal, -1);
                    }

                    if ((scores[0] + scores[1]) >= 10) {
                        PlayerState.updateFatigue(winnerReal, 10);
                        PlayerState.updateFatigue(loserReal, 10);
                    }
                    // Force save after manual match
                    if (typeof PlayerState !== 'undefined' && PlayerState.savePlayers) {
                        PlayerState.savePlayers();
                    }

                    // NEWS: Check for Upset (Rank diff > 20)
                    // Use findIndex with name because object reference might differ
                    const rankWin = (typeof PLAYERS_DB !== 'undefined') ? PLAYERS_DB.findIndex(p => p.name === winnerCopy.name) + 1 : 0;
                    const rankLose = (typeof PLAYERS_DB !== 'undefined') ? PLAYERS_DB.findIndex(p => p.name === loserCopy.name) + 1 : 0;

                    // Get proper event name
                    const ev = Tournament.getCurrentEvent();
                    const eventName = ev ? ev.name : (Tournament.config?.name || App.config?.event || "Tournament");

                    console.log('[NEWS] Match result:', winnerCopy.name, '(#' + rankWin + ') beat', loserCopy.name, '(#' + rankLose + ')');

                    const isUpset = rankWin > 0 && rankLose > 0 && rankWin > rankLose + 20;

                    if (isUpset) {
                        console.log('[NEWS] UPSET DETECTED! Adding upset news');
                        NewsSystem.add('upset', {
                            player: winnerCopy.name,
                            rank: rankWin,
                            rival: loserCopy.name,
                            event: eventName
                        });
                    }

                    // Track rivalries and generate beef
                    if (typeof RivalryTracker !== 'undefined' && eventName) {
                        const isFinal = Tournament.state.bracketData &&
                            Tournament.state.currentActiveRound === Tournament.state.bracketData.length - 1;
                        RivalryTracker.recordMatch(
                            winnerCopy.name,
                            loserCopy.name,
                            eventName,
                            isUpset,
                            isFinal
                        );
                    }
                }

                // Check if this is a Grand Slam group stage match
                if (Tournament.activeGroupIdx !== undefined) {
                    const groupIdx = Tournament.activeGroupIdx;
                    const matchIdx = Tournament.activeMatchIdx;
                    const match = Tournament.state.groupMatches[groupIdx][matchIdx];
                    const standings = Tournament.state.groupStandings[groupIdx];

                    const scores = scoreStr.split(' - ').map(Number);
                    match.score = scores;
                    match.winner = (winnerIdx === 0) ? match.p1 : match.p2;
                    match.averages = avgs;

                    // Update standings
                    const winner = match.winner;
                    const loser = (winnerIdx === 0) ? match.p2 : match.p1;

                    standings[winner.name].wins++;
                    standings[winner.name].points += 2;
                    standings[winner.name].legsFor += scores[winnerIdx];
                    standings[winner.name].legsAgainst += scores[1 - winnerIdx];

                    standings[loser.name].losses++;
                    standings[loser.name].legsFor += scores[1 - winnerIdx];
                    standings[loser.name].legsAgainst += scores[winnerIdx];

                    // Check if all group matches are complete
                    const allGroupsComplete = Tournament.state.groupMatches.every(gm => gm.every(m => m.winner));

                    if (allGroupsComplete) {
                        // All group stages complete - move to knockout
                        Tournament.initiateGrandSlamKnockout();
                    } else {
                        Tournament.renderGrandSlamGroupStage();
                    }
                    Persistence.save();
                } else {
                    // Regular knockout tournament
                    const rIdx = Tournament.state.currentActiveRound;
                    const m = Tournament.state.bracketData[rIdx][Tournament.activeMatchIdx];
                    const scores = scoreStr.split(' - ').map(Number);
                    m.score = scores;
                    m.winner = (winnerIdx === 0) ? m.p1 : m.p2;
                    m.averages = avgs;

                    Persistence.save();
                    Tournament.checkRoundComplete();

                    // If an advancement animation is in progress, wait for it to finish
                    if (Tournament.roundAdvanceAnimating) return;

                    // Only render if tournament is still active
                    if (Tournament.state.active) {
                        if (Tournament.state.matchQueue && Tournament.state.matchQueue.length > 0) {
                            Tournament.playNextInQueue();
                        } else {
                            Tournament.renderHub();
                        }
                    }
                }
            },
            initiateGrandSlamKnockout: () => {
                const isBulkSim = typeof Season !== 'undefined' && Season.isBulkSim;

                // Get top 2 from each group
                const qualifiers = [];

                for (let g = 0; g < Tournament.state.groupStageData.length; g++) {
                    const standings = Tournament.state.groupStandings[g];
                    const sorted = Object.entries(standings)
                        .map(([name, stats]) => ({
                            player: Tournament.state.groupStageData[g].find(p => p.name === name),
                            stats: stats
                        }))
                        .sort((a, b) => {
                            if (b.stats.points !== a.stats.points) return b.stats.points - a.stats.points;
                            return (b.stats.legsFor - b.stats.legsAgainst) - (a.stats.legsFor - a.stats.legsAgainst);
                        });

                    qualifiers.push(sorted[0].player, sorted[1].player);
                }

                // Create knockout bracket
                Tournament.state.bracketData = [];
                // Index 0 is reserved for group stage (not in bracketData, stored in groupMatches)
                Tournament.state.bracketData.push([]); // Empty placeholder for groups

                const r0 = [];
                for (let i = 0; i < qualifiers.length; i += 2) {
                    r0.push({ p1: qualifiers[i], p2: qualifiers[i + 1], winner: null, score: null, averages: null });
                }

                Tournament.state.bracketData.push(r0); // L16 at index 1
                for (let i = 2; i < 5; i++) {
                    Tournament.state.bracketData.push([]); // QF, SF, F at indices 2-4
                }

                Tournament.state.currentActiveRound = 1; // Start at L16
                Tournament.state.viewingRound = 1;
                Tournament.activeGroupIdx = undefined;
                Tournament.config.isGroupStage = false;

                // Skip UI updates during bulk simulation
                if (!isBulkSim) {
                    Persistence.save();
                    Tournament.renderHub();
                }
            },
            checkRoundComplete: () => {
                const rIdx = Tournament.state.currentActiveRound;
                const matches = Tournament.state.bracketData[rIdx];
                Tournament.roundAdvanceAnimating = false;

                // Skip if matches is empty or invalid (e.g., Grand Slam placeholder round)
                if (!matches || matches.length === 0) {
                    return;
                }

                const advanceToNextRound = () => {
                    const nextRIdx = rIdx + 1;
                    if (Tournament.state.bracketData.length <= nextRIdx || Tournament.state.bracketData[nextRIdx].length === 0) {
                        const nextMatches = [];
                        for (let i = 0; i < matches.length; i += 2) {
                            const p1Winner = matches[i] ? matches[i].winner : null;
                            const p2Winner = matches[i + 1] ? matches[i + 1].winner : null;
                            nextMatches.push({ p1: p1Winner, p2: p2Winner, winner: null, score: null, averages: null });
                        }
                        Tournament.state.bracketData[nextRIdx] = nextMatches;
                        Tournament.state.currentActiveRound = nextRIdx;
                        Tournament.state.viewingRound = nextRIdx;
                    }
                };

                if (matches.every(m => m.winner)) {
                    // Special handling for UK Open
                    if (Tournament.config.eventType === 'uk-open') {
                        Tournament.checkRoundCompleteUkOpen();
                        return;
                    }

                    if (rIdx === Tournament.config.rounds.length - 1) {
                        // Tournament is complete - get winner info BEFORE changing state
                        const finalMatch = matches[0];
                        const winner = finalMatch.winner;
                        const runnerUp = finalMatch.p1 === winner ? finalMatch.p2 : finalMatch.p1;
                        const tournamentName = Tournament.config.name || document.getElementById('tourn-event-name')?.value || 'CUSTOM TOURNAMENT';

                        // AUTOSAVE: Save tournament result to history BEFORE clearing state
                        Persistence.saveTournamentResult(winner, runnerUp, tournamentName, Tournament.state.bracketData);
                        console.log(`[Tournament Complete] Winner: ${winner?.name}, saved to history`);

                        if (typeof Season === 'undefined' || !Season.silentSimulation) {
                            // Show celebration overlay instead of alert
                            Tournament.showCelebration("TOURNAMENT WINNER", winner?.name || 'Unknown', [winner?.name || 'Unknown']);
                        }

                        Tournament.state.active = false;
                        Persistence.save();

                        // CRITICAL: For Premier League simulations, DO NOT call completeEvent here!
                        // Premier League handles completion in initializePremierLeague after the simulation loop
                        // to avoid cascading to the next night automatically
                        if ((Tournament.config.eventType === 'premier-league' || Tournament.config.eventType === 'premier-league-playoff') && Season.silentSimulation) {
                            console.log(`[checkRoundComplete] PL sim detected, NOT calling completeEvent (will be called by initializePremierLeague)`);
                            return;
                        }

                        if (Season.state.inProgress) {
                            // Ensure we don't recursive call completeEvent if it's already running or completed
                            if (Season.guardAgainstAutoStart) {
                                console.warn('[checkRoundComplete] Guard is active, skipping auto-completeEvent');
                                return;
                            }
                            Season.completeEvent(Tournament.state.bracketData);
                            return;
                        } else {
                            // Non-season mode: Stay in tournament hub to show results, don't auto-exit
                            // User can click "Exit Tournament" when ready
                            Tournament.renderHub();
                            return;
                        }
                    }

                    const shouldAnimate = !Tournament.skipAdvancementAnimation && !(typeof Season !== 'undefined' && Season.silentSimulation);
                    if (shouldAnimate) {
                        const advancingPlayers = matches
                            .map(m => ({ player: m.winner, avg: m.averages ? m.averages[m.winner === m.p1 ? 0 : 1] : null }))
                            .filter(p => p && p.player);

                        Tournament.roundAdvanceAnimating = true;
                        Tournament.showAdvancementAnimation(advancingPlayers, rIdx);

                        setTimeout(() => {
                            Tournament.closeAdvancementOverlay();
                            advanceToNextRound();
                            Tournament.roundAdvanceAnimating = false;
                            Persistence.save();
                            Tournament.renderHub();
                        }, 1300);
                        return;
                    }

                    advanceToNextRound();
                }
            },

            checkRoundCompleteUkOpen: () => {
                const rIdx = Tournament.state.currentActiveRound;
                const matches = Tournament.state.bracketData[rIdx];

                if (!matches.every(m => m.winner)) return;

                if (rIdx === Tournament.config.rounds.length - 1) {
                    // Get winner info BEFORE changing state for autosave
                    const finalMatch = matches[0];
                    const winner = finalMatch.winner;
                    const runnerUp = finalMatch.p1 === winner ? finalMatch.p2 : finalMatch.p1;
                    const tournamentName = Tournament.config.name || document.getElementById('tourn-event-name')?.value || 'UK OPEN';

                    // AUTOSAVE: Save tournament result to history
                    Persistence.saveTournamentResult(winner, runnerUp, tournamentName, Tournament.state.bracketData);
                    console.log(`[UK Open Complete] Winner: ${winner?.name}, saved to history`);

                    if (!Season.silentSimulation && !Season.isBulkSim) {
                        Tournament.showCelebration("TOURNAMENT WINNER", matches[0].winner.name, [matches[0].winner.name]);
                    }

                    if (Season.isBulkSim) {
                        Tournament.state.active = false;
                        Persistence.save();
                        Season.completeEvent(Tournament.state.bracketData);
                    } else {
                        // Interactive mode: Wait for user to dismiss overlay
                        // The "Exit Tournament" button in Hub will handle data cleanup
                        // But we mark tournament as inactive instantly to prevent re-sim
                        Tournament.state.active = false;
                        Persistence.save();
                        // Also trigger season completion in background
                        if (Season.state.inProgress) {
                            Season.completeEvent(Tournament.state.bracketData);
                        } else {
                            // Non-season mode: Stay in hub to show results
                            Tournament.renderHub();
                        }
                    }
                    return;
                }

                Tournament.advanceUkOpenRound();
            },

            advanceUkOpenRound: () => {
                const rIdx = Tournament.state.currentActiveRound;
                const matches = Tournament.state.bracketData[rIdx];
                const winners = matches.map(m => m.winner).filter(Boolean);
                const nextRIdx = rIdx + 1;

                // Get entrants for next round based on current round
                let entrantsIdx = [];
                if (rIdx === 0) entrantsIdx = Tournament.state.ukOpenEntrants?.R2 || [];  // Round 2 entrants (32)
                else if (rIdx === 1) entrantsIdx = Tournament.state.ukOpenEntrants?.R3 || []; // Round 3 entrants (32)
                else if (rIdx === 2) entrantsIdx = Tournament.state.ukOpenEntrants?.R4Top32 || []; // Last 64 seeds (32)

                console.log(`üîç UK Open R${rIdx} complete: ${winners.length} winners, ${entrantsIdx.length} entrants available`);

                const entrants = entrantsIdx.map(i => PLAYERS_DB[i] ? { ...PLAYERS_DB[i] } : null).filter(p => p && p.name);

                // Show which players are joining this round
                if (entrants.length > 0 && !Season.silentSimulation) {
                    const roundNames = ['R2', 'R3', 'Last 64'];
                    const roundName = roundNames[rIdx] || `Round ${nextRIdx}`;
                    const playerNames = entrants.map(p => p.name).join(', ');
                    console.log(`üéØ ${entrants.length} players joining ${roundName}`);
                    alert(`${entrants.length} players joining ${roundName}:\n\n${playerNames}`);
                }

                let combined = winners.concat(entrants);

                // Ensure even number of players
                if (combined.length % 2 !== 0) {
                    combined = combined.slice(0, combined.length - 1);
                }

                const nextMatches = [];

                // SPECIAL SEEDING for Last 64 (R3‚ÜíL64): Top 32 seeds vs R3 winners
                if (rIdx === 2) {
                    const top32 = entrants;      // 32 seeded players in OOM order
                    const r3Winners = winners.slice(0, 32); // R3 winners (unseeded)

                    console.log(`üèÜ Seeding Last 64: 32 seeds + 32 R3 winners = 64 players`);

                    // Standard bracket seeding pattern
                    const seedPairs = [
                        [0, 31], [16, 15],  // 1v32, 17v16 ‚Üí L32 match 0
                        [8, 23], [24, 7],   // 9v24, 25v8 ‚Üí L32 match 1
                        [4, 27], [20, 11],  // 5v28, 21v12 ‚Üí L32 match 2
                        [12, 19], [28, 3],  // 13v20, 29v4 ‚Üí L32 match 3
                        [2, 29], [18, 13],  // 3v30, 19v14 ‚Üí L32 match 4
                        [10, 21], [26, 5],  // 11v22, 27v6 ‚Üí L32 match 5
                        [6, 25], [22, 9],   // 7v26, 23v10 ‚Üí L32 match 6
                        [14, 17], [30, 1],  // 15v18, 31v2 ‚Üí L32 match 7
                        [1, 30], [17, 14],  // 2v31, 18v15 ‚Üí L32 match 8
                        [9, 22], [25, 6],   // 10v23, 26v7 ‚Üí L32 match 9
                        [5, 26], [21, 10],  // 6v27, 22v11 ‚Üí L32 match 10
                        [13, 18], [29, 2],  // 14v19, 30v3 ‚Üí L32 match 11
                        [3, 28], [19, 12],  // 4v29, 20v13 ‚Üí L32 match 12
                        [11, 20], [27, 4],  // 12v21, 28v5 ‚Üí L32 match 13
                        [7, 24], [23, 8],   // 8v25, 24v9 ‚Üí L32 match 14
                        [15, 16], [31, 0]   // 16v17, 32v1 ‚Üí L32 match 15
                    ];

                    for (const [seed1Idx, seed2Idx] of seedPairs) {
                        if (top32[seed1Idx] && r3Winners[seed2Idx]) {
                            nextMatches.push({
                                p1: top32[seed1Idx],
                                p2: r3Winners[seed2Idx],
                                winner: null,
                                score: null,
                                averages: null
                            });
                        }
                    }
                } else {
                    // R1‚ÜíR2 and R2‚ÜíR3: OPEN DRAW (random shuffle)
                    for (let i = combined.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [combined[i], combined[j]] = [combined[j], combined[i]];
                    }

                    for (let i = 0; i < combined.length; i += 2) {
                        if (combined[i] && combined[i + 1]) {
                            nextMatches.push({ p1: combined[i], p2: combined[i + 1], winner: null, score: null, averages: null });
                        }
                    }
                }

                console.log(`UK Open advancing to round ${nextRIdx}: ${winners.length} winners + ${entrants.length} entrants = ${combined.length} total ‚Üí ${nextMatches.length} matches`);

                Tournament.state.bracketData[nextRIdx] = nextMatches;
                Tournament.state.currentActiveRound = nextRIdx;
                Tournament.state.viewingRound = nextRIdx;
                Persistence.save();
            },

            checkRoundCompleteNoAutoAdvance: () => {
                const rIdx = Tournament.state.currentActiveRound;
                const matches = Tournament.state.bracketData[rIdx];

                const advanceToNextRound = () => {
                    const nextRIdx = rIdx + 1;
                    if (Tournament.state.bracketData.length <= nextRIdx || Tournament.state.bracketData[nextRIdx].length === 0) {
                        const nextMatches = [];
                        for (let i = 0; i < matches.length; i += 2) {
                            nextMatches.push({ p1: matches[i].winner, p2: matches[i + 1].winner, winner: null, score: null, averages: null });
                        }
                        Tournament.state.bracketData[nextRIdx] = nextMatches;
                    }
                    Tournament.state.currentActiveRound = nextRIdx;
                    Tournament.state.viewingRound = nextRIdx;
                    Persistence.save();
                };

                if (matches.every(m => m.winner)) {
                    const isFinal = rIdx === Tournament.config.rounds.length - 1;
                    const shouldAnimate = !Tournament.skipAdvancementAnimation && !(typeof Season !== 'undefined' && Season.silentSimulation);
                    const advancingPlayers = matches
                        .map(m => ({ player: m.winner, avg: m.averages ? m.averages[m.winner === m.p1 ? 0 : 1] : null }))
                        .filter(p => p && p.player);

                    if (shouldAnimate && advancingPlayers.length > 0) {
                        Tournament.roundAdvanceAnimating = true;
                        Tournament.showAdvancementAnimation(advancingPlayers, rIdx);
                        setTimeout(() => {
                            Tournament.closeAdvancementOverlay();
                            Tournament.roundAdvanceAnimating = false;
                            if (isFinal) {
                                alert(`${matches[0].winner.name} WINS THE NIGHT!`);
                                Tournament.state.active = false;
                                Persistence.save();
                                if (Season.state.inProgress) {
                                    Season.completeEvent(Tournament.state.bracketData);
                                } else {
                                    Persistence.clearTournamentOnly();
                                    document.getElementById('setup-screen').style.display = 'flex';
                                    document.getElementById('tournament-hub').style.display = 'none';
                                }
                                return;
                            }
                            advanceToNextRound();
                            Tournament.renderHub();
                        }, 1300);
                        return;
                    }

                    if (rIdx === Tournament.config.rounds.length - 1) {
                        if (!Season.silentSimulation) {
                            alert(`${matches[0].winner.name} WINS THE NIGHT!`);
                        }
                        Tournament.state.active = false;
                        Persistence.save();

                        if (Season.state.inProgress) {
                            // If this is a silent simulation (managed by initializePremierLeague loop), 
                            // DO NOT call completeEvent here. Let the loop controller handle it.
                            if (Season.silentSimulation && (Tournament.config.eventType === 'premier-league' || Tournament.config.eventType === 'premier-league-playoff')) {
                                console.log('[checkRoundCompleteNoAutoAdvance] PL silent sim completed round, active=false, checking out to let loop finish');
                                return;
                            }
                            Season.completeEvent(Tournament.state.bracketData);
                            return;
                        } else {
                            Persistence.clearTournamentOnly();
                            document.getElementById('setup-screen').style.display = 'flex';
                            document.getElementById('tournament-hub').style.display = 'none';
                            return;
                        }
                        return;
                    }
                }
                // For Premier League: prepare next round and advance to it
                advanceToNextRound();
                Tournament.renderHub();
            }
        }

        // Make these globally accessible for onclick handlers
        window.App = {
            config: { mode: 'sets', target: 3, setLegs: 3 },
            players: [],
            matchState: { sets: [0, 0], legs: [0, 0], starterLeg: 0, starterSet: 0, currentThrower: 0 },
            selectedPlayers: { p1: 0, p2: 1 },
            isPaused: false,

            init: () => {
                // Initialize Players (deduplicate by normalized name)
                const uniquePlayers = []; const seenNames = new Set();
                const normalizeName = (raw) => {
                    let name = raw || "";
                    if (name.includes(',')) {
                        const parts = name.split(',');
                        name = `${parts[1].trim()} ${parts[0].trim()}`;
                    }
                    return name.trim().replace(/\s+/g, ' ');
                };

                // IF RAW_PLAYERS IS EMPTY, GENERATE DUMMIES
                if (RAW_PLAYERS.length === 0) {
                    for (let i = 1; i <= 128; i++) {
                        RAW_PLAYERS.push({
                            name: `Qualifier ${i}`,
                            country: 'eng',
                            avg: 80 + Math.random() * 15,
                            co: 30 + Math.random() * 20,
                            fav: 20,
                            money: 0,
                            tourCard: i <= 64
                        });
                    }
                }

                RAW_PLAYERS.forEach(p => {
                    const cleanName = normalizeName(p.name);
                    const key = cleanName.toLowerCase();
                    if (!seenNames.has(key)) {
                        seenNames.add(key);
                        const player = {
                            ...p,
                            name: cleanName,
                            form: p.form !== undefined ? p.form : 50,
                            fatigue: p.fatigue !== undefined ? p.fatigue : 0,
                            consistency: p.consistency !== undefined ? p.consistency : 50
                        };
                        uniquePlayers.push(player);
                    }
                });
                PLAYERS_DB.push(...uniquePlayers);

                // Load custom career players from storage
                try {
                    const customPlayers = JSON.parse(localStorage.getItem('pdc_custom_players') || '[]');
                    if (Array.isArray(customPlayers)) {
                        customPlayers.forEach(p => {
                            const key = (p.name || '').trim().toLowerCase();
                            if (key && !seenNames.has(key)) {
                                seenNames.add(key);
                                PLAYERS_DB.push({ ...p, name: normalizeName(p.name) });
                            }
                        });
                    }
                } catch (e) {
                    console.warn('Failed to load custom players:', e);
                }

                const inpP1 = document.getElementById('inp-p1-text');
                const inpP2 = document.getElementById('inp-p2-text');
                if (inpP1) {
                    App.renderDropdown('p1');
                    inpP1.value = PLAYERS_DB[0].name;
                }
                if (inpP2) {
                    App.renderDropdown('p2');
                    inpP2.value = PLAYERS_DB[1].name;
                }
                Tournament.updateConfigUI();

                // Load saved state FIRST before initializing
                Persistence.load();

                // Check for cloud sync if logged in
                AuthSystem.init();

                // Initialize Season logic (will only init if no data exists)
                Season.init();

                // OOM Tab logic
                const btnMain = document.getElementById("btn-main-oom");
                const btnPro = document.getElementById("btn-protour-oom");
                const btnChallenge = document.getElementById("btn-challenge-oom");
                const btnWs = document.getElementById("btn-ws-oom");
                if (btnMain) btnMain.onclick = () => { Season.state.activeOOMView = "main"; Season.renderUI(); };
                if (btnPro) btnPro.onclick = () => { Season.state.activeOOMView = "pro"; Season.renderUI(); };
                if (btnChallenge) btnChallenge.onclick = () => { Season.state.activeOOMView = "challenge"; Season.renderUI(); };
                if (btnWs) btnWs.onclick = () => { Season.state.activeOOMView = "worldseries"; Season.renderUI(); };

                document.addEventListener('click', function (event) {
                    const listP1 = document.getElementById('list-p1');
                    const listP2 = document.getElementById('list-p2');
                    if (listP1 && !listP1.parentElement.contains(event.target)) listP1.style.display = 'none';
                    if (listP2 && !listP2.parentElement.contains(event.target)) listP2.style.display = 'none';
                });
                const btnEndMatch = document.getElementById('btn-end-match');
                if (btnEndMatch) btnEndMatch.addEventListener('click', App.showPostMatch);

                // Auto-start in Career Mode (fullscreen)
                setTimeout(() => {
                    App.switchTab('season');
                }, 100);
            },
            renderDropdown: (id) => {
                const list = document.getElementById(`list-${id}`);
                let html = '';
                PLAYERS_DB.forEach((p, idx) => {
                    const flag = getFlagUrl(p.country);
                    const badge = p.tourCard ? '<span class="tc-badge">TC</span>' : '';
                    html += `<div class="search-item" data-name="${p.name.toLowerCase()}" onclick="selectPlayer('${id}', ${idx})">
                                <img src="${flag}"><span>${p.name}</span>${badge}
                             </div>`;
                });
                list.innerHTML = html;
            },

            showDropdown: (id) => { document.getElementById(`list-${id}`).style.display = 'block'; },
            filterDropdown: (id) => {
                const term = document.getElementById(`inp-${id}-text`).value.toLowerCase();
                const list = document.getElementById(`list-${id}`);
                list.style.display = 'block';
                const items = list.getElementsByClassName('search-item');
                for (let item of items) { item.style.display = item.getAttribute('data-name').includes(term) ? 'flex' : 'none'; }
            },
            selectPlayer: (id, idx) => {
                App.selectedPlayers[id] = idx;
                document.getElementById(`inp-${id}-text`).value = PLAYERS_DB[idx].name;
                document.getElementById(`list-${id}`).style.display = 'none';
            },
            switchTab: (tabName) => {
                // Hide all tabs
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

                // Activate target
                const btn = document.getElementById(`tab-btn-${tabName}`);
                const content = document.getElementById(`tab-${tabName}`);

                if (btn) btn.classList.add('active');
                if (content) content.classList.add('active');

                document.body.classList.toggle('career-fullscreen', tabName === 'season');

                // Handle News Render
                if (tabName === 'news' && typeof NewsSystem !== 'undefined') {
                    NewsSystem.renderNews(NewsSystem.viewState.filter);
                }

                if (tabName === 'season' && typeof Season !== 'undefined' && Season.renderUI) {
                    Season.renderUI();
                }

                // Handle initial render for Standings
                if (tabName === 'standings') {
                    // Default to OOM if nothing active
                    if (!document.querySelector('.standing-section.active')) {
                        App.switchStandingSection('oom');
                    } else {
                        // Re-render currently active section
                        if (document.getElementById('section-premier').classList.contains('active')) Season.renderPremierLeagueStandings();
                        if (document.getElementById('section-qschool').classList.contains('active')) Season.renderQSchoolStandings();
                        if (document.getElementById('section-oom').classList.contains('active')) {
                            // Render OOM
                            Season.renderOOMTable('oom-hub-main', Season.state.orderOfMerit);
                            Season.renderOOMTable('oom-hub-pro', Season.state.proTourOOM);
                            Season.renderOOMTable('oom-hub-challenge', Season.state.challengeTourOOM);
                            Season.renderOOMTable('oom-hub-ws', Season.state.worldSeriesOOM);
                        }
                    }
                }
            },

            switchStandingSection: (section) => {
                // Nav buttons
                document.querySelectorAll('.std-btn').forEach(b => b.classList.remove('active'));
                document.getElementById(`std-btn-${section}`).classList.add('active');

                // Sections
                document.querySelectorAll('.standing-section').forEach(s => s.classList.remove('active'));
                document.getElementById(`section-${section}`).classList.add('active');

                // Render data
                if (section === 'premier') Season.renderPremierLeagueStandings();
                else if (section === 'qschool') Season.renderQSchoolStandings();
                else if (section === 'oom') {
                    Season.renderOOMTable('oom-hub-main', Season.state.orderOfMerit);
                    Season.renderOOMTable('oom-hub-pro', Season.state.proTourOOM);
                    Season.renderOOMTable('oom-hub-challenge', Season.state.challengeTourOOM);
                    Season.renderOOMTable('oom-hub-ws', Season.state.worldSeriesOOM);
                }
            },
            switchOOMView: (view) => {
                document.querySelectorAll('#oom-btn-main, #oom-btn-pro, #oom-btn-challenge, #oom-btn-ws, #oom-btn-form').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.oom-view').forEach(v => v.classList.remove('active'));
                document.getElementById(`oom-btn-${view}`).classList.add('active');
                document.getElementById(`oom-view-${view}`).classList.add('active');

                if (view === 'main') Season.renderOOMTable('oom-hub-main', Season.state.orderOfMerit);
                else if (view === 'pro') Season.renderOOMTable('oom-hub-pro', Season.state.proTourOOM);
                else if (view === 'challenge') Season.renderOOMTable('oom-hub-challenge', Season.state.challengeTourOOM);
                else if (view === 'ws') Season.renderOOMTable('oom-hub-ws', Season.state.worldSeriesOOM);
                else if (view === 'form') Season.renderFormFatigueTable('oom-hub-form');
            },
            switchQSchoolView: (location) => {
                document.querySelectorAll('#qschool-btn-uk, #qschool-btn-eu').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.qschool-view').forEach(v => v.classList.remove('active'));
                document.getElementById(`qschool-btn-${location}`).classList.add('active');
                document.getElementById(`qschool-standings-${location}`).classList.add('active');
            },
            setMode: (mode) => {
                App.config.mode = mode;
                const btnSets = document.getElementById('btn-sets');
                const btnLegs = document.getElementById('btn-legs');
                if (btnSets) btnSets.className = `format-btn ${mode === 'sets' ? 'selected' : ''}`;
                if (btnLegs) btnLegs.className = `format-btn ${mode === 'legs' ? 'selected' : ''}`;
                const legDiv = document.getElementById('legs-per-set-div');
                if (legDiv) legDiv.style.display = (mode === 'sets') ? 'block' : 'none';
                const lblTarget = document.getElementById('lbl-target');
                if (lblTarget) lblTarget.innerText = (mode === 'sets') ? "Sets" : "Legs";
                const sel = document.getElementById('inp-target');
                if (sel) {
                    if (mode === 'legs') {
                        sel.innerHTML = `<option>3</option><option>5</option><option>7</option><option>10</option><option>11</option><option>13</option><option>15</option><option>18</option><option>21</option>`;
                    }
                    else { sel.innerHTML = `<option>1</option><option>3</option><option>5</option><option>7</option>`; sel.value = 3; }
                }
            },
            applyEventColors: (eventName) => {
                const eventBar = document.querySelector('.event-bar');
                const scoreboardHeader = document.getElementById('scoreboard-header');
                const bottomBar = document.querySelector('.bottom-bar');
                const visitBoard = document.getElementById('visit-container');
                const eventLogo = document.getElementById('event-logo');
                const pdcLogo = document.getElementById('pdc-logo');

                // Reset theme classes
                scoreboardHeader.className = 'scoreboard-header';
                if (bottomBar) {
                    bottomBar.className = 'bottom-bar';
                    bottomBar.style.background = ''; // Reset inline custom theme style
                }
                if (visitBoard) {
                    visitBoard.className = 'visit-board';
                    visitBoard.style.background = ''; // Reset inline custom theme style
                }

                // Reset to default settings first
                eventBar.style.background = '#111';
                eventLogo.src = "";
                eventLogo.style.display = 'none';
                pdcLogo.style.display = 'block';

                // ================= THEME RESOLUTION =================
                let themeConfig = null;
                const isCustomTab = document.getElementById('tab-tourn')?.classList.contains('active');
                const setupScreenVisible = document.getElementById('setup-screen')?.style.display !== 'none';

                // prioritize UI selection if in custom tab setup
                if (isCustomTab && setupScreenVisible && !Tournament.state.active) {
                    const themeEl = document.getElementById('tourn-theme');
                    if (themeEl) {
                        if (themeEl.value === 'custom') {
                            const c1 = document.getElementById('theme-col-1')?.value || '#000';
                            const c2 = document.getElementById('theme-col-2')?.value || '#fff';
                            themeConfig = { mode: 'custom', color1: c1, color2: c2 };
                        } else if (themeEl.value !== 'default') {
                            themeConfig = { mode: 'preset', id: themeEl.value };
                        }
                    }
                }

                if (!themeConfig) {
                    if (typeof Tournament !== 'undefined' && Tournament.config.theme) {
                        themeConfig = Tournament.config.theme;
                    } else if (typeof App !== 'undefined' && App.config.theme) {
                        themeConfig = App.config.theme;
                    }
                }

                // Normalization
                if (typeof themeConfig === 'string') {
                    themeConfig = { mode: 'preset', id: themeConfig };
                }

                // 1. CUSTOM THEME (from theme selector UI)
                if (themeConfig && themeConfig.mode === 'custom') {
                    eventBar.style.background = `linear-gradient(135deg, ${themeConfig.color1} 0%, ${themeConfig.color2} 100%)`;
                    eventLogo.style.display = 'none';
                    pdcLogo.style.display = 'block';
                    // Apply custom theme to bottom bar (solid gradient, no transparency)
                    if (bottomBar) {
                        bottomBar.style.background = `linear-gradient(135deg, ${themeConfig.color1} 0%, ${themeConfig.color2} 100%)`;
                    }
                    // Don't apply custom background to visit board - keep default
                    return;
                }

                // 2. PRESET THEME - Just use the themeId directly from Tournament.config
                const themeId = (themeConfig && themeConfig.mode === 'preset') ? themeConfig.id : null;

                // Get the hardcoded defaults
                const defaultThemes = DataLoader.getDefaultThemes();

                // Simple lookup: check EVENT_THEMES first, then defaults
                let matchedTheme = null;

                console.log('[Theme] Using themeId:', themeId);

                if (themeId && EVENT_THEMES && EVENT_THEMES[themeId]) {
                    matchedTheme = EVENT_THEMES[themeId];
                    console.log('[Theme] Found in EVENT_THEMES:', themeId);
                }
                else if (themeId && defaultThemes[themeId]) {
                    matchedTheme = defaultThemes[themeId];
                    console.log('[Theme] Found in defaults:', themeId);
                }
                else {
                    // Last resort fallback
                    matchedTheme = defaultThemes['minor'] || { color1: '#1A1A1A', color2: '#2E2E2E' };
                    console.log('[Theme] Fallback to minor');
                }

                // Apply the matched theme
                if (matchedTheme) {
                    // Store current theme globally for use by other functions
                    App.currentTheme = matchedTheme;

                    // Debug log
                    console.log('[Theme] Applied theme:', matchedTheme);

                    // Use color1/color2 format (matches admin.html)
                    const color1 = matchedTheme.color1 || (matchedTheme.gradient ? matchedTheme.gradient[0] : '#111');
                    const color2 = matchedTheme.color2 || (matchedTheme.gradient ? matchedTheme.gradient[1] : '#333');

                    eventBar.style.background = `linear-gradient(135deg, ${color1} 0%, ${color2} 100%)`;

                    // Use theme logo
                    if (matchedTheme.logo) {
                        eventLogo.src = matchedTheme.logo;
                        eventLogo.style.display = 'block';
                        pdcLogo.style.display = 'none';
                    } else {
                        eventLogo.style.display = 'none';
                        pdcLogo.style.display = 'block';
                    }

                    // Apply CSS class for visit-board and other CSS-only styles
                    const cssClass = matchedTheme.theme || matchedTheme.cssClass;
                    if (cssClass) {
                        scoreboardHeader.classList.add(cssClass);
                        if (bottomBar) bottomBar.classList.add(cssClass);
                        if (visitBoard) visitBoard.classList.add(cssClass);
                    }

                    // Apply bottom bar gradient from theme data
                    if (bottomBar) {
                        bottomBar.style.background = `linear-gradient(135deg, ${color2} 0%, ${color1} 100%)`;
                    }

                    // Apply leg name color from theme data
                    if (bottomBar && matchedTheme.legNameColor) {
                        const legNames = bottomBar.querySelectorAll('.leg-name');
                        legNames.forEach(ln => ln.style.color = matchedTheme.legNameColor);
                    }
                } else {
                    // No theme found - apply default dark gradient as fallback
                    console.warn('[Theme] No theme found, applying fallback gradient');
                    eventBar.style.background = 'linear-gradient(135deg, #1A1A1A 0%, #2E2E2E 100%)';
                    eventLogo.style.display = 'none';
                    pdcLogo.style.display = 'block';
                    if (bottomBar) {
                        bottomBar.style.background = 'linear-gradient(135deg, #2E2E2E 0%, #1A1A1A 100%)';
                    }
                }
            },

            // Apply active player theme gradient from database
            applyActivePlayerTheme: (activeIdx) => {
                const theme = App.currentTheme;
                const card0 = document.getElementById('card-p0');
                const card1 = document.getElementById('card-p1');
                const nameStrip0 = card0 ? card0.querySelector('.name-strip') : null;
                const nameStrip1 = card1 ? card1.querySelector('.name-strip') : null;

                // Default inactive gradient
                const inactiveGradient = 'linear-gradient(to bottom, #4c6478, #2f4254)';
                // Default active gradient (red)
                const defaultActiveGradient = 'linear-gradient(to bottom, #e00000, #9a0000)';

                if (theme && theme.activeGradient) {
                    const activeGradient = `linear-gradient(to bottom, ${theme.activeGradient[0]}, ${theme.activeGradient[1]})`;
                    if (nameStrip0) nameStrip0.style.background = activeIdx === 0 ? activeGradient : inactiveGradient;
                    if (nameStrip1) nameStrip1.style.background = activeIdx === 1 ? activeGradient : inactiveGradient;
                } else {
                    if (nameStrip0) nameStrip0.style.background = activeIdx === 0 ? defaultActiveGradient : inactiveGradient;
                    if (nameStrip1) nameStrip1.style.background = activeIdx === 1 ? defaultActiveGradient : inactiveGradient;
                }
            },

            startMatch: (p1Override, p2Override, targetOverride) => {
                requestWakeLock();
                SOUND_180.load();
                SOUND_167.load();
                SOUND_BIG_CHECKOUT.load();
                SOUND_INTRO.load();
                SOUND_OUTRO.load();

                const createPlayer = (p) => ({
                    ...p,
                    score: 501,
                    stats: { pts: 0, darts: 0, c180: 0, coAtt: 0, coHit: 0, highOut: 0, tonPlus: 0, legsWon: 0 }
                });

                if (p1Override) {
                    App.players = [createPlayer(p1Override), createPlayer(p2Override)];
                    App.config.target = targetOverride;
                } else {
                    // Use currently selected indices from the dropdowns
                    const i1 = App.selectedPlayers.p1;
                    const i2 = App.selectedPlayers.p2;
                    App.players = [createPlayer(PLAYERS_DB[i1]), createPlayer(PLAYERS_DB[i2])];
                    if (!Season.state.inProgress) {
                        App.config.target = parseInt(document.getElementById('inp-target').value);
                    }
                    App.config.event = document.getElementById('inp-event').value;
                    if (!Season.state.inProgress) {
                        App.config.setLegs = parseInt(document.getElementById('inp-set-legs').value);
                        App.config.tiebreak = document.getElementById('inp-tiebreak').checked;
                    }
                }

                // Initialize Confidence for this match
                if (App.players[0]) PlayerState.initMatchConfidence(App.players[0]);
                if (App.players[1]) PlayerState.initMatchConfidence(App.players[1]);

                App.config.legsToWinSet = Math.ceil(App.config.setLegs / 2);
                document.getElementById('setup-screen').style.display = 'none';
                document.getElementById('tournament-hub').style.display = 'none';
                document.getElementById('match-screen').style.display = 'flex';
                let txt = App.config.event.toUpperCase();
                if (App.config.tiebreak && App.config.mode === 'legs') txt += " (TB)";
                document.getElementById('txt-event-header').innerText = txt;

                const p0 = App.players[0]; const p1 = App.players[1];
                document.getElementById('name-p0').innerText = p0.name;
                document.getElementById('name-p1').innerText = p1.name;
                document.getElementById('flag-p0').src = getFlagUrl(p0.country);
                document.getElementById('flag-p1').src = getFlagUrl(p1.country);
                document.getElementById('bot-name-p0').innerText = p0.name.split(' ').pop();
                document.getElementById('bot-name-p1').innerText = p1.name.split(' ').pop();

                document.getElementById('lbl-score-type').innerText = (App.config.mode === 'sets') ? "SETS" : "LEGS";

                if (App.config.mode === 'legs') {
                    document.getElementById('bot-sets-p0').style.display = "none";
                    document.getElementById('bot-sets-p1').style.display = "none";
                    document.getElementById('bot-legs-p0').className = "main-score";
                    document.getElementById('bot-legs-p1').className = "main-score";
                } else {
                    document.getElementById('bot-sets-p0').style.display = "block";
                    document.getElementById('bot-sets-p1').style.display = "block";
                    document.getElementById('bot-legs-p0').className = "sub-score";
                    document.getElementById('bot-legs-p1').className = "sub-score";
                }
                App.matchState = { sets: [0, 0], legs: [0, 0], starterLeg: 0, starterSet: 0, currentThrower: 0 };
                App.matchState.starterSet = Math.random() < 0.5 ? 0 : 1;
                App.matchState.starterLeg = App.matchState.starterSet;

                App.isPaused = false;
                Persistence.save();

                // Apply event-specific colors
                App.applyEventColors(App.config.event);

                Tournament.playIntroSequence(App.players[0], App.players[1]);
            },

            showPostMatch: () => {
                document.getElementById('overlay-end').style.display = 'none';
                const p0 = App.players[0]; const p1 = App.players[1];

                document.getElementById('stats-event-name').innerText = App.config.event;
                document.getElementById('stats-p0-flag').src = getFlagUrl(p0.country);
                document.getElementById('stats-p1-flag').src = getFlagUrl(p1.country);
                document.getElementById('stats-p0-name').innerText = p0.name;
                document.getElementById('stats-p1-name').innerText = p1.name;

                const avg0 = p0.stats.darts ? ((p0.stats.pts / p0.stats.darts) * 3).toFixed(2) : "0.00";
                const avg1 = p1.stats.darts ? ((p1.stats.pts / p1.stats.darts) * 3).toFixed(2) : "0.00";
                document.getElementById('st-avg-0').innerText = avg0;
                document.getElementById('st-avg-1').innerText = avg1;
                document.getElementById('st-avg-0').className = `stat-val ${parseFloat(avg0) > parseFloat(avg1) ? 'winner' : ''}`;
                document.getElementById('st-avg-1').className = `stat-val ${parseFloat(avg1) > parseFloat(avg0) ? 'winner' : ''}`;

                document.getElementById('st-180-0').innerText = p0.stats.c180;
                document.getElementById('st-180-1').innerText = p1.stats.c180;

                const co0 = p0.stats.coAtt > 0 ? ((p0.stats.coHit / p0.stats.coAtt) * 100).toFixed(1) + "%" : "0%";
                const co1 = p1.stats.coAtt > 0 ? ((p1.stats.coHit / p1.stats.coAtt) * 100).toFixed(1) + "%" : "0%";
                document.getElementById('st-co-0').innerText = co0 + ` (${p0.stats.coHit}/${p0.stats.coAtt})`;
                document.getElementById('st-co-1').innerText = co1 + ` (${p1.stats.coHit}/${p1.stats.coAtt})`;

                document.getElementById('st-high-0').innerText = p0.stats.highOut;
                document.getElementById('st-high-1').innerText = p1.stats.highOut;

                document.getElementById('st-tonplus-0').innerText = p0.stats.tonPlus;
                document.getElementById('st-tonplus-1').innerText = p1.stats.tonPlus;

                const legsRow = document.getElementById('row-legs-won');
                if (App.config.mode === 'sets') {
                    legsRow.style.display = 'contents';
                    document.getElementById('st-legs-0').innerText = p0.stats.legsWon;
                    document.getElementById('st-legs-1').innerText = p1.stats.legsWon;
                } else {
                    legsRow.style.display = 'none';
                }

                const btn = document.getElementById('btn-stats-continue');
                if (Tournament.state.active && Tournament.state.matchQueue && Tournament.state.matchQueue.length > 0) {
                    btn.innerText = "NEXT MATCH >>";
                    btn.style.background = "#e65100";
                    // Auto-advance to next match after stats display
                    // Store timer ID so it can be cancelled if user clicks manually
                    App._autoAdvanceTimer = setTimeout(() => {
                        // Only auto-advance if post-match screen is still visible
                        if (Tournament.state.matchQueue && Tournament.state.matchQueue.length > 0 && document.getElementById('post-match-screen').style.display === 'flex') {
                            App.returnToMenu();
                        }
                    }, 3000);
                } else {
                    btn.innerText = "CONTINUE";
                    btn.style.background = "var(--pdc-gold)";
                }

                document.getElementById('post-match-screen').style.display = 'flex';
                Persistence.save();

                SOUND_OUTRO.currentTime = 0;
                SOUND_OUTRO.play().catch(e => console.log(e));
            },

            returnToMenu: () => {
                // Cancel auto-advance timer if it exists
                if (App._autoAdvanceTimer) {
                    clearTimeout(App._autoAdvanceTimer);
                    App._autoAdvanceTimer = null;
                }

                // Guard: Only process if post-match screen is visible (prevents double-processing)
                if (document.getElementById('post-match-screen').style.display !== 'flex') {
                    return;
                }

                SOUND_OUTRO.pause();
                SOUND_OUTRO.currentTime = 0;

                document.getElementById('post-match-screen').style.display = 'none';
                if (Tournament.state.active) {
                    const winnerIdx = (App.matchState.sets[0] > App.matchState.sets[1] || App.matchState.legs[0] > App.matchState.legs[1]) ? 0 : 1;
                    let scoreStr = (App.config.mode === 'sets')
                        ? `${App.matchState.sets[0]} - ${App.matchState.sets[1]}`
                        : `${App.matchState.legs[0]} - ${App.matchState.legs[1]}`;

                    const avg0 = App.players[0].stats.darts ? ((App.players[0].stats.pts / App.players[0].stats.darts) * 3).toFixed(2) : "0.00";
                    const avg1 = App.players[1].stats.darts ? ((App.players[1].stats.pts / App.players[1].stats.darts) * 3).toFixed(2) : "0.00";

                    Tournament.onMatchFinished(winnerIdx, scoreStr, [avg0, avg1]);
                } else {
                    Persistence.clear();
                }
            },

            setupMatch: () => {
                // Setup the first leg but keep match paused
                App.players[0].score = 501;
                App.players[1].score = 501;
                document.getElementById('visit-container').innerHTML = '';
                App.updateScoreboard();
                App.matchState.currentThrower = App.matchState.starterLeg;
                const legCount = App.matchState.legs[0] + App.matchState.legs[1] + 1;
                const setDisplay = App.config.mode === 'sets' ? ` (Set ${App.matchState.sets[0] + App.matchState.sets[1] + 1})` : '';
                document.getElementById('intro-title-txt').innerText = `LEG ${legCount}${setDisplay}`;
                document.getElementById('intro-name-txt').innerText = App.players[App.matchState.starterLeg].name;
                document.getElementById('overlay-intro').style.display = 'flex';

                // Set match to paused state
                App.isPaused = true;
                Persistence.save();

                setTimeout(() => {
                    try {
                        document.getElementById('overlay-intro').style.display = 'none';
                        // Show pause overlay with resume button
                        App.updatePauseInfo();
                        document.getElementById('overlay-resume').style.display = 'flex';
                    } catch (e) {
                        console.error(e);
                        alert("Game Crash! Returning to Menu.");
                        Persistence.clear();
                    }
                }, 1200);
            },

            startLeg: () => {
                // Cancel any pending game loop from previous match/leg
                App._gameLoopId = (App._gameLoopId || 0) + 1;
                const currentLoopId = App._gameLoopId;

                // üî• FIX: mindig a round target legyen az igazs√°g (only for tournaments)
                if (Tournament.config && Tournament.config.rounds && Tournament.state && Tournament.state.currentActiveRound !== undefined) {
                    const roundInfo = Tournament.config.rounds[Tournament.state.currentActiveRound];
                    if (roundInfo && roundInfo.target) {
                        App.config.target = roundInfo.target;
                    }
                }

                App.players[0].score = 501;
                App.players[1].score = 501;
                document.getElementById('visit-container').innerHTML = '';
                App.updateScoreboard();
                App.matchState.currentThrower = App.matchState.starterLeg;
                const legCount = App.matchState.legs[0] + App.matchState.legs[1] + 1;
                const setDisplay = App.config.mode === 'sets' ? ` (Set ${App.matchState.sets[0] + App.matchState.sets[1] + 1})` : '';
                document.getElementById('intro-title-txt').innerText = `LEG ${legCount}${setDisplay}`;
                document.getElementById('intro-name-txt').innerText = App.players[App.matchState.starterLeg].name;
                document.getElementById('overlay-intro').style.display = 'flex';
                setTimeout(() => {
                    // Guard: Only proceed if this is still the current game loop
                    if (App._gameLoopId !== currentLoopId) return;
                    try {
                        document.getElementById('overlay-intro').style.display = 'none';
                        App.gameLoop();
                    } catch (e) {
                        console.error(e);
                        alert("Game Crash! Returning to Menu.");
                        Persistence.clear();
                    }
                }, 1200);
            },
            trigger180: () => {
                SOUND_180.play().catch(e => console.log(e));
                document.getElementById('overlay-180').style.display = 'flex';
                setTimeout(() => { document.getElementById('overlay-180').style.display = 'none'; }, 1500);
            },
            gameLoop: () => {
                if (App.isPaused) return;

                // Guard against stale game loops from previous matches
                const currentLoopId = App._gameLoopId || 0;

                const pIdx = App.matchState.currentThrower;
                const p = App.players[pIdx];
                App.ensureRow();

                document.getElementById('card-p0').className = `player-card ${pIdx === 0 ? 'active' : ''}`;
                document.getElementById('card-p1').className = `player-card ${pIdx === 1 ? 'active' : ''}`;

                // Apply dynamic active gradient from theme data
                App.applyActivePlayerTheme(pIdx);

                const rows = document.getElementById('visit-container').children;
                if (rows.length > 0) {
                    const row = rows[rows.length - 1];
                    const al = row.querySelector('#al');
                    const ar = row.querySelector('#ar');
                    if (al && ar) {
                        al.style.opacity = pIdx === 0 ? 1 : 0;
                        ar.style.opacity = pIdx === 1 ? 1 : 0;
                    }
                }

                setTimeout(() => {
                    // Guard: check if this game loop is still valid
                    if (App.isPaused || App._gameLoopId !== currentLoopId) return;

                    const legs = App.matchState.legs;
                    const isDecider = (App.config.mode === 'sets') ? (legs[0] === legs[1] && legs[0] === App.config.legsToWinSet - 1) : false;
                    const result = Logic.processVisit(p, isDecider);

                    // Confidence Logic (Missed opportunities)
                    const canCheckout = (p.score <= 170 && ![169, 168, 166, 165, 163, 162, 159].includes(p.score));
                    if (canCheckout) {
                        if (result.points === 0) PlayerState.updateConfidence(p, -4);
                    }

                    p.score -= result.points;
                    p.stats.pts += result.points;
                    p.stats.darts += result.dartsThrown;

                    let delay = 1200;

                    if (result.points === 180) {
                        p.stats.c180++;
                        PlayerState.updateConfidence(p, 2);
                        PlayerState.updateConfidence(App.players[1 - pIdx], -2);
                        App.trigger180();
                        delay = 3000;
                    } else if (result.points === 167) {
                        SOUND_167.play().catch(e => console.log(e));
                        delay = 2000;
                    }

                    const rows = document.getElementById('visit-container').children;
                    const row = rows[rows.length - 1];
                    if (pIdx === 0) { row.querySelector('.v-left').innerText = result.points; }
                    else { row.querySelector('.v-right').innerText = result.points; }

                    App.updateScoreboard();
                    Persistence.save();

                    if (result.endLeg) { App.handleLegWin(pIdx, result.points); }
                    else {
                        App.matchState.currentThrower = 1 - pIdx;
                        setTimeout(() => {
                            if (App._gameLoopId === currentLoopId) App.gameLoop();
                        }, delay);
                    }
                }, 1200);
            },

            ensureRow: () => {
                const container = document.getElementById('visit-container');
                const last = container.lastElementChild;
                const pIdx = App.matchState.currentThrower;
                let needNew = false;

                if (!last) {
                    needNew = true;
                } else {
                    if (pIdx === 0 && last.querySelector('.v-left').innerText !== "") needNew = true;
                    if (pIdx === 1 && last.querySelector('.v-right').innerText !== "") needNew = true;
                }

                if (needNew && (pIdx === App.matchState.starterLeg || container.children.length === 0)) {
                    const div = document.createElement('div');
                    div.className = 'visit-row';
                    const rNum = container.children.length + 1;
                    const oL = pIdx === 0 ? 1 : 0;
                    const oR = pIdx === 1 ? 1 : 0;

                    div.innerHTML = `<div class="v-score v-left"></div><div class="v-arrow" id="al" style="opacity:${oL}">‚ñ∂</div><div class="v-round">${rNum}</div><div class="v-arrow" id="ar" style="opacity:${oR}">‚óÄ</div><div class="v-score v-right"></div>`;
                    container.appendChild(div); container.scrollTop = container.scrollHeight;
                }
            },

            handleLegWin: (idx, checkoutScore) => {
                const overlay = document.getElementById('overlay-shot');
                const p = App.players[idx];
                const loser = App.players[1 - idx];

                // Player State Updates
                PlayerState.updateConfidence(p, 3);
                PlayerState.updateConfidence(loser, -3);
                PlayerState.updateFatigue(p, 2);
                PlayerState.updateFatigue(loser, 2);
                if (App.matchState.starterLeg !== idx) PlayerState.updateConfidence(p, 4); // Break

                p.stats.legsWon++;
                if (checkoutScore > p.stats.highOut) p.stats.highOut = checkoutScore;

                if (checkoutScore >= 100) {
                    p.stats.tonPlus++;
                    PlayerState.updateConfidence(p, 3);
                    overlay.innerHTML = `<div class="high-checkout-box">${checkoutScore}</div>`;
                    SOUND_BIG_CHECKOUT.play().catch(e => console.log(e));
                }
                else { overlay.innerHTML = `<div class="game-shot-box">GAME SHOT</div>`; }

                overlay.style.display = 'flex';
                setTimeout(() => {
                    overlay.style.display = 'none';
                    App.matchState.legs[idx]++;
                    let matchWon = false;
                    if (App.config.mode === 'sets') {
                        if (App.matchState.legs[idx] >= App.config.legsToWinSet) {
                            App.matchState.sets[idx]++;
                            // Set Won
                            PlayerState.updateFatigue(p, 5);
                            PlayerState.updateFatigue(loser, 5);
                            App.matchState.legs = [0, 0];
                            App.matchState.starterSet = 1 - App.matchState.starterSet;
                            App.matchState.starterLeg = App.matchState.starterSet;
                            if (App.matchState.sets[idx] >= App.config.target) matchWon = true;
                        } else { App.matchState.starterLeg = 1 - App.matchState.starterLeg; }
                    } else {
                        const legs = App.matchState.legs[idx];
                        const opp = App.matchState.legs[1 - idx];
                        const target = App.config.target;
                        if (App.config.tiebreak) { if (legs >= target && legs >= opp + 2) matchWon = true; }
                        else { if (legs >= target) matchWon = true; }
                        App.matchState.starterLeg = 1 - App.matchState.starterLeg;
                    }
                    App.updateScoreboard();
                    Persistence.save();

                    if (matchWon) {
                        const winner = App.players[idx];
                        document.getElementById('end-winner-name').innerText = winner.name;
                        let scoreStr = (App.config.mode === 'sets') ? `${App.matchState.sets[idx]} - ${App.matchState.sets[1 - idx]}` : `${App.matchState.legs[idx]} - ${App.matchState.legs[1 - idx]}`;
                        document.getElementById('end-score-txt').innerText = scoreStr;
                        const btn = document.querySelector('#overlay-end button');
                        btn.onclick = App.showPostMatch;
                        btn.innerText = "VIEW STATS";
                        document.getElementById('overlay-end').style.display = 'flex';
                    } else { App.startLeg(); }
                }, 2000);
            },
            updateScoreboard: () => {
                const p0 = App.players[0]; const p1 = App.players[1];
                document.getElementById('score-p0').innerText = p0.score;
                document.getElementById('score-p1').innerText = p1.score;
                const avg0 = p0.stats.darts ? ((p0.stats.pts / p0.stats.darts) * 3).toFixed(2) : "0.00";
                const avg1 = p1.stats.darts ? ((p1.stats.pts / p1.stats.darts) * 3).toFixed(2) : "0.00";

                document.getElementById('avg-p0').innerText = `AVG ${avg0}`;
                document.getElementById('avg-p1').innerText = `AVG ${avg1}`;

                const starter = App.matchState.starterLeg;
                document.getElementById('dot-p0').style.display = (starter === 0) ? 'block' : 'none';
                document.getElementById('dot-p1').style.display = (starter === 1) ? 'block' : 'none';

                const current = App.matchState.currentThrower;
                document.getElementById('card-p0').className = `player-card ${current === 0 ? 'active' : ''}`;
                document.getElementById('card-p1').className = `player-card ${current === 1 ? 'active' : ''}`;

                // Apply dynamic active gradient from theme data
                App.applyActivePlayerTheme(current);

                const rows = document.getElementById('visit-container').children;
                if (rows.length > 0) {
                    const row = rows[rows.length - 1];
                    const al = row.querySelector('#al');
                    const ar = row.querySelector('#ar');
                    if (al && ar) {
                        al.style.opacity = current === 0 ? 1 : 0;
                        ar.style.opacity = current === 1 ? 1 : 0;
                    }
                }

                if (App.config.mode === 'sets') {
                    document.getElementById('bot-sets-p0').innerText = App.matchState.sets[0];
                    document.getElementById('bot-sets-p1').innerText = App.matchState.sets[1];
                    document.getElementById('bot-legs-p0').innerText = App.matchState.legs[0];
                    document.getElementById('bot-legs-p1').innerText = App.matchState.legs[1];
                } else {
                    document.getElementById('bot-legs-p0').innerText = App.matchState.legs[0];
                    document.getElementById('bot-legs-p1').innerText = App.matchState.legs[1];
                }
            },

            simulateMatchToEnd: () => {
                App.isPaused = true;
                document.getElementById('overlay-resume').style.display = 'none';

                const p0 = App.players[0];
                const p1 = App.players[1];
                const target = App.config.target;
                const mode = App.config.mode;

                let winProbP0 = 0.50 + ((p0.avg - p1.avg) * 0.025);

                // Helper function to simulate a leg with proper stats
                const simulateLeg = (isWinner) => {
                    const winner = App.players[isWinner ? 0 : 1];
                    const loser = App.players[isWinner ? 1 : 0];

                    // Calculate darts realistically
                    const winnerDarts = Math.max(15, Math.round(501 / (winner.avg / 3) + (Math.random() * 4 - 2)));
                    winner.stats.darts += winnerDarts;
                    winner.stats.pts += 501;
                    winner.stats.legsWon++;

                    // Add 180s randomly based on average (rough estimate: 1 per 30 darts for average player)
                    const expected180s = winnerDarts / (100 / winner.avg) / 4;
                    if (Math.random() < expected180s) {
                        winner.stats.c180++;
                    }

                    // Estimate checkout attempts and hits based on player skill
                    // Winner always has 1-3 checkout attempts per leg (realistically)
                    const attempts = Math.floor(Math.random() * 2) + 1;
                    winner.stats.coAtt += attempts;
                    // Last attempt is always the successful checkout
                    winner.stats.coHit++;
                    const checkoutScore = Math.round(20 + Math.random() * 80);
                    if (checkoutScore > winner.stats.highOut) winner.stats.highOut = checkoutScore;
                    if (checkoutScore >= 100) winner.stats.tonPlus++;

                    // Loser may also have had checkout attempts but missed
                    const loserAttempts = Math.floor(Math.random() * 3);
                    if (loserAttempts > 0) {
                        loser.stats.coAtt += loserAttempts;
                        // Sometimes hits one but not the final one
                        if (Math.random() < (loser.co / 100) * 0.5) {
                            loser.stats.coHit += Math.floor(Math.random() * loserAttempts);
                        }
                    }

                    // Loser gets partial score
                    const loserPartialAvg = loser.avg * (0.7 + Math.random() * 0.3);
                    const loserDarts = Math.max(15, Math.round(Math.random() * 20) + 15);
                    const loserPts = Math.round((loserPartialAvg / 3) * loserDarts);
                    loser.stats.darts += loserDarts;
                    loser.stats.pts += loserPts;

                    // Add some 180s to loser too
                    const loserExpected180s = loserDarts / (100 / loser.avg) / 4;
                    if (Math.random() < loserExpected180s) {
                        loser.stats.c180++;
                    }
                };

                if (mode === 'legs') {
                    // Simulate remaining legs
                    while (App.matchState.legs[0] < target && App.matchState.legs[1] < target) {
                        const legWinner = Math.random() < winProbP0 ? 0 : 1;
                        App.matchState.legs[legWinner]++;
                        simulateLeg(legWinner === 0);
                    }
                } else {
                    // Simulate remaining sets
                    const legsToWinSet = App.config.legsToWinSet;

                    while (App.matchState.sets[0] < target && App.matchState.sets[1] < target) {
                        // Simulate set
                        let setLegs = [0, 0];
                        while (setLegs[0] < legsToWinSet && setLegs[1] < legsToWinSet) {
                            const legWinner = Math.random() < winProbP0 ? 0 : 1;
                            setLegs[legWinner]++;
                            simulateLeg(legWinner === 0);
                        }

                        if (setLegs[0] > setLegs[1]) {
                            App.matchState.sets[0]++;
                        } else {
                            App.matchState.sets[1]++;
                        }

                        App.matchState.legs[0] += setLegs[0];
                        App.matchState.legs[1] += setLegs[1];
                    }
                }

                // Determine winner
                let winnerIdx;
                if (mode === 'legs') {
                    const tiebreak = App.config.tiebreak;
                    if (tiebreak && App.matchState.legs[0] === App.matchState.legs[1]) {
                        winnerIdx = Math.random() < 0.5 ? 0 : 1;
                    } else {
                        winnerIdx = App.matchState.legs[0] >= target ? 0 : 1;
                    }
                } else {
                    winnerIdx = App.matchState.sets[0] >= target ? 0 : 1;
                }

                App.updateScoreboard();

                // Show the end screen
                const winner = App.players[winnerIdx];
                document.getElementById('end-winner-name').innerText = winner.name;
                let scoreStr = (App.config.mode === 'sets') ? `${App.matchState.sets[winnerIdx]} - ${App.matchState.sets[1 - winnerIdx]}` : `${App.matchState.legs[winnerIdx]} - ${App.matchState.legs[1 - winnerIdx]}`;
                document.getElementById('end-score-txt').innerText = scoreStr;
                const btn = document.querySelector('#overlay-end button');
                btn.onclick = App.showPostMatch;
                btn.innerText = "VIEW STATS";
                document.getElementById('overlay-end').style.display = 'flex';

                // Auto-continue to next match if in tournament mode with queued matches
                if (Tournament.state.active && Tournament.state.matchQueue && Tournament.state.matchQueue.length > 0) {
                    setTimeout(() => {
                        App.showPostMatch();
                    }, 2000);
                }
            },

            togglePause: () => {
                App.isPaused = !App.isPaused;
                if (App.isPaused) {
                    App.updatePauseInfo();
                    document.getElementById('overlay-resume').style.display = 'flex';
                } else {
                    document.getElementById('overlay-resume').style.display = 'none';
                    App.gameLoop();
                }
            },
            resumeFromReload: () => {
                SOUND_180.load();
                SOUND_167.load();
                SOUND_BIG_CHECKOUT.load();
                SOUND_INTRO.load();
                SOUND_OUTRO.load();

                App.isPaused = false;
                document.getElementById('overlay-resume').style.display = 'none';
                setTimeout(App.gameLoop, 500);
            },
            updatePauseInfo: () => {
                let info = "";
                if (App.config.mode === 'sets') {
                    info = `First to ${App.config.target} Sets`;
                } else {
                    const tb = App.config.tiebreak ? "(Tiebreak: ON)" : "";
                    info = `First to ${App.config.target} Legs ${tb}`;
                }
                document.getElementById('pause-info-text').innerText = info;
            }
        };

        // ================= SERVER CONFIG =================
        // Change this to your server's API URL
        const API_BASE_URL = '/api'; // e.g., 'https://yourserver.com/api' or '/api' for same domain

        // ================= AUTH SYSTEM =================
        window.AuthSystem = {
            currentUser: null,
            isInitialized: false,

            // Serialize with Set support
            serialize: (obj) => {
                return JSON.stringify(obj, (key, value) => {
                    if (value instanceof Set) return { __set: [...value] };
                    return value;
                });
            },

            // Deserialize with Set support
            deserialize: (str) => {
                return JSON.parse(str, (key, value) => {
                    if (value && value.__set) return new Set(value.__set);
                    return value;
                });
            },

            // API helper function
            apiCall: async (endpoint, method = 'GET', data = null) => {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout

                const options = {
                    method: method,
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    signal: controller.signal
                };

                if (data) {
                    options.body = JSON.stringify(data);
                    console.log(`API ${method} ${endpoint}, payload size:`, JSON.stringify(data).length);
                }

                if (AuthSystem.currentUser && AuthSystem.currentUser.token) {
                    options.headers['Authorization'] = 'Bearer ' + AuthSystem.currentUser.token;
                }

                try {
                    const response = await fetch(API_BASE_URL + endpoint, options);
                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error(`API error ${response.status}:`, errorText);
                        throw new Error(`HTTP ${response.status}: ${errorText}`);
                    }

                    const result = await response.json();
                    return result;
                } catch (error) {
                    clearTimeout(timeoutId);
                    if (error.name === 'AbortError') {
                        throw new Error('Request timeout - server may be overloaded');
                    }
                    console.error('API call failed:', error);
                    throw error;
                }
            },

            init: async () => {
                try {
                    // Check for saved login
                    const savedUser = localStorage.getItem('pdc_auth_user');
                    if (savedUser) {
                        AuthSystem.currentUser = JSON.parse(savedUser);
                        AuthSystem.updateUIStatus();
                        // Verify token is still valid
                        try {
                            const result = await AuthSystem.apiCall('/verify', 'POST');
                            if (result.success) {
                                await AuthSystem.loadFromCloud();
                            } else {
                                // Token expired, clear login
                                AuthSystem.logout();
                            }
                        } catch (e) {
                            console.log('Server not available, using local data');
                        }
                    }
                    AuthSystem.isInitialized = true;
                } catch (e) {
                    console.log('Auth init error:', e.message);
                }
            },

            showModal: () => {
                const modal = document.getElementById('auth-modal');
                modal.style.display = 'flex';
                AuthSystem.updateModalView();
            },

            closeModal: () => {
                document.getElementById('auth-modal').style.display = 'none';
            },

            updateModalView: () => {
                const loginView = document.getElementById('auth-login-view');
                const accountView = document.getElementById('auth-account-view');

                if (AuthSystem.currentUser) {
                    loginView.style.display = 'none';
                    accountView.style.display = 'block';
                    document.getElementById('auth-username-display').innerText = AuthSystem.currentUser.username;
                    document.getElementById('auth-last-sync').innerText = AuthSystem.currentUser.lastSync || 'Never';
                } else {
                    loginView.style.display = 'block';
                    accountView.style.display = 'none';
                }
            },

            updateUIStatus: () => {
                // Update any UI elements showing login status
                const accountBtns = document.querySelectorAll('[onclick="AuthSystem.showModal()"]');
                accountBtns.forEach(btn => {
                    if (AuthSystem.currentUser) {
                        const name = AuthSystem.currentUser.username.substring(0, 8);
                        if (btn.classList.contains('career-pill')) {
                            btn.innerHTML = `üë§ <span>${name}</span>`;
                        } else {
                            btn.innerHTML = 'üë§ ' + name;
                        }
                    } else {
                        if (btn.classList.contains('career-pill')) {
                            btn.innerHTML = `üë§ <span>LOGIN</span>`;
                        } else {
                            btn.innerHTML = 'üë§ ACCOUNT';
                        }
                    }
                });
            },

            switchToRegister: () => {
                document.getElementById('auth-login-form').style.display = 'none';
                document.getElementById('auth-register-form').style.display = 'block';
            },

            switchToLogin: () => {
                document.getElementById('auth-login-form').style.display = 'block';
                document.getElementById('auth-register-form').style.display = 'none';
            },

            hashPassword: async (password) => {
                const encoder = new TextEncoder();
                const data = encoder.encode(password + 'pdc_darts_salt_2026');
                const hash = await crypto.subtle.digest('SHA-256', data);
                return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join('');
            },

            register: async () => {
                const username = document.getElementById('reg-username').value.trim();
                const password = document.getElementById('reg-password').value;
                const confirmPassword = document.getElementById('reg-confirm-password').value;
                const errorEl = document.getElementById('auth-error');

                errorEl.innerText = '';

                if (!username || username.length < 3) {
                    errorEl.innerText = 'Username must be at least 3 characters';
                    return;
                }
                if (!password || password.length < 6) {
                    errorEl.innerText = 'Password must be at least 6 characters';
                    return;
                }
                if (password !== confirmPassword) {
                    errorEl.innerText = 'Passwords do not match';
                    return;
                }

                try {
                    const result = await AuthSystem.apiCall('/register', 'POST', {
                        username: username,
                        password: password
                    });

                    if (!result.success) {
                        errorEl.innerText = result.error || 'Registration failed';
                        return;
                    }

                    // Auto login after register
                    AuthSystem.currentUser = {
                        username: result.username,
                        userId: result.userId,
                        token: result.token,
                        lastSync: null
                    };
                    localStorage.setItem('pdc_auth_user', JSON.stringify(AuthSystem.currentUser));
                    AuthSystem.updateUIStatus();
                    AuthSystem.updateModalView();

                    // Save current progress to server
                    await AuthSystem.saveToCloud();

                } catch (e) {
                    console.error('Register error:', e);
                    errorEl.innerText = 'Server unavailable. Try again later.';
                }
            },

            login: async () => {
                const username = document.getElementById('login-username').value.trim();
                const password = document.getElementById('login-password').value;
                const errorEl = document.getElementById('auth-error');

                errorEl.innerText = '';

                if (!username || !password) {
                    errorEl.innerText = 'Please enter username and password';
                    return;
                }

                try {
                    const result = await AuthSystem.apiCall('/login', 'POST', {
                        username: username,
                        password: password
                    });

                    if (!result.success) {
                        errorEl.innerText = result.error || 'Login failed';
                        return;
                    }

                    AuthSystem.currentUser = {
                        username: result.username,
                        userId: result.userId,
                        token: result.token,
                        lastSync: result.lastSync || null
                    };
                    localStorage.setItem('pdc_auth_user', JSON.stringify(AuthSystem.currentUser));
                    AuthSystem.updateUIStatus();
                    AuthSystem.updateModalView();

                    // Load server save
                    await AuthSystem.loadFromCloud();

                } catch (e) {
                    console.error('Login error:', e);
                    errorEl.innerText = 'Server unavailable. Try again later.';
                }
            },

            logout: () => {
                AuthSystem.currentUser = null;
                localStorage.removeItem('pdc_auth_user');
                AuthSystem.updateUIStatus();
                AuthSystem.updateModalView();
            },

            getGameState: () => {
                // Prune season state to remove bulky participation data
                const prunedSeason = { ...Season.state };
                if (prunedSeason.completedEvents) {
                    prunedSeason.completedEvents = prunedSeason.completedEvents.map(ev => {
                        const { participations, ...rest } = ev;
                        return rest;
                    });
                }

                const state = {
                    season: prunedSeason,
                    app: {
                        config: App.config
                    },
                    players: PLAYERS_DB.map(p => ({
                        n: p.name,
                        f: p.form,
                        ft: p.fatigue,
                        m: p.money
                    })),
                    tournament: {
                        config: Tournament.config,
                        state: {
                            ...Tournament.state,
                            selectedPlayerIndices: [...Tournament.state.selectedPlayerIndices]
                        }
                    },
                    savedAt: Date.now()
                };

                // Log state sizes for debugging
                const seasonSize = JSON.stringify(state.season).length;
                const playersSize = JSON.stringify(state.players).length;
                const totalSize = JSON.stringify(state).length;
                console.log(`Game state sizes - Season: ${seasonSize}, Players: ${playersSize}, Total: ${totalSize} characters`);

                return state;
            },

            applyGameState: (data) => {
                if (data.season) {
                    Season.state = { ...Season.state, ...data.season };
                    // Ensure completedEvents stays as an array
                    if (data.season.completedEvents) {
                        if (data.season.completedEvents.__set) {
                            // Convert from Set serialization format back to array
                            Season.state.completedEvents = data.season.completedEvents.__set;
                        } else if (Array.isArray(data.season.completedEvents)) {
                            Season.state.completedEvents = data.season.completedEvents;
                        } else {
                            Season.state.completedEvents = [];
                        }
                    }
                }

                if (data.app && data.app.config) {
                    App.config = { ...App.config, ...data.app.config };
                    if (App.applyEventColors && App.config.event) {
                        App.applyEventColors(App.config.event);
                    }
                }

                // Restore tournament state
                if (data.tournament) {
                    if (data.tournament.config) {
                        Tournament.config = { ...Tournament.config, ...data.tournament.config };
                    }
                    if (data.tournament.state) {
                        Tournament.state = { ...Tournament.state, ...data.tournament.state };
                        // Restore Set from array
                        if (Array.isArray(data.tournament.state.selectedPlayerIndices)) {
                            Tournament.state.selectedPlayerIndices = new Set(data.tournament.state.selectedPlayerIndices);
                        }
                    }
                    // Always apply event colors based on tournament name (handles both custom themes and preset themes)
                    if (App.applyEventColors && data.tournament.config) {
                        const eventName = data.tournament.config.name || App.config.event || '';
                        App.applyEventColors(eventName);
                    }
                }
                if (data.players) {
                    data.players.forEach(sp => {
                        const p = PLAYERS_DB.find(x => x.name === sp.n);
                        if (p) {
                            p.form = sp.f || 0;
                            p.fatigue = sp.ft || 0;
                            p.money = sp.m || 0;
                        }
                    });
                }
            },

            saveToCloud: async () => {
                if (!AuthSystem.currentUser) {
                    alert('Please log in to save to server');
                    return;
                }

                try {
                    const saveBtn = document.getElementById('auth-save-btn');
                    if (saveBtn) saveBtn.innerText = '‚è≥ Saving...';

                    const gameState = AuthSystem.getGameState();
                    const serialized = AuthSystem.serialize(gameState);

                    console.log('Save data size:', serialized.length, 'characters');

                    const result = await AuthSystem.apiCall('/save', 'POST', {
                        data: serialized,
                        saveType: 'career_v2' // Separate identifier for server
                    });

                    if (!result.success) {
                        throw new Error(result.error || 'Save failed');
                    }

                    const now = new Date().toLocaleString();
                    AuthSystem.currentUser.lastSync = now;
                    localStorage.setItem('pdc_auth_user', JSON.stringify(AuthSystem.currentUser));
                    document.getElementById('auth-last-sync').innerText = now;

                    if (saveBtn) {
                        saveBtn.innerText = '‚úì Saved!';
                        setTimeout(() => saveBtn.innerText = 'üíæ SAVE TO SERVER', 2000);
                    }

                } catch (e) {
                    console.error('Save error:', e);
                    console.error('Error details:', e.message, e.stack);
                    alert('Failed to save. Check your connection.');
                    const saveBtn = document.getElementById('auth-save-btn');
                    if (saveBtn) saveBtn.innerText = 'üíæ SAVE TO SERVER';
                }
            },

            loadFromCloud: async () => {
                if (!AuthSystem.currentUser) return false;

                try {
                    const loadBtn = document.getElementById('auth-load-btn');
                    if (loadBtn) loadBtn.innerText = '‚è≥ Loading...';

                    const result = await AuthSystem.apiCall('/load?type=career_v2', 'GET');

                    if (result.success && result.data) {
                        const gameState = AuthSystem.deserialize(result.data);
                        AuthSystem.applyGameState(gameState);

                        // Update local persistence
                        Persistence.save('season');

                        // Refresh UI
                        if (typeof Season !== 'undefined' && Season.renderUI) {
                            Season.renderUI();
                            Tournament.updateThemeSelector();
                        }

                        if (loadBtn) {
                            loadBtn.innerText = '‚úì Loaded!';
                            setTimeout(() => loadBtn.innerText = 'üì• LOAD FROM SERVER', 2000);
                        }
                        return true;
                    } else {
                        if (loadBtn) loadBtn.innerText = 'üì• LOAD FROM SERVER';
                        return false;
                    }

                } catch (e) {
                    console.error('Load error:', e);
                    const loadBtn = document.getElementById('auth-load-btn');
                    if (loadBtn) loadBtn.innerText = 'üì• LOAD FROM SERVER';
                    return false;
                }
            }
        };

        // INITIALIZATION - Async to load from database first
        document.addEventListener("DOMContentLoaded", async () => {
            try {
                // Try to load players, tournaments, and themes from database
                console.log("[Init] Attempting to load data from database...");

                const [dbPlayers, dbTournaments, dbThemes] = await Promise.all([
                    DataLoader.loadPlayers(),
                    DataLoader.loadTournaments(),
                    DataLoader.loadThemes()
                ]);

                // If we got players from DB, use them instead of hardcoded
                if (dbPlayers && dbPlayers.length > 0) {
                    RAW_PLAYERS.length = 0; // Clear the array
                    dbPlayers.forEach(p => RAW_PLAYERS.push(p));
                    console.log("[Init] Using " + dbPlayers.length + " players from database");
                } else {
                    console.log("[Init] Using " + RAW_PLAYERS.length + " hardcoded players");
                }

                // If we got tournaments from DB, use them
                if (dbTournaments && dbTournaments.length > 0) {
                    Season.events = dbTournaments;
                    console.log("[Init] Using " + dbTournaments.length + " tournaments from database");
                } else {
                    console.log("[Init] Will use default tournaments");
                }

                // Themes are always loaded (server or defaults)
                console.log("[Init] Event themes loaded:", Object.keys(EVENT_THEMES).length);
                Tournament.updateThemeSelector();

                console.log("App starting, RAW_PLAYERS length:", RAW_PLAYERS.length);
                console.log("PLAYERS_DB length:", PLAYERS_DB.length);
                App.setMode('sets');
                console.log("setMode completed");

                // ===== UPDATE DETECTION =====
                const currentHash = btoa(document.documentElement.innerHTML.length + document.documentElement.innerHTML.substring(0, 100)).substring(0, 16);
                const cachedHash = localStorage.getItem('pdc_code_hash');
                if (cachedHash && cachedHash !== currentHash) {
                    // Code has been updated
                    const updateModal = document.createElement('div');
                    updateModal.style.cssText = 'position:fixed; inset:0; background:rgba(0,0,0,0.8); z-index:10000; display:flex; justify-content:center; align-items:center;';
                    updateModal.innerHTML = `
                        <div style="background:#1a1a1a; border:2px solid var(--pdc-gold); border-radius:8px; padding:30px; max-width:400px; color:white; text-align:center;">
                            <div style="font-size:20px; font-weight:bold; margin-bottom:15px; color:var(--pdc-gold);">‚ö° UPDATE AVAILABLE</div>
                            <div style="margin-bottom:20px; color:#ccc; font-size:14px;">Your application has been updated. You can either continue with the current version or reload to use the latest version.</div>
                            <div style="display:flex; gap:10px; justify-content:center;">
                                <button id="update-keep-btn" style="padding:10px 20px; background:#666; color:white; border:none; border-radius:4px; cursor:pointer; font-weight:bold;">KEEP CURRENT</button>
                                <button id="update-reload-btn" style="padding:10px 20px; background:var(--pdc-gold); color:black; border:none; border-radius:4px; cursor:pointer; font-weight:bold;">RELOAD & UPDATE</button>
                            </div>
                        </div>
                    `;
                    document.body.appendChild(updateModal);

                    document.getElementById('update-keep-btn').addEventListener('click', () => {
                        localStorage.setItem('pdc_code_hash', currentHash);
                        document.body.removeChild(updateModal);
                        App.init();
                    });

                    document.getElementById('update-reload-btn').addEventListener('click', () => {
                        localStorage.setItem('pdc_code_hash', currentHash);
                        location.reload();
                    });
                } else {
                    // No update or first run
                    localStorage.setItem('pdc_code_hash', currentHash);
                    App.init();
                }
                console.log("App initialized successfully");
            } catch (e) {
                console.error("Critical Error on startup:", e);
                console.error("Stack:", e.stack);
                alert("App failed to start. Error: " + e.message + "\n\nCheck console for details.");
                localStorage.clear();
                location.reload();
            }
        });
    </script>

    <!-- AUTH MODAL -->
    <div id="auth-modal"
        style="position:fixed; inset:0; background:rgba(0,0,0,0.85); z-index:10001; display:none; justify-content:center; align-items:center; padding:20px;">
        <div
            style="background:linear-gradient(145deg, #1a1f35, #0f1525); border:2px solid #ffd700; border-radius:12px; padding:25px; max-width:400px; width:100%; color:white;">
            <div style="font-size:18px; font-weight:bold; color:#ffd700; margin-bottom:15px; text-align:center;">üë§
                ACCOUNT</div>

            <!-- Login View (shown when not logged in) -->
            <div id="auth-login-view">
                <!-- Login Form -->
                <div id="auth-login-form">
                    <div style="margin-bottom:12px;">
                        <label style="font-size:11px; color:#aaa; display:block; margin-bottom:4px;">USERNAME</label>
                        <input type="text" id="login-username" placeholder="Enter username"
                            style="width:100%; padding:10px; background:#0a0e1a; border:1px solid #444; border-radius:4px; color:#fff; font-size:14px; box-sizing:border-box;">
                    </div>
                    <div style="margin-bottom:15px;">
                        <label style="font-size:11px; color:#aaa; display:block; margin-bottom:4px;">PASSWORD</label>
                        <input type="password" id="login-password" placeholder="Enter password"
                            style="width:100%; padding:10px; background:#0a0e1a; border:1px solid #444; border-radius:4px; color:#fff; font-size:14px; box-sizing:border-box;">
                    </div>
                    <button onclick="AuthSystem.login()"
                        style="width:100%; padding:12px; background:#0066cc; border:none; color:white; border-radius:4px; cursor:pointer; font-weight:bold; font-size:14px;">üîê
                        LOGIN</button>
                    <div style="text-align:center; margin-top:12px;">
                        <span style="color:#888; font-size:12px;">Don't have an account? </span>
                        <a href="#" onclick="AuthSystem.switchToRegister(); return false;"
                            style="color:#ffd700; font-size:12px;">Register</a>
                    </div>
                </div>

                <!-- Register Form -->
                <div id="auth-register-form" style="display:none;">
                    <div style="margin-bottom:12px;">
                        <label style="font-size:11px; color:#aaa; display:block; margin-bottom:4px;">USERNAME</label>
                        <input type="text" id="reg-username" placeholder="Choose username (min 3 chars)"
                            style="width:100%; padding:10px; background:#0a0e1a; border:1px solid #444; border-radius:4px; color:#fff; font-size:14px; box-sizing:border-box;">
                    </div>
                    <div style="margin-bottom:12px;">
                        <label style="font-size:11px; color:#aaa; display:block; margin-bottom:4px;">PASSWORD</label>
                        <input type="password" id="reg-password" placeholder="Choose password (min 6 chars)"
                            style="width:100%; padding:10px; background:#0a0e1a; border:1px solid #444; border-radius:4px; color:#fff; font-size:14px; box-sizing:border-box;">
                    </div>
                    <div style="margin-bottom:15px;">
                        <label style="font-size:11px; color:#aaa; display:block; margin-bottom:4px;">CONFIRM
                            PASSWORD</label>
                        <input type="password" id="reg-confirm-password" placeholder="Confirm password"
                            style="width:100%; padding:10px; background:#0a0e1a; border:1px solid #444; border-radius:4px; color:#fff; font-size:14px; box-sizing:border-box;">
                    </div>
                    <button onclick="AuthSystem.register()"
                        style="width:100%; padding:12px; background:#00b359; border:none; color:white; border-radius:4px; cursor:pointer; font-weight:bold; font-size:14px;">üìù
                        REGISTER</button>
                    <div style="text-align:center; margin-top:12px;">
                        <span style="color:#888; font-size:12px;">Already have an account? </span>
                        <a href="#" onclick="AuthSystem.switchToLogin(); return false;"
                            style="color:#ffd700; font-size:12px;">Login</a>
                    </div>
                </div>

                <div id="auth-error" style="color:#ff4444; font-size:12px; text-align:center; margin-top:10px;">
                </div>
            </div>

            <!-- Account View (shown when logged in) -->
            <div id="auth-account-view" style="display:none;">
                <div style="text-align:center; margin-bottom:20px;">
                    <div style="font-size:40px; margin-bottom:10px;">üë§</div>
                    <div style="font-size:16px; font-weight:bold; color:#fff;">Welcome, <span
                            id="auth-username-display"></span>!</div>
                    <div style="font-size:11px; color:#888; margin-top:5px;">Last sync: <span
                            id="auth-last-sync">Never</span></div>
                </div>

                <div style="display:flex; flex-direction:column; gap:10px; margin-bottom:20px;">
                    <button id="auth-save-btn" onclick="AuthSystem.saveToCloud()"
                        style="width:100%; padding:12px; background:#00b359; border:none; color:white; border-radius:4px; cursor:pointer; font-weight:bold;">üíæ
                        SAVE TO SERVER</button>
                    <button id="auth-load-btn" onclick="AuthSystem.loadFromCloud()"
                        style="width:100%; padding:12px; background:#0066cc; border:none; color:white; border-radius:4px; cursor:pointer; font-weight:bold;">üì•
                        LOAD FROM SERVER</button>
                </div>

                <div
                    style="padding:12px; background:rgba(0,102,0,0.2); border:1px solid #00b359; border-radius:6px; margin-bottom:15px;">
                    <div style="font-size:11px; color:#00b359;">‚úì Your progress syncs across all devices</div>
                    <div style="font-size:11px; color:#888; margin-top:4px;">Login on any device to continue your
                        career
                    </div>
                </div>

                <button onclick="AuthSystem.logout()"
                    style="width:100%; padding:10px; background:#9a0000; border:none; color:white; border-radius:4px; cursor:pointer; font-weight:bold;">üö™
                    LOGOUT</button>
            </div>

            <button onclick="AuthSystem.closeModal()"
                style="width:100%; padding:10px; background:#444; border:none; color:white; border-radius:4px; cursor:pointer; font-weight:bold; margin-top:15px;">CLOSE</button>
        </div>
    </div>



    <!-- PWA Install Button -->
    <button id="pwa-install-btn">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
            <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z" />
        </svg>
        INSTALL CAREER MODE
    </button>

    <!-- VERSION FOOTER -->
    <div id="version-footer"
        style="position: fixed; bottom: 8px; right: 12px; font-size: 12px; color: #aaa; font-family: Arial, sans-serif; z-index: 9999; pointer-events: none; background: rgba(0,0,0,0.5); padding: 4px 8px; border-radius: 4px;">
        v2.2.1 | PDC Darts Simulator
    </div>

    <!-- PWA Service Worker Registration and Install Logic -->
    <script>
        // PWA Install functionality
        let deferredPrompt;
        const installBtn = document.getElementById('pwa-install-btn');
        let swRegistration = null;

        // Register Service Worker with auto-update
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Force browser to always check for new service worker
                navigator.serviceWorker.register('./sw.js', { updateViaCache: 'none' })
                    .then(registration => {
                        console.log('SW registered:', registration);
                        swRegistration = registration;

                        // Check for updates immediately
                        registration.update();

                        // Check for updates every 30 seconds
                        setInterval(() => {
                            registration.update();
                            console.log('Checking for SW updates...');
                        }, 30000);

                        // Also check when page becomes visible again
                        document.addEventListener('visibilitychange', () => {
                            if (document.visibilityState === 'visible') {
                                registration.update();
                            }
                        });

                        // Listen for new service worker installing
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            console.log('New service worker installing...');

                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    // New version available - auto reload
                                    console.log('New version available, reloading...');
                                    // Tell the new SW to skip waiting
                                    newWorker.postMessage({ type: 'SKIP_WAITING' });
                                }
                            });
                        });
                    })
                    .catch(error => {
                        console.log('SW registration failed:', error);
                    });

                // Listen for controller change (new SW took over)
                let refreshing = false;
                navigator.serviceWorker.addEventListener('controllerchange', () => {
                    if (refreshing) return;
                    // Only reload if we were previously controlled (meaning this is an update)
                    if (!navigator.serviceWorker.controller) return;
                    refreshing = true;
                    console.log('New service worker activated, reloading page...');
                    window.location.reload();
                });

                // Listen for messages from SW
                navigator.serviceWorker.addEventListener('message', event => {
                    if (event.data && event.data.type === 'SW_UPDATED' && !refreshing) {
                        refreshing = true;
                        console.log('SW updated to version:', event.data.version);
                        window.location.reload();
                    }
                });
            });
        }

        // Check if running as PWA (standalone mode) - hide button
        if (window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true) {
            installBtn.classList.add('hidden');
        }

        // Listen for beforeinstallprompt event
        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent the mini-infobar from appearing on mobile
            e.preventDefault();
            // Stash the event so it can be triggered later
            deferredPrompt = e;
        });

        // Handle install button click
        installBtn.addEventListener('click', async () => {
            if (deferredPrompt) {
                // Show the install prompt
                deferredPrompt.prompt();
                // Wait for the user to respond to the prompt
                const { outcome } = await deferredPrompt.userChoice;
                console.log('User response to install prompt:', outcome);
                // Clear the deferred prompt
                deferredPrompt = null;
                if (outcome === 'accepted') {
                    installBtn.classList.add('hidden');
                }
            } else {
                // Fallback: Show instructions for manual install
                alert('To install this app:\n\n‚Ä¢ Chrome/Edge: Click the menu (‚ãÆ) and select "Install app"\n‚Ä¢ Safari iOS: Tap Share button and "Add to Home Screen"\n‚Ä¢ Firefox: Not supported for PWA install');
            }
        });

        // Hide button after app is installed
        window.addEventListener('appinstalled', () => {
            console.log('PWA was installed');
            installBtn.classList.add('hidden');
            deferredPrompt = null;
        });
    </script>
    <!-- Hidden elements to satisfy requirements from shared Tournament logic -->
    <div style="display:none;" aria-hidden="true">
        <input type="text" id="tourn-event-name" value="TOURNAMENT">
        <select id="tourn-size">
            <option value="4">4</option>
            <option value="8">8</option>
            <option value="16">16</option>
            <option value="32" selected>32</option>
            <option value="64">64</option>
            <option value="128">128</option>
            <option value="256">256</option>
        </select>
        <select id="inp-tourn-set-legs">
            <option value="2">2</option>
            <option value="3" selected>3</option>
            <option value="5">5</option>
        </select>
        <div id="tab-tourn"></div>
        <input type="checkbox" id="tourn-tiebreak">
        <select id="tourn-theme">
            <option value="default">Default</option>
            <option value="custom">Custom</option>
        </select>
        <input type="color" id="theme-col-1" value="#ffd700">
        <input type="color" id="theme-col-2" value="#d50000">
        <div id="tourn-rounds-container"></div>
        <input type="text" id="player-search">
        <div id="player-list-container"></div>
        <span id="sel-count">0</span>
        <span id="sel-total">0</span>
    </div>
</body>

</html>